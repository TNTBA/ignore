          }\n            }));\n            this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {\n                this.parentData.parent.focus();\n                this.cleanupExistingSubmenu(true);\n            }));\n            this.parentData.submenu.focus(selectFirstItem);\n            this.mysubmenu = this.parentData.submenu;\n        }\n        else {\n            this.parentData.submenu.focus(false);\n        }\n    }\n    updateAriaExpanded(value) {\n        var _a;\n        if (this.item) {\n            (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-expanded', value);\n        }\n    }\n    applyStyle() {\n        super.applyStyle();\n        if (!this.menuStyle) {\n            return;\n        }\n        const isSelected = this.element && this.element.classList.contains('focused');\n        const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n        if (this.submenuIndicator) {\n            this.submenuIndicator.style.color = fgColor ? `${fgColor}` : '';\n        }\n        if (this.parentData.submenu) {\n            this.parentData.submenu.style(this.menuStyle);\n        }\n    }\n    dispose() {\n        super.dispose();\n        this.hideScheduler.dispose();\n        if (this.mysubmenu) {\n            this.mysubmenu.dispose();\n            this.mysubmenu = null;\n        }\n        if (this.submenuContainer) {\n            this.submenuContainer = undefined;\n        }\n    }\n}\nclass MenuSeparatorActionViewItem extends ActionViewItem {\n    style(style) {\n        if (this.label) {\n            this.label.style.borderBottomColor = style.separatorColor ? `${style.separatorColor}` : '';\n        }\n    }\n}\nexport function cleanMnemonic(label) {\n    const regex = MENU_MNEMONIC_REGEX;\n    const matches = regex.exec(label);\n    if (!matches) {\n        return label;\n    }\n    const mnemonicInText = !matches[1];\n    return label.replace(regex, mnemonicInText ? '$2$3' : '').trim();\n}\nfunction getMenuWidgetCSS(style, isForShadowDom) {\n    let result = /* css */ `\n.monaco-menu {\n\tfont-size: 13px;\n\n}\n\n${formatRule(Codicon.menuSelection)}\n${formatRule(Codicon.menuSubmenu)}\n\n.monaco-menu .monaco-action-bar {\n\ttext-align: right;\n\toverflow: hidden;\n\twhite-space: nowrap;\n}\n\n.monaco-menu .monaco-action-bar .actions-container {\n\tdisplay: flex;\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 100%;\n\tjustify-content: flex-end;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar.reverse .actions-container {\n\tflex-direction: row-reverse;\n}\n\n.monaco-menu .monaco-action-bar .action-item {\n\tcursor: pointer;\n\tdisplay: inline-block;\n\ttransition: transform 50ms ease;\n\tposition: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled {\n\tcursor: default;\n}\n\n.monaco-menu .monaco-action-bar.animated .action-item.active {\n\ttransform: scale(1.272019649, 1.272019649); /* 1.272019649 = √φ */\n}\n\n.monaco-menu .monaco-action-bar .action-item .icon,\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: inline-block;\n}\n\n.monaco-menu .monaco-action-bar .action-item .codicon {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar .action-label {\n\tfont-size: 11px;\n\tmargin-right: 4px;\n}\n\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label,\n.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {\n\topacity: 0.4;\n}\n\n/* Vertical actions */\n\n.monaco-menu .monaco-action-bar.vertical {\n\ttext-align: left;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tdisplay: block;\n\tborder-bottom: 1px solid #bbb;\n\tpadding-top: 1px;\n\tmargin-left: .8em;\n\tmargin-right: .8em;\n}\n\n.monaco-menu .secondary-actions .monaco-action-bar .action-label {\n\tmargin-left: 6px;\n}\n\n/* Action Items */\n.monaco-menu .monaco-action-bar .action-item.select-container {\n\toverflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */\n\tflex: 1;\n\tmax-width: 170px;\n\tmin-width: 60px;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tmargin-right: 10px;\n}\n\n.monaco-menu .monaco-action-bar.vertical {\n\tmargin-left: 0;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .actions-container {\n\tdisplay: block;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tpadding: 0;\n\ttransform: none;\n\tdisplay: flex;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.active {\n\ttransform: none;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\tflex: 1 1 auto;\n\tdisplay: flex;\n\theight: 2em;\n\talign-items: center;\n\tposition: relative;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label {\n\tflex: 1 1 auto;\n\ttext-decoration: none;\n\tpadding: 0 1em;\n\tbackground: none;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .keybinding,\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tdisplay: inline-block;\n\tflex: 2 1 auto;\n\tpadding: 0 1em;\n\ttext-align: right;\n\tfont-size: 12px;\n\tline-height: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {\n\tfont-size: 16px !important;\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {\n\tmargin-left: auto;\n\tmargin-right: -20px;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,\n.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {\n\topacity: 0.4;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tmargin: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tposition: static;\n\toverflow: visible;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {\n\tposition: absolute;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tpadding: 0.5em 0 0 0;\n\tmargin-bottom: 0.5em;\n\twidth: 100%;\n\theight: 0px !important;\n\tmargin-left: .8em !important;\n\tmargin-right: .8em !important;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {\n\tpadding: 0.7em 1em 0.1em 1em;\n\tfont-weight: bold;\n\topacity: 1;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:hover {\n\tcolor: inherit;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tposition: absolute;\n\tvisibility: hidden;\n\twidth: 1em;\n\theight: 100%;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {\n\tvisibility: visible;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Context Menu */\n\n.context-view.monaco-menu-container {\n\toutline: 0;\n\tborder: none;\n\tanimation: fadeIn 0.083s linear;\n\t-webkit-app-region: no-drag;\n}\n\n.context-view.monaco-menu-container :focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,\n.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {\n\toutline: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-item {\n\tborder: thin solid transparent; /* prevents jumping behaviour on hover or focus */\n}\n\n\n/* High Contrast Theming */\n:host-context(.hc-black) .context-view.monaco-menu-container {\n\tbox-shadow: none;\n}\n\n:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {\n\tbackground: none;\n}\n\n/* Vertical Action Bar Styles */\n\n.monaco-menu .monaco-action-bar.vertical {\n\tpadding: .5em 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-menu-item {\n\theight: 1.8em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),\n.monaco-menu .monaco-action-bar.vertical .keybinding {\n\tfont-size: inherit;\n\tpadding: 0 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .menu-item-check {\n\tfont-size: inherit;\n\twidth: 2em;\n}\n\n.monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tfont-size: inherit;\n\tpadding: 0.2em 0 0 0;\n\tmargin-bottom: 0.2em;\n}\n\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {\n\tmargin-left: 0;\n\tmargin-right: 0;\n}\n\n.monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\tfont-size: 60%;\n\tpadding: 0 1.8em;\n}\n\n:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {\n\theight: 100%;\n\tmask-size: 10px 10px;\n\t-webkit-mask-size: 10px 10px;\n}\n\n.monaco-menu .action-item {\n\tcursor: default;\n}`;\n    if (isForShadowDom) {\n        // Only define scrollbar styles when used inside shadow dom,\n        // otherwise leave their styling to the global workbench styling.\n        result += `\n\t\t\t/* Arrows */\n\t\t\t.monaco-scrollable-element > .scrollbar > .scra {\n\t\t\t\tcursor: pointer;\n\t\t\t\tfont-size: 11px !important;\n\t\t\t}\n\n\t\t\t.monaco-scrollable-element > .visible {\n\t\t\t\topacity: 1;\n\n\t\t\t\t/* Background rule added for IE9 - to allow clicks on dom node */\n\t\t\t\tbackground:rgba(0,0,0,0);\n\n\t\t\t\ttransition: opacity 100ms linear;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible {\n\t\t\t\topacity: 0;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .invisible.fade {\n\t\t\t\ttransition: opacity 800ms linear;\n\t\t\t}\n\n\t\t\t/* Scrollable Content Inset Shadow */\n\t\t\t.monaco-scrollable-element > .shadow {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 3px;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 3px;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 100%;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t\t.monaco-scrollable-element > .shadow.top-left-corner {\n\t\t\t\tdisplay: block;\n\t\t\t\ttop: 0;\n\t\t\t\tleft: 0;\n\t\t\t\theight: 3px;\n\t\t\t\twidth: 3px;\n\t\t\t}\n\t\t`;\n        // Scrollbars\n        const scrollbarShadowColor = style.scrollbarShadow;\n        if (scrollbarShadowColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .shadow.top {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;\n\t\t\t\t}\n\n\t\t\t\t.monaco-scrollable-element > .shadow.top.left {\n\t\t\t\t\tbox-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderBackgroundColor = style.scrollbarSliderBackground;\n        if (scrollbarSliderBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider {\n\t\t\t\t\tbackground: ${scrollbarSliderBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderHoverBackgroundColor = style.scrollbarSliderHoverBackground;\n        if (scrollbarSliderHoverBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider:hover {\n\t\t\t\t\tbackground: ${scrollbarSliderHoverBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n        const scrollbarSliderActiveBackgroundColor = style.scrollbarSliderActiveBackground;\n        if (scrollbarSliderActiveBackgroundColor) {\n            result += `\n\t\t\t\t.monaco-scrollable-element > .scrollbar > .slider.active {\n\t\t\t\t\tbackground: ${scrollbarSliderActiveBackgroundColor};\n\t\t\t\t}\n\t\t\t`;\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, addDisposableListener, EventType, isHTMLElement } from '../../../base/browser/dom.js';\nimport { StandardMouseEvent } from '../../../base/browser/mouseEvent.js';\nimport { Menu } from '../../../base/browser/ui/menu/menu.js';\nimport { ActionRunner } from '../../../base/common/actions.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { combinedDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport './contextMenuHandler.css';\nimport { attachMenuStyler } from '../../theme/common/styler.js';\nexport class ContextMenuHandler {\n    constructor(contextViewService, telemetryService, notificationService, keybindingService, themeService) {\n        this.contextViewService = contextViewService;\n        this.telemetryService = telemetryService;\n        this.notificationService = notificationService;\n        this.keybindingService = keybindingService;\n        this.themeService = themeService;\n        this.focusToReturn = null;\n        this.block = null;\n        this.options = { blockMouse: true };\n    }\n    configure(options) {\n        this.options = options;\n    }\n    showContextMenu(delegate) {\n        const actions = delegate.getActions();\n        if (!actions.length) {\n            return; // Don't render an empty context menu\n        }\n        this.focusToReturn = document.activeElement;\n        let menu;\n        let shadowRootElement = isHTMLElement(delegate.domForShadowRoot) ? delegate.domForShadowRoot : undefined;\n        this.contextViewService.showContextView({\n            getAnchor: () => delegate.getAnchor(),\n            canRelayout: false,\n            anchorAlignment: delegate.anchorAlignment,\n            anchorAxisAlignment: delegate.anchorAxisAlignment,\n            render: (container) => {\n                let className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';\n                if (className) {\n                    container.className += ' ' + className;\n                }\n                // Render invisible div to block mouse interaction in the rest of the UI\n                if (this.options.blockMouse) {\n                    this.block = container.appendChild($('.context-view-block'));\n                    this.block.style.position = 'fixed';\n                    this.block.style.cursor = 'initial';\n                    this.block.style.left = '0';\n                    this.block.style.top = '0';\n                    this.block.style.width = '100%';\n                    this.block.style.height = '100%';\n                    this.block.style.zIndex = '-1';\n                    // TODO@Steven: this is never getting disposed\n                    addDisposableListener(this.block, EventType.MOUSE_DOWN, e => e.stopPropagation());\n                }\n                const menuDisposables = new DisposableStore();\n                const actionRunner = delegate.actionRunner || new ActionRunner();\n                actionRunner.onBeforeRun(this.onActionRun, this, menuDisposables);\n                actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);\n                menu = new Menu(container, actions, {\n                    actionViewItemProvider: delegate.getActionViewItem,\n                    context: delegate.getActionsContext ? delegate.getActionsContext() : null,\n                    actionRunner,\n                    getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : action => this.keybindingService.lookupKeybinding(action.id)\n                });\n                menuDisposables.add(attachMenuStyler(menu, this.themeService));\n                menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);\n                menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);\n                menuDisposables.add(addDisposableListener(window, EventType.BLUR, () => this.contextViewService.hideContextView(true)));\n                menuDisposables.add(addDisposableListener(window, EventType.MOUSE_DOWN, (e) => {\n                    if (e.defaultPrevented) {\n                        return;\n                    }\n                    let event = new StandardMouseEvent(e);\n                    let element = event.target;\n                    // Don't do anything as we are likely creating a context menu\n                    if (event.rightButton) {\n                        return;\n                    }\n                    while (element) {\n                        if (element === container) {\n                            return;\n                        }\n                        element = element.parentElement;\n                    }\n                    this.contextViewService.hideContextView(true);\n                }));\n                return combinedDisposable(menuDisposables, menu);\n            },\n            focus: () => {\n                if (menu) {\n                    menu.focus(!!delegate.autoSelectFirstItem);\n                }\n            },\n            onHide: (didCancel) => {\n                if (delegate.onHide) {\n                    delegate.onHide(!!didCancel);\n                }\n                if (this.block) {\n                    this.block.remove();\n                    this.block = null;\n                }\n                if (this.focusToReturn) {\n                    this.focusToReturn.focus();\n                }\n            }\n        }, shadowRootElement, !!shadowRootElement);\n    }\n    onActionRun(e) {\n        this.telemetryService.publicLog2('workbenchActionExecuted', { id: e.action.id, from: 'contextMenu' });\n        this.contextViewService.hideContextView(false);\n        // Restore focus here\n        if (this.focusToReturn) {\n            this.focusToReturn.focus();\n        }\n    }\n    onDidActionRun(e) {\n        if (e.error && !isCancellationError(e.error)) {\n            this.notificationService.error(e.error);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ModifierKeyEmitter } from '../../../base/browser/dom.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nimport { IThemeService } from '../../theme/common/themeService.js';\nimport { ContextMenuHandler } from './contextMenuHandler.js';\nimport { IContextViewService } from './contextView.js';\nlet ContextMenuService = class ContextMenuService extends Disposable {\n    constructor(telemetryService, notificationService, contextViewService, keybindingService, themeService) {\n        super();\n        this._onDidShowContextMenu = new Emitter();\n        this._onDidHideContextMenu = new Emitter();\n        this.contextMenuHandler = new ContextMenuHandler(contextViewService, telemetryService, notificationService, keybindingService, themeService);\n    }\n    configure(options) {\n        this.contextMenuHandler.configure(options);\n    }\n    // ContextMenu\n    showContextMenu(delegate) {\n        this.contextMenuHandler.showContextMenu(Object.assign(Object.assign({}, delegate), { onHide: (didCancel) => {\n                if (delegate.onHide) {\n                    delegate.onHide(didCancel);\n                }\n                this._onDidHideContextMenu.fire();\n            } }));\n        ModifierKeyEmitter.getInstance().resetKeyStatus();\n        this._onDidShowContextMenu.fire();\n    }\n};\nContextMenuService = __decorate([\n    __param(0, ITelemetryService),\n    __param(1, INotificationService),\n    __param(2, IContextViewService),\n    __param(3, IKeybindingService),\n    __param(4, IThemeService)\n], ContextMenuService);\nexport { ContextMenuService };\n","export var EditorOpenSource;\n(function (EditorOpenSource) {\n    /**\n     * Default: the editor is opening via a programmatic call\n     * to the editor service API.\n     */\n    EditorOpenSource[EditorOpenSource[\"API\"] = 0] = \"API\";\n    /**\n     * Indicates that a user action triggered the opening, e.g.\n     * via mouse or keyboard use.\n     */\n    EditorOpenSource[EditorOpenSource[\"USER\"] = 1] = \"USER\";\n})(EditorOpenSource || (EditorOpenSource = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../base/browser/dom.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { parse } from '../../../base/common/marshalling.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { normalizePath } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ICodeEditorService } from './codeEditorService.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { EditorOpenSource } from '../../../platform/editor/common/editor.js';\nimport { extractSelection, matchesScheme, matchesSomeScheme } from '../../../platform/opener/common/opener.js';\nlet CommandOpener = class CommandOpener {\n    constructor(_commandService) {\n        this._commandService = _commandService;\n    }\n    open(target, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!matchesScheme(target, Schemas.command)) {\n                return false;\n            }\n            if (!(options === null || options === void 0 ? void 0 : options.allowCommands)) {\n                // silently ignore commands when command-links are disabled, also\n                // surpress other openers by returning TRUE\n                return true;\n            }\n            // run command or bail out if command isn't known\n            if (typeof target === 'string') {\n                target = URI.parse(target);\n            }\n            // execute as command\n            let args = [];\n            try {\n                args = parse(decodeURIComponent(target.query));\n            }\n            catch (_a) {\n                // ignore and retry\n                try {\n                    args = parse(target.query);\n                }\n                catch (_b) {\n                    // ignore error\n                }\n            }\n            if (!Array.isArray(args)) {\n                args = [args];\n            }\n            yield this._commandService.executeCommand(target.path, ...args);\n            return true;\n        });\n    }\n};\nCommandOpener = __decorate([\n    __param(0, ICommandService)\n], CommandOpener);\nlet EditorOpener = class EditorOpener {\n    constructor(_editorService) {\n        this._editorService = _editorService;\n    }\n    open(target, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof target === 'string') {\n                target = URI.parse(target);\n            }\n            const { selection, uri } = extractSelection(target);\n            target = uri;\n            if (target.scheme === Schemas.file) {\n                target = normalizePath(target); // workaround for non-normalized paths (https://github.com/microsoft/vscode/issues/12954)\n            }\n            yield this._editorService.openCodeEditor({\n                resource: target,\n                options: Object.assign({ selection, source: (options === null || options === void 0 ? void 0 : options.fromUserGesture) ? EditorOpenSource.USER : EditorOpenSource.API }, options === null || options === void 0 ? void 0 : options.editorOptions)\n            }, this._editorService.getFocusedCodeEditor(), options === null || options === void 0 ? void 0 : options.openToSide);\n            return true;\n        });\n    }\n};\nEditorOpener = __decorate([\n    __param(0, ICodeEditorService)\n], EditorOpener);\nlet OpenerService = class OpenerService {\n    constructor(editorService, commandService) {\n        this._openers = new LinkedList();\n        this._validators = new LinkedList();\n        this._resolvers = new LinkedList();\n        this._resolvedUriTargets = new ResourceMap(uri => uri.with({ path: null, fragment: null, query: null }).toString());\n        this._externalOpeners = new LinkedList();\n        // Default external opener is going through window.open()\n        this._defaultExternalOpener = {\n            openExternal: (href) => __awaiter(this, void 0, void 0, function* () {\n                // ensure to open HTTP/HTTPS links into new windows\n                // to not trigger a navigation. Any other link is\n                // safe to be set as HREF to prevent a blank window\n                // from opening.\n                if (matchesSomeScheme(href, Schemas.http, Schemas.https)) {\n                    dom.windowOpenNoOpener(href);\n                }\n                else {\n                    window.location.href = href;\n                }\n                return true;\n            })\n        };\n        // Default opener: any external, maito, http(s), command, and catch-all-editors\n        this._openers.push({\n            open: (target, options) => __awaiter(this, void 0, void 0, function* () {\n                if ((options === null || options === void 0 ? void 0 : options.openExternal) || matchesSomeScheme(target, Schemas.mailto, Schemas.http, Schemas.https, Schemas.vsls)) {\n                    // open externally\n                    yield this._doOpenExternal(target, options);\n                    return true;\n                }\n                return false;\n            })\n        });\n        this._openers.push(new CommandOpener(commandService));\n        this._openers.push(new EditorOpener(editorService));\n    }\n    registerOpener(opener) {\n        const remove = this._openers.unshift(opener);\n        return { dispose: remove };\n    }\n    registerValidator(validator) {\n        const remove = this._validators.push(validator);\n        return { dispose: remove };\n    }\n    registerExternalUriResolver(resolver) {\n        const remove = this._resolvers.push(resolver);\n        return { dispose: remove };\n    }\n    setDefaultExternalOpener(externalOpener) {\n        this._defaultExternalOpener = externalOpener;\n    }\n    registerExternalOpener(opener) {\n        const remove = this._externalOpeners.push(opener);\n        return { dispose: remove };\n    }\n    open(target, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // check with contributed validators\n            const targetURI = typeof target === 'string' ? URI.parse(target) : target;\n            // validate against the original URI that this URI resolves to, if one exists\n            const validationTarget = (_a = this._resolvedUriTargets.get(targetURI)) !== null && _a !== void 0 ? _a : target;\n            for (const validator of this._validators) {\n                if (!(yield validator.shouldOpen(validationTarget))) {\n                    return false;\n                }\n            }\n            // check with contributed openers\n            for (const opener of this._openers) {\n                const handled = yield opener.open(target, options);\n                if (handled) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    resolveExternalUri(resource, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const resolver of this._resolvers) {\n                try {\n                    const result = yield resolver.resolveExternalUri(resource, options);\n                    if (result) {\n                        if (!this._resolvedUriTargets.has(result.resolved)) {\n                            this._resolvedUriTargets.set(result.resolved, resource);\n                        }\n                        return result;\n                    }\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n            throw new Error('Could not resolve external URI: ' + resource.toString());\n        });\n    }\n    _doOpenExternal(resource, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            //todo@jrieken IExternalUriResolver should support `uri: URI | string`\n            const uri = typeof resource === 'string' ? URI.parse(resource) : resource;\n            let externalUri;\n            try {\n                externalUri = (yield this.resolveExternalUri(uri, options)).resolved;\n            }\n            catch (_a) {\n                externalUri = uri;\n            }\n            let href;\n            if (typeof resource === 'string' && uri.toString() === externalUri.toString()) {\n                // open the url-string AS IS\n                href = resource;\n            }\n            else {\n                // open URI using the toString(noEncode)+encodeURI-trick\n                href = encodeURI(externalUri.toString(true));\n            }\n            if (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) {\n                const preferredOpenerId = typeof (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) === 'string' ? options === null || options === void 0 ? void 0 : options.allowContributedOpeners : undefined;\n                for (const opener of this._externalOpeners) {\n                    const didOpen = yield opener.openExternal(href, {\n                        sourceUri: uri,\n                        preferredOpenerId,\n                    }, CancellationToken.None);\n                    if (didOpen) {\n                        return true;\n                    }\n                }\n            }\n            return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);\n        });\n    }\n    dispose() {\n        this._validators.clear();\n    }\n};\nOpenerService = __decorate([\n    __param(0, ICodeEditorService),\n    __param(1, ICommandService)\n], OpenerService);\nexport { OpenerService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport Severity from '../../../base/common/severity.js';\nimport { localize } from '../../../nls.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport var MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\n(function (MarkerSeverity) {\n    function compare(a, b) {\n        return b - a;\n    }\n    MarkerSeverity.compare = compare;\n    const _displayStrings = Object.create(null);\n    _displayStrings[MarkerSeverity.Error] = localize('sev.error', \"Error\");\n    _displayStrings[MarkerSeverity.Warning] = localize('sev.warning', \"Warning\");\n    _displayStrings[MarkerSeverity.Info] = localize('sev.info', \"Info\");\n    function toString(a) {\n        return _displayStrings[a] || '';\n    }\n    MarkerSeverity.toString = toString;\n    function fromSeverity(severity) {\n        switch (severity) {\n            case Severity.Error: return MarkerSeverity.Error;\n            case Severity.Warning: return MarkerSeverity.Warning;\n            case Severity.Info: return MarkerSeverity.Info;\n            case Severity.Ignore: return MarkerSeverity.Hint;\n        }\n    }\n    MarkerSeverity.fromSeverity = fromSeverity;\n    function toSeverity(severity) {\n        switch (severity) {\n            case MarkerSeverity.Error: return Severity.Error;\n            case MarkerSeverity.Warning: return Severity.Warning;\n            case MarkerSeverity.Info: return Severity.Info;\n            case MarkerSeverity.Hint: return Severity.Ignore;\n        }\n    }\n    MarkerSeverity.toSeverity = toSeverity;\n})(MarkerSeverity || (MarkerSeverity = {}));\nexport var IMarkerData;\n(function (IMarkerData) {\n    const emptyString = '';\n    function makeKey(markerData) {\n        return makeKeyOptionalMessage(markerData, true);\n    }\n    IMarkerData.makeKey = makeKey;\n    function makeKeyOptionalMessage(markerData, useMessage) {\n        let result = [emptyString];\n        if (markerData.source) {\n            result.push(markerData.source.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.code) {\n            if (typeof markerData.code === 'string') {\n                result.push(markerData.code.replace('¦', '\\\\¦'));\n            }\n            else {\n                result.push(markerData.code.value.replace('¦', '\\\\¦'));\n            }\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.severity !== undefined && markerData.severity !== null) {\n            result.push(MarkerSeverity.toString(markerData.severity));\n        }\n        else {\n            result.push(emptyString);\n        }\n        // Modifed to not include the message as part of the marker key to work around\n        // https://github.com/microsoft/vscode/issues/77475\n        if (markerData.message && useMessage) {\n            result.push(markerData.message.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startLineNumber !== undefined && markerData.startLineNumber !== null) {\n            result.push(markerData.startLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startColumn !== undefined && markerData.startColumn !== null) {\n            result.push(markerData.startColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endLineNumber !== undefined && markerData.endLineNumber !== null) {\n            result.push(markerData.endLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endColumn !== undefined && markerData.endColumn !== null) {\n            result.push(markerData.endColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        result.push(emptyString);\n        return result.join('¦');\n    }\n    IMarkerData.makeKeyOptionalMessage = makeKeyOptionalMessage;\n})(IMarkerData || (IMarkerData = {}));\nexport const IMarkerService = createDecorator('markerService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { IMarkerService, MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { OverviewRulerLane, MinimapPosition } from '../model.js';\nimport { themeColorFromId } from '../../../platform/theme/common/themeService.js';\nimport { overviewRulerWarning, overviewRulerInfo, overviewRulerError } from '../core/editorColorRegistry.js';\nimport { IModelService } from './model.js';\nimport { Range } from '../core/range.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { minimapWarning, minimapError } from '../../../platform/theme/common/colorRegistry.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nclass MarkerDecorations extends Disposable {\n    constructor(model) {\n        super();\n        this.model = model;\n        this._markersData = new Map();\n        this._register(toDisposable(() => {\n            this.model.deltaDecorations([...this._markersData.keys()], []);\n            this._markersData.clear();\n        }));\n    }\n    update(markers, newDecorations) {\n        const oldIds = [...this._markersData.keys()];\n        this._markersData.clear();\n        const ids = this.model.deltaDecorations(oldIds, newDecorations);\n        for (let index = 0; index < ids.length; index++) {\n            this._markersData.set(ids[index], markers[index]);\n        }\n        return oldIds.length !== 0 || ids.length !== 0;\n    }\n    getMarker(decoration) {\n        return this._markersData.get(decoration.id);\n    }\n}\nlet MarkerDecorationsService = class MarkerDecorationsService extends Disposable {\n    constructor(modelService, _markerService) {\n        super();\n        this._markerService = _markerService;\n        this._onDidChangeMarker = this._register(new Emitter());\n        this._markerDecorations = new ResourceMap();\n        modelService.getModels().forEach(model => this._onModelAdded(model));\n        this._register(modelService.onModelAdded(this._onModelAdded, this));\n        this._register(modelService.onModelRemoved(this._onModelRemoved, this));\n        this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));\n    }\n    dispose() {\n        super.dispose();\n        this._markerDecorations.forEach(value => value.dispose());\n        this._markerDecorations.clear();\n    }\n    getMarker(uri, decoration) {\n        const markerDecorations = this._markerDecorations.get(uri);\n        return markerDecorations ? (markerDecorations.getMarker(decoration) || null) : null;\n    }\n    _handleMarkerChange(changedResources) {\n        changedResources.forEach((resource) => {\n            const markerDecorations = this._markerDecorations.get(resource);\n            if (markerDecorations) {\n                this._updateDecorations(markerDecorations);\n            }\n        });\n    }\n    _onModelAdded(model) {\n        const markerDecorations = new MarkerDecorations(model);\n        this._markerDecorations.set(model.uri, markerDecorations);\n        this._updateDecorations(markerDecorations);\n    }\n    _onModelRemoved(model) {\n        const markerDecorations = this._markerDecorations.get(model.uri);\n        if (markerDecorations) {\n            markerDecorations.dispose();\n            this._markerDecorations.delete(model.uri);\n        }\n        // clean up markers for internal, transient models\n        if (model.uri.scheme === Schemas.inMemory\n            || model.uri.scheme === Schemas.internal\n            || model.uri.scheme === Schemas.vscode) {\n            if (this._markerService) {\n                this._markerService.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));\n            }\n        }\n    }\n    _updateDecorations(markerDecorations) {\n        // Limit to the first 500 errors/warnings\n        const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });\n        const newModelDecorations = markers.map((marker) => {\n            return {\n                range: this._createDecorationRange(markerDecorations.model, marker),\n                options: this._createDecorationOption(marker)\n            };\n        });\n        if (markerDecorations.update(markers, newModelDecorations)) {\n            this._onDidChangeMarker.fire(markerDecorations.model);\n        }\n    }\n    _createDecorationRange(model, rawMarker) {\n        let ret = Range.lift(rawMarker);\n        if (rawMarker.severity === MarkerSeverity.Hint && !this._hasMarkerTag(rawMarker, 1 /* Unnecessary */) && !this._hasMarkerTag(rawMarker, 2 /* Deprecated */)) {\n            // * never render hints on multiple lines\n            // * make enough space for three dots\n            ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);\n        }\n        ret = model.validateRange(ret);\n        if (ret.isEmpty()) {\n            const maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) ||\n                model.getLineMaxColumn(ret.startLineNumber);\n            if (maxColumn === 1 || ret.endColumn >= maxColumn) {\n                // empty line or behind eol\n                // keep the range as is, it will be rendered 1ch wide\n                return ret;\n            }\n            const word = model.getWordAtPosition(ret.getStartPosition());\n            if (word) {\n                ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);\n            }\n        }\n        else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {\n            let minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);\n            if (minColumn < ret.endColumn) {\n                ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);\n                rawMarker.startColumn = minColumn;\n            }\n        }\n        return ret;\n    }\n    _createDecorationOption(marker) {\n        let className;\n        let color = undefined;\n        let zIndex;\n        let inlineClassName = undefined;\n        let minimap;\n        switch (marker.severity) {\n            case MarkerSeverity.Hint:\n                if (this._hasMarkerTag(marker, 2 /* Deprecated */)) {\n                    className = undefined;\n                }\n                else if (this._hasMarkerTag(marker, 1 /* Unnecessary */)) {\n                    className = \"squiggly-unnecessary\" /* EditorUnnecessaryDecoration */;\n                }\n                else {\n                    className = \"squiggly-hint\" /* EditorHintDecoration */;\n                }\n                zIndex = 0;\n                break;\n            case MarkerSeverity.Warning:\n                className = \"squiggly-warning\" /* EditorWarningDecoration */;\n                color = themeColorFromId(overviewRulerWarning);\n                zIndex = 20;\n                minimap = {\n                    color: themeColorFromId(minimapWarning),\n                    position: MinimapPosition.Inline\n                };\n                break;\n            case MarkerSeverity.Info:\n                className = \"squiggly-info\" /* EditorInfoDecoration */;\n                color = themeColorFromId(overviewRulerInfo);\n                zIndex = 10;\n                break;\n            case MarkerSeverity.Error:\n            default:\n                className = \"squiggly-error\" /* EditorErrorDecoration */;\n                color = themeColorFromId(overviewRulerError);\n                zIndex = 30;\n                minimap = {\n                    color: themeColorFromId(minimapError),\n                    position: MinimapPosition.Inline\n                };\n                break;\n        }\n        if (marker.tags) {\n            if (marker.tags.indexOf(1 /* Unnecessary */) !== -1) {\n                inlineClassName = \"squiggly-inline-unnecessary\" /* EditorUnnecessaryInlineDecoration */;\n            }\n            if (marker.tags.indexOf(2 /* Deprecated */) !== -1) {\n                inlineClassName = \"squiggly-inline-deprecated\" /* EditorDeprecatedInlineDecoration */;\n            }\n        }\n        return {\n            description: 'marker-decoration',\n            stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n            className,\n            showIfCollapsed: true,\n            overviewRuler: {\n                color,\n                position: OverviewRulerLane.Right\n            },\n            minimap,\n            zIndex,\n            inlineClassName,\n        };\n    }\n    _hasMarkerTag(marker, tag) {\n        if (marker.tags) {\n            return marker.tags.indexOf(tag) >= 0;\n        }\n        return false;\n    }\n};\nMarkerDecorationsService = __decorate([\n    __param(0, IModelService),\n    __param(1, IMarkerService)\n], MarkerDecorationsService);\nexport { MarkerDecorationsService };\n","import { addDisposableListener, EventHelper, EventType, reset, trackFocus } from '../../dom.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { EventType as TouchEventType, Gesture } from '../../touch.js';\nimport { renderLabelWithIcons } from '../iconLabel/iconLabels.js';\nimport { Color } from '../../../common/color.js';\nimport { Emitter } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { mixin } from '../../../common/objects.js';\nimport './button.css';\nconst defaultOptions = {\n    buttonBackground: Color.fromHex('#0E639C'),\n    buttonHoverBackground: Color.fromHex('#006BB3'),\n    buttonForeground: Color.white\n};\nexport class Button extends Disposable {\n    constructor(container, options) {\n        super();\n        this._onDidClick = this._register(new Emitter());\n        this.options = options || Object.create(null);\n        mixin(this.options, defaultOptions, false);\n        this.buttonForeground = this.options.buttonForeground;\n        this.buttonBackground = this.options.buttonBackground;\n        this.buttonHoverBackground = this.options.buttonHoverBackground;\n        this.buttonSecondaryForeground = this.options.buttonSecondaryForeground;\n        this.buttonSecondaryBackground = this.options.buttonSecondaryBackground;\n        this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground;\n        this.buttonBorder = this.options.buttonBorder;\n        this._element = document.createElement('a');\n        this._element.classList.add('monaco-button');\n        this._element.tabIndex = 0;\n        this._element.setAttribute('role', 'button');\n        container.appendChild(this._element);\n        this._register(Gesture.addTarget(this._element));\n        [EventType.CLICK, TouchEventType.Tap].forEach(eventType => {\n            this._register(addDisposableListener(this._element, eventType, e => {\n                if (!this.enabled) {\n                    EventHelper.stop(e);\n                    return;\n                }\n                this._onDidClick.fire(e);\n            }));\n        });\n        this._register(addDisposableListener(this._element, EventType.KEY_DOWN, e => {\n            const event = new StandardKeyboardEvent(e);\n            let eventHandled = false;\n            if (this.enabled && (event.equals(3 /* Enter */) || event.equals(10 /* Space */))) {\n                this._onDidClick.fire(e);\n                eventHandled = true;\n            }\n            else if (event.equals(9 /* Escape */)) {\n                this._element.blur();\n                eventHandled = true;\n            }\n            if (eventHandled) {\n                EventHelper.stop(event, true);\n            }\n        }));\n        this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, e => {\n            if (!this._element.classList.contains('disabled')) {\n                this.setHoverBackground();\n            }\n        }));\n        this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, e => {\n            this.applyStyles(); // restore standard styles\n        }));\n        // Also set hover background when button is focused for feedback\n        this.focusTracker = this._register(trackFocus(this._element));\n        this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground()));\n        this._register(this.focusTracker.onDidBlur(() => this.applyStyles())); // restore standard styles\n        this.applyStyles();\n    }\n    get onDidClick() { return this._onDidClick.event; }\n    setHoverBackground() {\n        let hoverBackground;\n        if (this.options.secondary) {\n            hoverBackground = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null;\n        }\n        else {\n            hoverBackground = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null;\n        }\n        if (hoverBackground) {\n            this._element.style.backgroundColor = hoverBackground;\n        }\n    }\n    style(styles) {\n        this.buttonForeground = styles.buttonForeground;\n        this.buttonBackground = styles.buttonBackground;\n        this.buttonHoverBackground = styles.buttonHoverBackground;\n        this.buttonSecondaryForeground = styles.buttonSecondaryForeground;\n        this.buttonSecondaryBackground = styles.buttonSecondaryBackground;\n        this.buttonSecondaryHoverBackground = styles.buttonSecondaryHoverBackground;\n        this.buttonBorder = styles.buttonBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this._element) {\n            let background, foreground;\n            if (this.options.secondary) {\n                foreground = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : '';\n                background = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : '';\n            }\n            else {\n                foreground = this.buttonForeground ? this.buttonForeground.toString() : '';\n                background = this.buttonBackground ? this.buttonBackground.toString() : '';\n            }\n            const border = this.buttonBorder ? this.buttonBorder.toString() : '';\n            this._element.style.color = foreground;\n            this._element.style.backgroundColor = background;\n            this._element.style.borderWidth = border ? '1px' : '';\n            this._element.style.borderStyle = border ? 'solid' : '';\n            this._element.style.borderColor = border;\n        }\n    }\n    get element() {\n        return this._element;\n    }\n    set label(value) {\n        this._element.classList.add('monaco-text-button');\n        if (this.options.supportIcons) {\n            reset(this._element, ...renderLabelWithIcons(value));\n        }\n        else {\n            this._element.textContent = value;\n        }\n        if (typeof this.options.title === 'string') {\n            this._element.title = this.options.title;\n        }\n        else if (this.options.title) {\n            this._element.title = value;\n        }\n    }\n    set enabled(value) {\n        if (value) {\n            this._element.classList.remove('disabled');\n            this._element.setAttribute('aria-disabled', String(false));\n            this._element.tabIndex = 0;\n        }\n        else {\n            this._element.classList.add('disabled');\n            this._element.setAttribute('aria-disabled', String(true));\n        }\n    }\n    get enabled() {\n        return !this._element.classList.contains('disabled');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { show } from '../../dom.js';\nimport { RunOnceScheduler } from '../../../common/async.js';\nimport { Color } from '../../../common/color.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { mixin } from '../../../common/objects.js';\nimport './progressbar.css';\nconst CSS_DONE = 'done';\nconst CSS_ACTIVE = 'active';\nconst CSS_INFINITE = 'infinite';\nconst CSS_INFINITE_LONG_RUNNING = 'infinite-long-running';\nconst CSS_DISCRETE = 'discrete';\nconst defaultOpts = {\n    progressBarBackground: Color.fromHex('#0E70C0')\n};\n/**\n * A progress bar with support for infinite or discrete progress.\n */\nexport class ProgressBar extends Disposable {\n    constructor(container, options) {\n        super();\n        this.options = options || Object.create(null);\n        mixin(this.options, defaultOpts, false);\n        this.workedVal = 0;\n        this.progressBarBackground = this.options.progressBarBackground;\n        this.showDelayedScheduler = this._register(new RunOnceScheduler(() => show(this.element), 0));\n        this.longRunningScheduler = this._register(new RunOnceScheduler(() => this.infiniteLongRunning(), ProgressBar.LONG_RUNNING_INFINITE_THRESHOLD));\n        this.create(container);\n    }\n    create(container) {\n        this.element = document.createElement('div');\n        this.element.classList.add('monaco-progress-container');\n        this.element.setAttribute('role', 'progressbar');\n        this.element.setAttribute('aria-valuemin', '0');\n        container.appendChild(this.element);\n        this.bit = document.createElement('div');\n        this.bit.classList.add('progress-bit');\n        this.element.appendChild(this.bit);\n        this.applyStyles();\n    }\n    off() {\n        this.bit.style.width = 'inherit';\n        this.bit.style.opacity = '1';\n        this.element.classList.remove(CSS_ACTIVE, CSS_INFINITE, CSS_INFINITE_LONG_RUNNING, CSS_DISCRETE);\n        this.workedVal = 0;\n        this.totalWork = undefined;\n        this.longRunningScheduler.cancel();\n    }\n    /**\n     * Stops the progressbar from showing any progress instantly without fading out.\n     */\n    stop() {\n        return this.doDone(false);\n    }\n    doDone(delayed) {\n        this.element.classList.add(CSS_DONE);\n        // discrete: let it grow to 100% width and hide afterwards\n        if (!this.element.classList.contains(CSS_INFINITE)) {\n            this.bit.style.width = 'inherit';\n            if (delayed) {\n                setTimeout(() => this.off(), 200);\n            }\n            else {\n                this.off();\n            }\n        }\n        // infinite: let it fade out and hide afterwards\n        else {\n            this.bit.style.opacity = '0';\n            if (delayed) {\n                setTimeout(() => this.off(), 200);\n            }\n            else {\n                this.off();\n            }\n        }\n        return this;\n    }\n    /**\n     * Use this mode to indicate progress that has no total number of work units.\n     */\n    infinite() {\n        this.bit.style.width = '2%';\n        this.bit.style.opacity = '1';\n        this.element.classList.remove(CSS_DISCRETE, CSS_DONE, CSS_INFINITE_LONG_RUNNING);\n        this.element.classList.add(CSS_ACTIVE, CSS_INFINITE);\n        this.longRunningScheduler.schedule();\n        return this;\n    }\n    infiniteLongRunning() {\n        this.element.classList.add(CSS_INFINITE_LONG_RUNNING);\n    }\n    getContainer() {\n        return this.element;\n    }\n    style(styles) {\n        this.progressBarBackground = styles.progressBarBackground;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.bit) {\n            const background = this.progressBarBackground ? this.progressBarBackground.toString() : '';\n            this.bit.style.backgroundColor = background;\n        }\n    }\n}\n/**\n * After a certain time of showing the progress bar, switch\n * to long-running mode and throttle animations to reduce\n * the pressure on the GPU process.\n *\n * https://github.com/microsoft/vscode/issues/97900\n * https://github.com/microsoft/vscode/issues/138396\n */\nProgressBar.LONG_RUNNING_INFINITE_THRESHOLD = 10000;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../browser/dom.js';\nimport { IdGenerator } from '../../../common/idGenerator.js';\nimport './media/quickInput.css';\nconst iconPathToClass = {};\nconst iconClassGenerator = new IdGenerator('quick-input-button-icon-');\nexport function getIconClass(iconPath) {\n    if (!iconPath) {\n        return undefined;\n    }\n    let iconClass;\n    const key = iconPath.dark.toString();\n    if (iconPathToClass[key]) {\n        iconClass = iconPathToClass[key];\n    }\n    else {\n        iconClass = iconClassGenerator.nextId();\n        dom.createCSSRule(`.${iconClass}`, `background-image: ${dom.asCSSUrl(iconPath.light || iconPath.dark)}`);\n        dom.createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${dom.asCSSUrl(iconPath.dark)}`);\n        iconPathToClass[key] = iconClass;\n    }\n    return iconClass;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../browser/keyboardEvent.js';\nimport { StandardMouseEvent } from '../../../browser/mouseEvent.js';\nimport { InputBox } from '../../../browser/ui/inputbox/inputBox.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport Severity from '../../../common/severity.js';\nimport './media/quickInput.css';\nconst $ = dom.$;\nexport class QuickInputBox extends Disposable {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        this.onKeyDown = (handler) => {\n            return dom.addDisposableListener(this.inputBox.inputElement, dom.EventType.KEY_DOWN, (e) => {\n                handler(new StandardKeyboardEvent(e));\n            });\n        };\n        this.onMouseDown = (handler) => {\n            return dom.addDisposableListener(this.inputBox.inputElement, dom.EventType.MOUSE_DOWN, (e) => {\n                handler(new StandardMouseEvent(e));\n            });\n        };\n        this.onDidChange = (handler) => {\n            return this.inputBox.onDidChange(handler);\n        };\n        this.container = dom.append(this.parent, $('.quick-input-box'));\n        this.inputBox = this._register(new InputBox(this.container, undefined));\n    }\n    get value() {\n        return this.inputBox.value;\n    }\n    set value(value) {\n        this.inputBox.value = value;\n    }\n    select(range = null) {\n        this.inputBox.select(range);\n    }\n    isSelectionAtEnd() {\n        return this.inputBox.isSelectionAtEnd();\n    }\n    get placeholder() {\n        return this.inputBox.inputElement.getAttribute('placeholder') || '';\n    }\n    set placeholder(placeholder) {\n        this.inputBox.setPlaceHolder(placeholder);\n    }\n    get ariaLabel() {\n        return this.inputBox.getAriaLabel();\n    }\n    set ariaLabel(ariaLabel) {\n        this.inputBox.setAriaLabel(ariaLabel);\n    }\n    get password() {\n        return this.inputBox.inputElement.type === 'password';\n    }\n    set password(password) {\n        this.inputBox.inputElement.type = password ? 'password' : 'text';\n    }\n    setAttribute(name, value) {\n        this.inputBox.inputElement.setAttribute(name, value);\n    }\n    removeAttribute(name) {\n        this.inputBox.inputElement.removeAttribute(name);\n    }\n    showDecoration(decoration) {\n        if (decoration === Severity.Ignore) {\n            this.inputBox.hideMessage();\n        }\n        else {\n            this.inputBox.showMessage({ type: decoration === Severity.Info ? 1 /* INFO */ : decoration === Severity.Warning ? 2 /* WARNING */ : 3 /* ERROR */, content: '' });\n        }\n    }\n    stylesForType(decoration) {\n        return this.inputBox.stylesForType(decoration === Severity.Info ? 1 /* INFO */ : decoration === Severity.Warning ? 2 /* WARNING */ : 3 /* ERROR */);\n    }\n    setFocus() {\n        this.inputBox.focus();\n    }\n    layout() {\n        this.inputBox.layout();\n    }\n    style(styles) {\n        this.inputBox.style(styles);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { UILabelProvider } from '../../../common/keybindingLabels.js';\nimport { equals } from '../../../common/objects.js';\nimport './keybindingLabel.css';\nimport { localize } from '../../../../nls.js';\nconst $ = dom.$;\nexport class KeybindingLabel {\n    constructor(container, os, options) {\n        this.os = os;\n        this.keyElements = new Set();\n        this.options = options || Object.create(null);\n        this.labelBackground = this.options.keybindingLabelBackground;\n        this.labelForeground = this.options.keybindingLabelForeground;\n        this.labelBorder = this.options.keybindingLabelBorder;\n        this.labelBottomBorder = this.options.keybindingLabelBottomBorder;\n        this.labelShadow = this.options.keybindingLabelShadow;\n        this.domNode = dom.append(container, $('.monaco-keybinding'));\n        this.didEverRender = false;\n        container.appendChild(this.domNode);\n    }\n    get element() {\n        return this.domNode;\n    }\n    set(keybinding, matches) {\n        if (this.didEverRender && this.keybinding === keybinding && KeybindingLabel.areSame(this.matches, matches)) {\n            return;\n        }\n        this.keybinding = keybinding;\n        this.matches = matches;\n        this.render();\n    }\n    render() {\n        this.clear();\n        if (this.keybinding) {\n            let [firstPart, chordPart] = this.keybinding.getParts();\n            if (firstPart) {\n                this.renderPart(this.domNode, firstPart, this.matches ? this.matches.firstPart : null);\n            }\n            if (chordPart) {\n                dom.append(this.domNode, $('span.monaco-keybinding-key-chord-separator', undefined, ' '));\n                this.renderPart(this.domNode, chordPart, this.matches ? this.matches.chordPart : null);\n            }\n            this.domNode.title = this.keybinding.getAriaLabel() || '';\n        }\n        else if (this.options && this.options.renderUnboundKeybindings) {\n            this.renderUnbound(this.domNode);\n        }\n        this.applyStyles();\n        this.didEverRender = true;\n    }\n    clear() {\n        dom.clearNode(this.domNode);\n        this.keyElements.clear();\n    }\n    renderPart(parent, part, match) {\n        const modifierLabels = UILabelProvider.modifierLabels[this.os];\n        if (part.ctrlKey) {\n            this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match === null || match === void 0 ? void 0 : match.ctrlKey), modifierLabels.separator);\n        }\n        if (part.shiftKey) {\n            this.renderKey(parent, modifierLabels.shiftKey, Boolean(match === null || match === void 0 ? void 0 : match.shiftKey), modifierLabels.separator);\n        }\n        if (part.altKey) {\n            this.renderKey(parent, modifierLabels.altKey, Boolean(match === null || match === void 0 ? void 0 : match.altKey), modifierLabels.separator);\n        }\n        if (part.metaKey) {\n            this.renderKey(parent, modifierLabels.metaKey, Boolean(match === null || match === void 0 ? void 0 : match.metaKey), modifierLabels.separator);\n        }\n        const keyLabel = part.keyLabel;\n        if (keyLabel) {\n            this.renderKey(parent, keyLabel, Boolean(match === null || match === void 0 ? void 0 : match.keyCode), '');\n        }\n    }\n    renderKey(parent, label, highlight, separator) {\n        dom.append(parent, this.createKeyElement(label, highlight ? '.highlight' : ''));\n        if (separator) {\n            dom.append(parent, $('span.monaco-keybinding-key-separator', undefined, separator));\n        }\n    }\n    renderUnbound(parent) {\n        dom.append(parent, this.createKeyElement(localize('unbound', \"Unbound\")));\n    }\n    createKeyElement(label, extraClass = '') {\n        const keyElement = $('span.monaco-keybinding-key' + extraClass, undefined, label);\n        this.keyElements.add(keyElement);\n        return keyElement;\n    }\n    style(styles) {\n        this.labelBackground = styles.keybindingLabelBackground;\n        this.labelForeground = styles.keybindingLabelForeground;\n        this.labelBorder = styles.keybindingLabelBorder;\n        this.labelBottomBorder = styles.keybindingLabelBottomBorder;\n        this.labelShadow = styles.keybindingLabelShadow;\n        this.applyStyles();\n    }\n    applyStyles() {\n        var _a;\n        if (this.element) {\n            for (const keyElement of this.keyElements) {\n                if (this.labelBackground) {\n                    keyElement.style.backgroundColor = (_a = this.labelBackground) === null || _a === void 0 ? void 0 : _a.toString();\n                }\n                if (this.labelBorder) {\n                    keyElement.style.borderColor = this.labelBorder.toString();\n                }\n                if (this.labelBottomBorder) {\n                    keyElement.style.borderBottomColor = this.labelBottomBorder.toString();\n                }\n                if (this.labelShadow) {\n                    keyElement.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`;\n                }\n            }\n            if (this.labelForeground) {\n                this.element.style.color = this.labelForeground.toString();\n            }\n        }\n    }\n    static areSame(a, b) {\n        if (a === b || (!a && !b)) {\n            return true;\n        }\n        return !!a && !!b && equals(a.firstPart, b.firstPart) && equals(a.chordPart, b.chordPart);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from './async.js';\n// When comparing large numbers of strings it's better for performance to create an\n// Intl.Collator object and use the function provided by its compare property\n// than it is to use String.prototype.localeCompare()\n// A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n    return {\n        collator: collator,\n        collatorIsNumeric: collator.resolvedOptions().numeric\n    };\n});\n// A collator with numeric sorting enabled.\nconst intlFileNameCollatorNumeric = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true });\n    return {\n        collator: collator\n    };\n});\n// A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.\nconst intlFileNameCollatorNumericCaseInsensitive = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'accent' });\n    return {\n        collator: collator\n    };\n});\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\nexport function compareFileNames(one, other, caseSensitive = false) {\n    const a = one || '';\n    const b = other || '';\n    const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n    // Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.\n    if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n        return a < b ? -1 : 1;\n    }\n    return result;\n}\nexport function compareAnything(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    // Sort prefix matches over non prefix matches\n    const prefixCompare = compareByPrefix(one, other, lookFor);\n    if (prefixCompare) {\n        return prefixCompare;\n    }\n    // Sort suffix matches over non suffix matches\n    const elementASuffixMatch = elementAName.endsWith(lookFor);\n    const elementBSuffixMatch = elementBName.endsWith(lookFor);\n    if (elementASuffixMatch !== elementBSuffixMatch) {\n        return elementASuffixMatch ? -1 : 1;\n    }\n    // Understand file names\n    const r = compareFileNames(elementAName, elementBName);\n    if (r !== 0) {\n        return r;\n    }\n    // Compare by name\n    return elementAName.localeCompare(elementBName);\n}\nexport function compareByPrefix(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    // Sort prefix matches over non prefix matches\n    const elementAPrefixMatch = elementAName.startsWith(lookFor);\n    const elementBPrefixMatch = elementBName.startsWith(lookFor);\n    if (elementAPrefixMatch !== elementBPrefixMatch) {\n        return elementAPrefixMatch ? -1 : 1;\n    }\n    // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n    else if (elementAPrefixMatch && elementBPrefixMatch) {\n        if (elementAName.length < elementBName.length) {\n            return -1;\n        }\n        if (elementAName.length > elementBName.length) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../browser/keyboardEvent.js';\nimport { ActionBar } from '../../../browser/ui/actionbar/actionbar.js';\nimport { IconLabel } from '../../../browser/ui/iconLabel/iconLabel.js';\nimport { KeybindingLabel } from '../../../browser/ui/keybindingLabel/keybindingLabel.js';\nimport { Action } from '../../../common/actions.js';\nimport { range } from '../../../common/arrays.js';\nimport { getCodiconAriaLabel } from '../../../common/codicons.js';\nimport { compareAnything } from '../../../common/comparers.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { matchesFuzzyIconAware, parseLabelWithIcons } from '../../../common/iconLabels.js';\nimport { dispose } from '../../../common/lifecycle.js';\nimport * as platform from '../../../common/platform.js';\nimport { withNullAsUndefined } from '../../../common/types.js';\nimport { getIconClass } from './quickInputUtils.js';\nimport './media/quickInput.css';\nimport { localize } from '../../../../nls.js';\nconst $ = dom.$;\nclass ListElement {\n    constructor(init) {\n        this.hidden = false;\n        this._onChecked = new Emitter();\n        this.onChecked = this._onChecked.event;\n        Object.assign(this, init);\n    }\n    get checked() {\n        return !!this._checked;\n    }\n    set checked(value) {\n        if (value !== this._checked) {\n            this._checked = value;\n            this._onChecked.fire(value);\n        }\n    }\n    dispose() {\n        this._onChecked.dispose();\n    }\n}\nclass ListElementRenderer {\n    get templateId() {\n        return ListElementRenderer.ID;\n    }\n    renderTemplate(container) {\n        const data = Object.create(null);\n        data.toDisposeElement = [];\n        data.toDisposeTemplate = [];\n        data.entry = dom.append(container, $('.quick-input-list-entry'));\n        // Checkbox\n        const label = dom.append(data.entry, $('label.quick-input-list-label'));\n        data.toDisposeTemplate.push(dom.addStandardDisposableListener(label, dom.EventType.CLICK, e => {\n            if (!data.checkbox.offsetParent) { // If checkbox not visible:\n                e.preventDefault(); // Prevent toggle of checkbox when it is immediately shown afterwards. #91740\n            }\n        }));\n        data.checkbox = dom.append(label, $('input.quick-input-list-checkbox'));\n        data.checkbox.type = 'checkbox';\n        data.toDisposeTemplate.push(dom.addStandardDisposableListener(data.checkbox, dom.EventType.CHANGE, e => {\n            data.element.checked = data.checkbox.checked;\n        }));\n        // Rows\n        const rows = dom.append(label, $('.quick-input-list-rows'));\n        const row1 = dom.append(rows, $('.quick-input-list-row'));\n        const row2 = dom.append(rows, $('.quick-input-list-row'));\n        // Label\n        data.label = new IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true, supportIcons: true });\n        // Keybinding\n        const keybindingContainer = dom.append(row1, $('.quick-input-list-entry-keybinding'));\n        data.keybinding = new KeybindingLabel(keybindingContainer, platform.OS);\n        // Detail\n        const detailContainer = dom.append(row2, $('.quick-input-list-label-meta'));\n        data.detail = new IconLabel(detailContainer, { supportHighlights: true, supportIcons: true });\n        // Separator\n        data.separator = dom.append(data.entry, $('.quick-input-list-separator'));\n        // Actions\n        data.actionBar = new ActionBar(data.entry);\n        data.actionBar.domNode.classList.add('quick-input-list-entry-action-bar');\n        data.toDisposeTemplate.push(data.actionBar);\n        return data;\n    }\n    renderElement(element, index, data) {\n        data.toDisposeElement = dispose(data.toDisposeElement);\n        data.element = element;\n        data.checkbox.checked = element.checked;\n        data.toDisposeElement.push(element.onChecked(checked => data.checkbox.checked = checked));\n        const { labelHighlights, descriptionHighlights, detailHighlights } = element;\n        // Label\n        const options = Object.create(null);\n        options.matches = labelHighlights || [];\n        options.descriptionTitle = element.saneDescription;\n        options.descriptionMatches = descriptionHighlights || [];\n        options.extraClasses = element.item.iconClasses;\n        options.italic = element.item.italic;\n        options.strikethrough = element.item.strikethrough;\n        data.label.setLabel(element.saneLabel, element.saneDescription, options);\n        // Keybinding\n        data.keybinding.set(element.item.keybinding);\n        // Meta\n        if (element.saneDetail) {\n            data.detail.setLabel(element.saneDetail, undefined, {\n                matches: detailHighlights,\n                title: element.saneDetail\n            });\n        }\n        // Separator\n        if (element.separator && element.separator.label) {\n            data.separator.textContent = element.separator.label;\n            data.separator.style.display = '';\n        }\n        else {\n            data.separator.style.display = 'none';\n        }\n        data.entry.classList.toggle('quick-input-list-separator-border', !!element.separator);\n        // Actions\n        data.actionBar.clear();\n        const buttons = element.item.buttons;\n        if (buttons && buttons.length) {\n            data.actionBar.push(buttons.map((button, index) => {\n                let cssClasses = button.iconClass || (button.iconPath ? getIconClass(button.iconPath) : undefined);\n                if (button.alwaysVisible) {\n                    cssClasses = cssClasses ? `${cssClasses} always-visible` : 'always-visible';\n                }\n                const action = new Action(`id-${index}`, '', cssClasses, true, () => __awaiter(this, void 0, void 0, function* () {\n                    element.fireButtonTriggered({\n                        button,\n                        item: element.item\n                    });\n                }));\n                action.tooltip = button.tooltip || '';\n                return action;\n            }), { icon: true, label: false });\n            data.entry.classList.add('has-actions');\n        }\n        else {\n            data.entry.classList.remove('has-actions');\n        }\n    }\n    disposeElement(element, index, data) {\n        data.toDisposeElement = dispose(data.toDisposeElement);\n    }\n    disposeTemplate(data) {\n        data.toDisposeElement = dispose(data.toDisposeElement);\n        data.toDisposeTemplate = dispose(data.toDisposeTemplate);\n    }\n}\nListElementRenderer.ID = 'listelement';\nclass ListElementDelegate {\n    getHeight(element) {\n        return element.saneDetail ? 44 : 22;\n    }\n    getTemplateId(element) {\n        return ListElementRenderer.ID;\n    }\n}\nexport var QuickInputListFocus;\n(function (QuickInputListFocus) {\n    QuickInputListFocus[QuickInputListFocus[\"First\"] = 1] = \"First\";\n    QuickInputListFocus[QuickInputListFocus[\"Second\"] = 2] = \"Second\";\n    QuickInputListFocus[QuickInputListFocus[\"Last\"] = 3] = \"Last\";\n    QuickInputListFocus[QuickInputListFocus[\"Next\"] = 4] = \"Next\";\n    QuickInputListFocus[QuickInputListFocus[\"Previous\"] = 5] = \"Previous\";\n    QuickInputListFocus[QuickInputListFocus[\"NextPage\"] = 6] = \"NextPage\";\n    QuickInputListFocus[QuickInputListFocus[\"PreviousPage\"] = 7] = \"PreviousPage\";\n})(QuickInputListFocus || (QuickInputListFocus = {}));\nexport class QuickInputList {\n    constructor(parent, id, options) {\n        this.parent = parent;\n        this.inputElements = [];\n        this.elements = [];\n        this.elementsToIndexes = new Map();\n        this.matchOnDescription = false;\n        this.matchOnDetail = false;\n        this.matchOnLabel = true;\n        this.matchOnMeta = true;\n        this.sortByLabel = true;\n        this._onChangedAllVisibleChecked = new Emitter();\n        this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;\n        this._onChangedCheckedCount = new Emitter();\n        this.onChangedCheckedCount = this._onChangedCheckedCount.event;\n        this._onChangedVisibleCount = new Emitter();\n        this.onChangedVisibleCount = this._onChangedVisibleCount.event;\n        this._onChangedCheckedElements = new Emitter();\n        this.onChangedCheckedElements = this._onChangedCheckedElements.event;\n        this._onButtonTriggered = new Emitter();\n        this.onButtonTriggered = this._onButtonTriggered.event;\n        this._onKeyDown = new Emitter();\n        this.onKeyDown = this._onKeyDown.event;\n        this._onLeave = new Emitter();\n        this.onLeave = this._onLeave.event;\n        this._fireCheckedEvents = true;\n        this.elementDisposables = [];\n        this.disposables = [];\n        this.id = id;\n        this.container = dom.append(this.parent, $('.quick-input-list'));\n        const delegate = new ListElementDelegate();\n        const accessibilityProvider = new QuickInputAccessibilityProvider();\n        this.list = options.createList('QuickInput', this.container, delegate, [new ListElementRenderer()], {\n            identityProvider: { getId: element => element.saneLabel },\n            setRowLineHeight: false,\n            multipleSelectionSupport: false,\n            horizontalScrolling: false,\n            accessibilityProvider\n        });\n        this.list.getHTMLElement().id = id;\n        this.disposables.push(this.list);\n        this.disposables.push(this.list.onKeyDown(e => {\n            const event = new StandardKeyboardEvent(e);\n            switch (event.keyCode) {\n                case 10 /* Space */:\n                    this.toggleCheckbox();\n                    break;\n                case 31 /* KeyA */:\n                    if (platform.isMacintosh ? e.metaKey : e.ctrlKey) {\n                        this.list.setFocus(range(this.list.length));\n                    }\n                    break;\n                case 16 /* UpArrow */: {\n                    const focus1 = this.list.getFocus();\n                    if (focus1.length === 1 && focus1[0] === 0) {\n                        this._onLeave.fire();\n                    }\n                    break;\n                }\n                case 18 /* DownArrow */: {\n                    const focus2 = this.list.getFocus();\n                    if (focus2.length === 1 && focus2[0] === this.list.length - 1) {\n                        this._onLeave.fire();\n                    }\n                    break;\n                }\n            }\n            this._onKeyDown.fire(event);\n        }));\n        this.disposables.push(this.list.onMouseDown(e => {\n            if (e.browserEvent.button !== 2) {\n                // Works around / fixes #64350.\n                e.browserEvent.preventDefault();\n            }\n        }));\n        this.disposables.push(dom.addDisposableListener(this.container, dom.EventType.CLICK, e => {\n            if (e.x || e.y) { // Avoid 'click' triggered by 'space' on checkbox.\n                this._onLeave.fire();\n            }\n        }));\n        this.disposables.push(this.list.onMouseMiddleClick(e => {\n            this._onLeave.fire();\n        }));\n        this.disposables.push(this.list.onContextMenu(e => {\n            if (typeof e.index === 'number') {\n                e.browserEvent.preventDefault();\n                // we want to treat a context menu event as\n                // a gesture to open the item at the index\n                // since we do not have any context menu\n                // this enables for example macOS to Ctrl-\n                // click on an item to open it.\n                this.list.setSelection([e.index]);\n            }\n        }));\n        this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);\n    }\n    get onDidChangeFocus() {\n        return Event.map(this.list.onDidChangeFocus, e => e.elements.map(e => e.item));\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.list.onDidChangeSelection, e => ({ items: e.elements.map(e => e.item), event: e.browserEvent }));\n    }\n    get scrollTop() {\n        return this.list.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.list.scrollTop = scrollTop;\n    }\n    getAllVisibleChecked() {\n        return this.allVisibleChecked(this.elements, false);\n    }\n    allVisibleChecked(elements, whenNoneVisible = true) {\n        for (let i = 0, n = elements.length; i < n; i++) {\n            const element = elements[i];\n            if (!element.hidden) {\n                if (!element.checked) {\n                    return false;\n                }\n                else {\n                    whenNoneVisible = true;\n                }\n            }\n        }\n        return whenNoneVisible;\n    }\n    getCheckedCount() {\n        let count = 0;\n        const elements = this.elements;\n        for (let i = 0, n = elements.length; i < n; i++) {\n            if (elements[i].checked) {\n                count++;\n            }\n        }\n        return count;\n    }\n    getVisibleCount() {\n        let count = 0;\n        const elements = this.elements;\n        for (let i = 0, n = elements.length; i < n; i++) {\n            if (!elements[i].hidden) {\n                count++;\n            }\n        }\n        return count;\n    }\n    setAllVisibleChecked(checked) {\n        try {\n            this._fireCheckedEvents = false;\n            this.elements.forEach(element => {\n                if (!element.hidden) {\n                    element.checked = checked;\n                }\n            });\n        }\n        finally {\n            this._fireCheckedEvents = true;\n            this.fireCheckedEvents();\n        }\n    }\n    setElements(inputElements) {\n        this.elementDisposables = dispose(this.elementDisposables);\n        const fireButtonTriggered = (event) => this.fireButtonTriggered(event);\n        this.inputElements = inputElements;\n        this.elements = inputElements.reduce((result, item, index) => {\n            var _a, _b, _c;\n            if (item.type !== 'separator') {\n                const previous = index && inputElements[index - 1];\n                const saneLabel = item.label && item.label.replace(/\\r?\\n/g, ' ');\n                const saneMeta = item.meta && item.meta.replace(/\\r?\\n/g, ' ');\n                const saneDescription = item.description && item.description.replace(/\\r?\\n/g, ' ');\n                const saneDetail = item.detail && item.detail.replace(/\\r?\\n/g, ' ');\n                const saneAriaLabel = item.ariaLabel || [saneLabel, saneDescription, saneDetail]\n                    .map(s => getCodiconAriaLabel(s))\n                    .filter(s => !!s)\n                    .join(', ');\n                const hasCheckbox = this.parent.classList.contains('show-checkboxes');\n                result.push(new ListElement({\n                    hasCheckbox,\n                    index,\n                    item,\n                    saneLabel,\n                    saneMeta,\n                    saneAriaLabel,\n                    saneDescription,\n                    saneDetail,\n                    labelHighlights: (_a = item.highlights) === null || _a === void 0 ? void 0 : _a.label,\n                    descriptionHighlights: (_b = item.highlights) === null || _b === void 0 ? void 0 : _b.description,\n                    detailHighlights: (_c = item.highlights) === null || _c === void 0 ? void 0 : _c.detail,\n                    checked: false,\n                    separator: previous && previous.type === 'separator' ? previous : undefined,\n                    fireButtonTriggered\n                }));\n            }\n            return result;\n        }, []);\n        this.elementDisposables.push(...this.elements);\n        this.elementDisposables.push(...this.elements.map(element => element.onChecked(() => this.fireCheckedEvents())));\n        this.elementsToIndexes = this.elements.reduce((map, element, index) => {\n            map.set(element.item, index);\n            return map;\n        }, new Map());\n        this.list.splice(0, this.list.length); // Clear focus and selection first, sending the events when the list is empty.\n        this.list.splice(0, this.list.length, this.elements);\n        this._onChangedVisibleCount.fire(this.elements.length);\n    }\n    getFocusedElements() {\n        return this.list.getFocusedElements()\n            .map(e => e.item);\n    }\n    setFocusedElements(items) {\n        this.list.setFocus(items\n            .filter(item => this.elementsToIndexes.has(item))\n            .map(item => this.elementsToIndexes.get(item)));\n        if (items.length > 0) {\n            const focused = this.list.getFocus()[0];\n            if (typeof focused === 'number') {\n                this.list.reveal(focused);\n            }\n        }\n    }\n    getActiveDescendant() {\n        return this.list.getHTMLElement().getAttribute('aria-activedescendant');\n    }\n    setSelectedElements(items) {\n        this.list.setSelection(items\n            .filter(item => this.elementsToIndexes.has(item))\n            .map(item => this.elementsToIndexes.get(item)));\n    }\n    getCheckedElements() {\n        return this.elements.filter(e => e.checked)\n            .map(e => e.item);\n    }\n    setCheckedElements(items) {\n        try {\n            this._fireCheckedEvents = false;\n            const checked = new Set();\n            for (const item of items) {\n                checked.add(item);\n            }\n            for (const element of this.elements) {\n                element.checked = checked.has(element.item);\n            }\n        }\n        finally {\n            this._fireCheckedEvents = true;\n            this.fireCheckedEvents();\n        }\n    }\n    set enabled(value) {\n        this.list.getHTMLElement().style.pointerEvents = value ? '' : 'none';\n    }\n    focus(what) {\n        if (!this.list.length) {\n            return;\n        }\n        if (what === QuickInputListFocus.Next && this.list.getFocus()[0] === this.list.length - 1) {\n            what = QuickInputListFocus.First;\n        }\n        if (what === QuickInputListFocus.Previous && this.list.getFocus()[0] === 0) {\n            what = QuickInputListFocus.Last;\n        }\n        if (what === QuickInputListFocus.Second && this.list.length < 2) {\n            what = QuickInputListFocus.First;\n        }\n        switch (what) {\n            case QuickInputListFocus.First:\n                this.list.focusFirst();\n                break;\n            case QuickInputListFocus.Second:\n                this.list.focusNth(1);\n                break;\n            case QuickInputListFocus.Last:\n                this.list.focusLast();\n                break;\n            case QuickInputListFocus.Next:\n                this.list.focusNext();\n                break;\n            case QuickInputListFocus.Previous:\n                this.list.focusPrevious();\n                break;\n            case QuickInputListFocus.NextPage:\n                this.list.focusNextPage();\n                break;\n            case QuickInputListFocus.PreviousPage:\n                this.list.focusPreviousPage();\n                break;\n        }\n        const focused = this.list.getFocus()[0];\n        if (typeof focused === 'number') {\n            this.list.reveal(focused);\n        }\n    }\n    clearFocus() {\n        this.list.setFocus([]);\n    }\n    domFocus() {\n        this.list.domFocus();\n    }\n    layout(maxHeight) {\n        this.list.getHTMLElement().style.maxHeight = maxHeight ? `calc(${Math.floor(maxHeight / 44) * 44}px)` : '';\n        this.list.layout();\n    }\n    filter(query) {\n        if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {\n            this.list.layout();\n            return false;\n        }\n        query = query.trim();\n        // Reset filtering\n        if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {\n            this.elements.forEach(element => {\n                element.labelHighlights = undefined;\n                element.descriptionHighlights = undefined;\n                element.detailHighlights = undefined;\n                element.hidden = false;\n                const previous = element.index && this.inputElements[element.index - 1];\n                element.separator = previous && previous.type === 'separator' ? previous : undefined;\n            });\n        }\n        // Filter by value (since we support icons in labels, use $(..) aware fuzzy matching)\n        else {\n            let currentSeparator;\n            this.elements.forEach(element => {\n                const labelHighlights = this.matchOnLabel ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel))) : undefined;\n                const descriptionHighlights = this.matchOnDescription ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || ''))) : undefined;\n                const detailHighlights = this.matchOnDetail ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || ''))) : undefined;\n                const metaHighlights = this.matchOnMeta ? withNullAsUndefined(matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneMeta || ''))) : undefined;\n                if (labelHighlights || descriptionHighlights || detailHighlights || metaHighlights) {\n                    element.labelHighlights = labelHighlights;\n                    element.descriptionHighlights = descriptionHighlights;\n                    element.detailHighlights = detailHighlights;\n                    element.hidden = false;\n                }\n                else {\n                    element.labelHighlights = undefined;\n                    element.descriptionHighlights = undefined;\n                    element.detailHighlights = undefined;\n                    element.hidden = !element.item.alwaysShow;\n                }\n                element.separator = undefined;\n                // we can show the separator unless the list gets sorted by match\n                if (!this.sortByLabel) {\n                    const previous = element.index && this.inputElements[element.index - 1];\n                    currentSeparator = previous && previous.type === 'separator' ? previous : currentSeparator;\n                    if (currentSeparator && !element.hidden) {\n                        element.separator = currentSeparator;\n                        currentSeparator = undefined;\n                    }\n                }\n            });\n        }\n        const shownElements = this.elements.filter(element => !element.hidden);\n        // Sort by value\n        if (this.sortByLabel && query) {\n            const normalizedSearchValue = query.toLowerCase();\n            shownElements.sort((a, b) => {\n                return compareEntries(a, b, normalizedSearchValue);\n            });\n        }\n        this.elementsToIndexes = shownElements.reduce((map, element, index) => {\n            map.set(element.item, index);\n            return map;\n        }, new Map());\n        this.list.splice(0, this.list.length, shownElements);\n        this.list.setFocus([]);\n        this.list.layout();\n        this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());\n        this._onChangedVisibleCount.fire(shownElements.length);\n        return true;\n    }\n    toggleCheckbox() {\n        try {\n            this._fireCheckedEvents = false;\n            const elements = this.list.getFocusedElements();\n            const allChecked = this.allVisibleChecked(elements);\n            for (const element of elements) {\n                element.checked = !allChecked;\n            }\n        }\n        finally {\n            this._fireCheckedEvents = true;\n            this.fireCheckedEvents();\n        }\n    }\n    display(display) {\n        this.container.style.display = display ? '' : 'none';\n    }\n    isDisplayed() {\n        return this.container.style.display !== 'none';\n    }\n    dispose() {\n        this.elementDisposables = dispose(this.elementDisposables);\n        this.disposables = dispose(this.disposables);\n    }\n    fireCheckedEvents() {\n        if (this._fireCheckedEvents) {\n            this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());\n            this._onChangedCheckedCount.fire(this.getCheckedCount());\n            this._onChangedCheckedElements.fire(this.getCheckedElements());\n        }\n    }\n    fireButtonTriggered(event) {\n        this._onButtonTriggered.fire(event);\n    }\n    style(styles) {\n        this.list.style(styles);\n    }\n}\n__decorate([\n    memoize\n], QuickInputList.prototype, \"onDidChangeFocus\", null);\n__decorate([\n    memoize\n], QuickInputList.prototype, \"onDidChangeSelection\", null);\nfunction compareEntries(elementA, elementB, lookFor) {\n    const labelHighlightsA = elementA.labelHighlights || [];\n    const labelHighlightsB = elementB.labelHighlights || [];\n    if (labelHighlightsA.length && !labelHighlightsB.length) {\n        return -1;\n    }\n    if (!labelHighlightsA.length && labelHighlightsB.length) {\n        return 1;\n    }\n    if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {\n        return 0;\n    }\n    return compareAnything(elementA.saneLabel, elementB.saneLabel, lookFor);\n}\nclass QuickInputAccessibilityProvider {\n    getWidgetAriaLabel() {\n        return localize('quickInput', \"Quick Input\");\n    }\n    getAriaLabel(element) {\n        return element.saneAriaLabel;\n    }\n    getWidgetRole() {\n        return 'listbox';\n    }\n    getRole(element) {\n        return element.hasCheckbox ? 'checkbox' : 'option';\n    }\n    isChecked(element) {\n        if (!element.hasCheckbox) {\n            return undefined;\n        }\n        return {\n            value: element.checked,\n            onDidChange: element.onChecked\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as dom from '../../../browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../browser/keyboardEvent.js';\nimport { ActionBar } from '../../../browser/ui/actionbar/actionbar.js';\nimport { Button } from '../../../browser/ui/button/button.js';\nimport { CountBadge } from '../../../browser/ui/countBadge/countBadge.js';\nimport { renderLabelWithIcons } from '../../../browser/ui/iconLabel/iconLabels.js';\nimport { ProgressBar } from '../../../browser/ui/progressbar/progressbar.js';\nimport { Action } from '../../../common/actions.js';\nimport { equals } from '../../../common/arrays.js';\nimport { TimeoutTimer } from '../../../common/async.js';\nimport { CancellationToken } from '../../../common/cancellation.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { Emitter } from '../../../common/event.js';\nimport { Disposable, DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { isIOS } from '../../../common/platform.js';\nimport Severity from '../../../common/severity.js';\nimport { withNullAsUndefined } from '../../../common/types.js';\nimport { getIconClass } from './quickInputUtils.js';\nimport { ItemActivation, NO_KEY_MODS, QuickInputHideReason } from '../common/quickInput.js';\nimport './media/quickInput.css';\nimport { localize } from '../../../../nls.js';\nimport { QuickInputBox } from './quickInputBox.js';\nimport { QuickInputList, QuickInputListFocus } from './quickInputList.js';\nconst $ = dom.$;\nconst backButton = {\n    iconClass: Codicon.quickInputBack.classNames,\n    tooltip: localize('quickInput.back', \"Back\"),\n    handle: -1 // TODO\n};\nclass QuickInput extends Disposable {\n    constructor(ui) {\n        super();\n        this.ui = ui;\n        this.visible = false;\n        this._enabled = true;\n        this._busy = false;\n        this._ignoreFocusOut = false;\n        this._buttons = [];\n        this.noValidationMessage = QuickInput.noPromptMessage;\n        this._severity = Severity.Ignore;\n        this.buttonsUpdated = false;\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.onDidHideEmitter = this._register(new Emitter());\n        this.onDisposeEmitter = this._register(new Emitter());\n        this.visibleDisposables = this._register(new DisposableStore());\n        this.onDidHide = this.onDidHideEmitter.event;\n    }\n    get title() {\n        return this._title;\n    }\n    set title(title) {\n        this._title = title;\n        this.update();\n    }\n    get description() {\n        return this._description;\n    }\n    set description(description) {\n        this._description = description;\n        this.update();\n    }\n    get step() {\n        return this._steps;\n    }\n    set step(step) {\n        this._steps = step;\n        this.update();\n    }\n    get totalSteps() {\n        return this._totalSteps;\n    }\n    set totalSteps(totalSteps) {\n        this._totalSteps = totalSteps;\n        this.update();\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(enabled) {\n        this._enabled = enabled;\n        this.update();\n    }\n    get contextKey() {\n        return this._contextKey;\n    }\n    set contextKey(contextKey) {\n        this._contextKey = contextKey;\n        this.update();\n    }\n    get busy() {\n        return this._busy;\n    }\n    set busy(busy) {\n        this._busy = busy;\n        this.update();\n    }\n    get ignoreFocusOut() {\n        return this._ignoreFocusOut;\n    }\n    set ignoreFocusOut(ignoreFocusOut) {\n        const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;\n        this._ignoreFocusOut = ignoreFocusOut && !isIOS;\n        if (shouldUpdate) {\n            this.update();\n        }\n    }\n    get buttons() {\n        return this._buttons;\n    }\n    set buttons(buttons) {\n        this._buttons = buttons;\n        this.buttonsUpdated = true;\n        this.update();\n    }\n    get validationMessage() {\n        return this._validationMessage;\n    }\n    set validationMessage(validationMessage) {\n        this._validationMessage = validationMessage;\n        this.update();\n    }\n    get severity() {\n        return this._severity;\n    }\n    set severity(severity) {\n        this._severity = severity;\n        this.update();\n    }\n    show() {\n        if (this.visible) {\n            return;\n        }\n        this.visibleDisposables.add(this.ui.onDidTriggerButton(button => {\n            if (this.buttons.indexOf(button) !== -1) {\n                this.onDidTriggerButtonEmitter.fire(button);\n            }\n        }));\n        this.ui.show(this);\n        // update properties in the controller that get reset in the ui.show() call\n        this.visible = true;\n        // This ensures the message/prompt gets rendered\n        this._lastValidationMessage = undefined;\n        // This ensures the input box has the right severity applied\n        this._lastSeverity = undefined;\n        if (this.buttons.length) {\n            // if there are buttons, the ui.show() clears them out of the UI so we should\n            // rerender them.\n            this.buttonsUpdated = true;\n        }\n        this.update();\n    }\n    hide() {\n        if (!this.visible) {\n            return;\n        }\n        this.ui.hide();\n    }\n    didHide(reason = QuickInputHideReason.Other) {\n        this.visible = false;\n        this.visibleDisposables.clear();\n        this.onDidHideEmitter.fire({ reason });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        const title = this.getTitle();\n        if (title && this.ui.title.textContent !== title) {\n            this.ui.title.textContent = title;\n        }\n        else if (!title && this.ui.title.innerHTML !== '&nbsp;') {\n            this.ui.title.innerText = '\\u00a0';\n        }\n        const description = this.getDescription();\n        if (this.ui.description1.textContent !== description) {\n            this.ui.description1.textContent = description;\n        }\n        if (this.ui.description2.textContent !== description) {\n            this.ui.description2.textContent = description;\n        }\n        if (this.busy && !this.busyDelay) {\n            this.busyDelay = new TimeoutTimer();\n            this.busyDelay.setIfNotSet(() => {\n                if (this.visible) {\n                    this.ui.progressBar.infinite();\n                }\n            }, 800);\n        }\n        if (!this.busy && this.busyDelay) {\n            this.ui.progressBar.stop();\n            this.busyDelay.cancel();\n            this.busyDelay = undefined;\n        }\n        if (this.buttonsUpdated) {\n            this.buttonsUpdated = false;\n            this.ui.leftActionBar.clear();\n            const leftButtons = this.buttons.filter(button => button === backButton);\n            this.ui.leftActionBar.push(leftButtons.map((button, index) => {\n                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {\n                    this.onDidTriggerButtonEmitter.fire(button);\n                }));\n                action.tooltip = button.tooltip || '';\n                return action;\n            }), { icon: true, label: false });\n            this.ui.rightActionBar.clear();\n            const rightButtons = this.buttons.filter(button => button !== backButton);\n            this.ui.rightActionBar.push(rightButtons.map((button, index) => {\n                const action = new Action(`id-${index}`, '', button.iconClass || getIconClass(button.iconPath), true, () => __awaiter(this, void 0, void 0, function* () {\n                    this.onDidTriggerButtonEmitter.fire(button);\n                }));\n                action.tooltip = button.tooltip || '';\n                return action;\n            }), { icon: true, label: false });\n        }\n        this.ui.ignoreFocusOut = this.ignoreFocusOut;\n        this.ui.setEnabled(this.enabled);\n        this.ui.setContextKey(this.contextKey);\n        const validationMessage = this.validationMessage || this.noValidationMessage;\n        if (this._lastValidationMessage !== validationMessage) {\n            this._lastValidationMessage = validationMessage;\n            dom.reset(this.ui.message, ...renderLabelWithIcons(validationMessage));\n        }\n        if (this._lastSeverity !== this.severity) {\n            this._lastSeverity = this.severity;\n            this.showMessageDecoration(this.severity);\n        }\n    }\n    getTitle() {\n        if (this.title && this.step) {\n            return `${this.title} (${this.getSteps()})`;\n        }\n        if (this.title) {\n            return this.title;\n        }\n        if (this.step) {\n            return this.getSteps();\n        }\n        return '';\n    }\n    getDescription() {\n        return this.description || '';\n    }\n    getSteps() {\n        if (this.step && this.totalSteps) {\n            return localize('quickInput.steps', \"{0}/{1}\", this.step, this.totalSteps);\n        }\n        if (this.step) {\n            return String(this.step);\n        }\n        return '';\n    }\n    showMessageDecoration(severity) {\n        this.ui.inputBox.showDecoration(severity);\n        if (severity !== Severity.Ignore) {\n            const styles = this.ui.inputBox.stylesForType(severity);\n            this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : '';\n            this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : '';\n            this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : '';\n            this.ui.message.style.marginBottom = '-2px';\n        }\n        else {\n            this.ui.message.style.color = '';\n            this.ui.message.style.backgroundColor = '';\n            this.ui.message.style.border = '';\n            this.ui.message.style.marginBottom = '';\n        }\n    }\n    dispose() {\n        this.hide();\n        this.onDisposeEmitter.fire();\n        super.dispose();\n    }\n}\nQuickInput.noPromptMessage = localize('inputModeEntry', \"Press 'Enter' to confirm your input or 'Escape' to cancel\");\nclass QuickPick extends QuickInput {\n    constructor() {\n        super(...arguments);\n        this._value = '';\n        this.onDidChangeValueEmitter = this._register(new Emitter());\n        this.onWillAcceptEmitter = this._register(new Emitter());\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this._items = [];\n        this.itemsUpdated = false;\n        this._canSelectMany = false;\n        this._canAcceptInBackground = false;\n        this._matchOnDescription = false;\n        this._matchOnDetail = false;\n        this._matchOnLabel = true;\n        this._sortByLabel = true;\n        this._autoFocusOnList = true;\n        this._keepScrollPosition = false;\n        this._itemActivation = this.ui.isScreenReaderOptimized() ? ItemActivation.NONE /* https://github.com/microsoft/vscode/issues/57501 */ : ItemActivation.FIRST;\n        this._activeItems = [];\n        this.activeItemsUpdated = false;\n        this.activeItemsToConfirm = [];\n        this.onDidChangeActiveEmitter = this._register(new Emitter());\n        this._selectedItems = [];\n        this.selectedItemsUpdated = false;\n        this.selectedItemsToConfirm = [];\n        this.onDidChangeSelectionEmitter = this._register(new Emitter());\n        this.onDidTriggerItemButtonEmitter = this._register(new Emitter());\n        this.valueSelectionUpdated = true;\n        this._ok = 'default';\n        this._customButton = false;\n        this.filterValue = (value) => value;\n        this.onDidChangeValue = this.onDidChangeValueEmitter.event;\n        this.onWillAccept = this.onWillAcceptEmitter.event;\n        this.onDidAccept = this.onDidAcceptEmitter.event;\n        this.onDidChangeActive = this.onDidChangeActiveEmitter.event;\n        this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;\n        this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;\n    }\n    get quickNavigate() {\n        return this._quickNavigate;\n    }\n    set quickNavigate(quickNavigate) {\n        this._quickNavigate = quickNavigate;\n        this.update();\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this.doSetValue(value);\n    }\n    doSetValue(value, skipUpdate) {\n        if (this._value !== value) {\n            this._value = value;\n            if (!skipUpdate) {\n                this.update();\n            }\n            if (this.visible) {\n                const didFilter = this.ui.list.filter(this.filterValue(this._value));\n                if (didFilter) {\n                    this.trySelectFirst();\n                }\n            }\n            this.onDidChangeValueEmitter.fire(this._value);\n        }\n    }\n    set ariaLabel(ariaLabel) {\n        this._ariaLabel = ariaLabel;\n        this.update();\n    }\n    get ariaLabel() {\n        return this._ariaLabel;\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(placeholder) {\n        this._placeholder = placeholder;\n        this.update();\n    }\n    get items() {\n        return this._items;\n    }\n    get scrollTop() {\n        return this.ui.list.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.ui.list.scrollTop = scrollTop;\n    }\n    set items(items) {\n        this._items = items;\n        this.itemsUpdated = true;\n        this.update();\n    }\n    get canSelectMany() {\n        return this._canSelectMany;\n    }\n    set canSelectMany(canSelectMany) {\n        this._canSelectMany = canSelectMany;\n        this.update();\n    }\n    get canAcceptInBackground() {\n        return this._canAcceptInBackground;\n    }\n    set canAcceptInBackground(canAcceptInBackground) {\n        this._canAcceptInBackground = canAcceptInBackground;\n    }\n    get matchOnDescription() {\n        return this._matchOnDescription;\n    }\n    set matchOnDescription(matchOnDescription) {\n        this._matchOnDescription = matchOnDescription;\n        this.update();\n    }\n    get matchOnDetail() {\n        return this._matchOnDetail;\n    }\n    set matchOnDetail(matchOnDetail) {\n        this._matchOnDetail = matchOnDetail;\n        this.update();\n    }\n    get matchOnLabel() {\n        return this._matchOnLabel;\n    }\n    set matchOnLabel(matchOnLabel) {\n        this._matchOnLabel = matchOnLabel;\n        this.update();\n    }\n    get sortByLabel() {\n        return this._sortByLabel;\n    }\n    set sortByLabel(sortByLabel) {\n        this._sortByLabel = sortByLabel;\n        this.update();\n    }\n    get autoFocusOnList() {\n        return this._autoFocusOnList;\n    }\n    set autoFocusOnList(autoFocusOnList) {\n        this._autoFocusOnList = autoFocusOnList;\n        this.update();\n    }\n    get keepScrollPosition() {\n        return this._keepScrollPosition;\n    }\n    set keepScrollPosition(keepScrollPosition) {\n        this._keepScrollPosition = keepScrollPosition;\n    }\n    get itemActivation() {\n        return this._itemActivation;\n    }\n    set itemActivation(itemActivation) {\n        this._itemActivation = itemActivation;\n    }\n    get activeItems() {\n        return this._activeItems;\n    }\n    set activeItems(activeItems) {\n        this._activeItems = activeItems;\n        this.activeItemsUpdated = true;\n        this.update();\n    }\n    get selectedItems() {\n        return this._selectedItems;\n    }\n    set selectedItems(selectedItems) {\n        this._selectedItems = selectedItems;\n        this.selectedItemsUpdated = true;\n        this.update();\n    }\n    get keyMods() {\n        if (this._quickNavigate) {\n            // Disable keyMods when quick navigate is enabled\n            // because in this model the interaction is purely\n            // keyboard driven and Ctrl/Alt are typically\n            // pressed and hold during this interaction.\n            return NO_KEY_MODS;\n        }\n        return this.ui.keyMods;\n    }\n    set valueSelection(valueSelection) {\n        this._valueSelection = valueSelection;\n        this.valueSelectionUpdated = true;\n        this.update();\n    }\n    get customButton() {\n        return this._customButton;\n    }\n    set customButton(showCustomButton) {\n        this._customButton = showCustomButton;\n        this.update();\n    }\n    get customLabel() {\n        return this._customButtonLabel;\n    }\n    set customLabel(label) {\n        this._customButtonLabel = label;\n        this.update();\n    }\n    get customHover() {\n        return this._customButtonHover;\n    }\n    set customHover(hover) {\n        this._customButtonHover = hover;\n        this.update();\n    }\n    get ok() {\n        return this._ok;\n    }\n    set ok(showOkButton) {\n        this._ok = showOkButton;\n        this.update();\n    }\n    get hideInput() {\n        return !!this._hideInput;\n    }\n    set hideInput(hideInput) {\n        this._hideInput = hideInput;\n        this.update();\n    }\n    trySelectFirst() {\n        if (this.autoFocusOnList) {\n            if (!this.canSelectMany) {\n                this.ui.list.focus(QuickInputListFocus.First);\n            }\n        }\n    }\n    show() {\n        if (!this.visible) {\n            this.visibleDisposables.add(this.ui.inputBox.onDidChange(value => {\n                this.doSetValue(value, true /* skip update since this originates from the UI */);\n            }));\n            this.visibleDisposables.add(this.ui.inputBox.onMouseDown(event => {\n                if (!this.autoFocusOnList) {\n                    this.ui.list.clearFocus();\n                }\n            }));\n            this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {\n                switch (event.keyCode) {\n                    case 18 /* DownArrow */:\n                        this.ui.list.focus(QuickInputListFocus.Next);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 16 /* UpArrow */:\n                        if (this.ui.list.getFocusedElements().length) {\n                            this.ui.list.focus(QuickInputListFocus.Previous);\n                        }\n                        else {\n                            this.ui.list.focus(QuickInputListFocus.Last);\n                        }\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 12 /* PageDown */:\n                        this.ui.list.focus(QuickInputListFocus.NextPage);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 11 /* PageUp */:\n                        this.ui.list.focus(QuickInputListFocus.PreviousPage);\n                        if (this.canSelectMany) {\n                            this.ui.list.domFocus();\n                        }\n                        dom.EventHelper.stop(event, true);\n                        break;\n                    case 17 /* RightArrow */:\n                        if (!this._canAcceptInBackground) {\n                            return; // needs to be enabled\n                        }\n                        if (!this.ui.inputBox.isSelectionAtEnd()) {\n                            return; // ensure input box selection at end\n                        }\n                        if (this.activeItems[0]) {\n                            this._selectedItems = [this.activeItems[0]];\n                            this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                            this.handleAccept(true);\n                        }\n                        break;\n                    case 14 /* Home */:\n                        if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {\n                            this.ui.list.focus(QuickInputListFocus.First);\n                            dom.EventHelper.stop(event, true);\n                        }\n                        break;\n                    case 13 /* End */:\n                        if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {\n                            this.ui.list.focus(QuickInputListFocus.Last);\n                            dom.EventHelper.stop(event, true);\n                        }\n                        break;\n                }\n            }));\n            this.visibleDisposables.add(this.ui.onDidAccept(() => {\n                if (this.canSelectMany) {\n                    // if there are no checked elements, it means that an onDidChangeSelection never fired to overwrite\n                    // `_selectedItems`. In that case, we should emit one with an empty array to ensure that\n                    // `.selectedItems` is up to date.\n                    if (!this.ui.list.getCheckedElements().length) {\n                        this._selectedItems = [];\n                        this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    }\n                }\n                else if (this.activeItems[0]) {\n                    // For single-select, we set `selectedItems` to the item that was accepted.\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                }\n                this.handleAccept(false);\n            }));\n            this.visibleDisposables.add(this.ui.onDidCustom(() => {\n                this.onDidCustomEmitter.fire();\n            }));\n            this.visibleDisposables.add(this.ui.list.onDidChangeFocus(focusedItems => {\n                if (this.activeItemsUpdated) {\n                    return; // Expect another event.\n                }\n                if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._activeItems = focusedItems;\n                this.onDidChangeActiveEmitter.fire(focusedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {\n                if (this.canSelectMany) {\n                    if (selectedItems.length) {\n                        this.ui.list.setSelectedElements([]);\n                    }\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = selectedItems;\n                this.onDidChangeSelectionEmitter.fire(selectedItems);\n                if (selectedItems.length) {\n                    this.handleAccept(event instanceof MouseEvent && event.button === 1 /* mouse middle click */);\n                }\n            }));\n            this.visibleDisposables.add(this.ui.list.onChangedCheckedElements(checkedItems => {\n                if (!this.canSelectMany) {\n                    return;\n                }\n                if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {\n                    return;\n                }\n                this._selectedItems = checkedItems;\n                this.onDidChangeSelectionEmitter.fire(checkedItems);\n            }));\n            this.visibleDisposables.add(this.ui.list.onButtonTriggered(event => this.onDidTriggerItemButtonEmitter.fire(event)));\n            this.visibleDisposables.add(this.registerQuickNavigation());\n            this.valueSelectionUpdated = true;\n        }\n        super.show(); // TODO: Why have show() bubble up while update() trickles down? (Could move setComboboxAccessibility() here.)\n    }\n    handleAccept(inBackground) {\n        // Figure out veto via `onWillAccept` event\n        let veto = false;\n        this.onWillAcceptEmitter.fire({ veto: () => veto = true });\n        // Continue with `onDidAccept` if no veto\n        if (!veto) {\n            this.onDidAcceptEmitter.fire({ inBackground });\n        }\n    }\n    registerQuickNavigation() {\n        return dom.addDisposableListener(this.ui.container, dom.EventType.KEY_UP, e => {\n            if (this.canSelectMany || !this._quickNavigate) {\n                return;\n            }\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            const keyCode = keyboardEvent.keyCode;\n            // Select element when keys are pressed that signal it\n            const quickNavKeys = this._quickNavigate.keybindings;\n            const wasTriggerKeyPressed = quickNavKeys.some(k => {\n                const [firstPart, chordPart] = k.getParts();\n                if (chordPart) {\n                    return false;\n                }\n                if (firstPart.shiftKey && keyCode === 4 /* Shift */) {\n                    if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {\n                        return false; // this is an optimistic check for the shift key being used to navigate back in quick input\n                    }\n                    return true;\n                }\n                if (firstPart.altKey && keyCode === 6 /* Alt */) {\n                    return true;\n                }\n                if (firstPart.ctrlKey && keyCode === 5 /* Ctrl */) {\n                    return true;\n                }\n                if (firstPart.metaKey && keyCode === 57 /* Meta */) {\n                    return true;\n                }\n                return false;\n            });\n            if (wasTriggerKeyPressed) {\n                if (this.activeItems[0]) {\n                    this._selectedItems = [this.activeItems[0]];\n                    this.onDidChangeSelectionEmitter.fire(this.selectedItems);\n                    this.handleAccept(false);\n                }\n                // Unset quick navigate after press. It is only valid once\n                // and should not result in any behaviour change afterwards\n                // if the picker remains open because there was no active item\n                this._quickNavigate = undefined;\n            }\n        });\n    }\n    update() {\n        if (!this.visible) {\n            return;\n        }\n        // store the scrollTop before it is reset\n        const scrollTopBefore = this.keepScrollPosition ? this.scrollTop : 0;\n        const hideInput = !!this._hideInput && this._items.length > 0;\n        this.ui.container.classList.toggle('hidden-input', hideInput && !this.description);\n        const visibilities = {\n            title: !!this.title || !!this.step || !!this.buttons.length,\n            description: !!this.description,\n            checkAll: this.canSelectMany && !this._hideCheckAll,\n            checkBox: this.canSelectMany,\n            inputBox: !hideInput,\n            progressBar: !hideInput,\n            visibleCount: true,\n            count: this.canSelectMany,\n            ok: this.ok === 'default' ? this.canSelectMany : this.ok,\n            list: true,\n            message: !!this.validationMessage,\n            customButton: this.customButton\n        };\n        this.ui.setVisibilities(visibilities);\n        super.update();\n        if (this.ui.inputBox.value !== this.value) {\n            this.ui.inputBox.value = this.value;\n        }\n        if (this.valueSelectionUpdated) {\n            this.valueSelectionUpdated = false;\n            this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });\n        }\n        if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {\n            this.ui.inputBox.placeholder = (this.placeholder || '');\n        }\n        const ariaLabel = this.ariaLabel || this.placeholder || QuickPick.DEFAULT_ARIA_LABEL;\n        if (this.ui.inputBox.ariaLabel !== ariaLabel) {\n            this.ui.inputBox.ariaLabel = ariaLabel;\n        }\n        this.ui.list.matchOnDescription = this.matchOnDescription;\n        this.ui.list.matchOnDetail = this.matchOnDetail;\n        this.ui.list.matchOnLabel = this.matchOnLabel;\n        this.ui.list.sortByLabel = this.sortByLabel;\n        if (this.itemsUpdated) {\n            this.itemsUpdated = false;\n            this.ui.list.setElements(this.items);\n            this.ui.list.filter(this.filterValue(this.ui.inputBox.value));\n            this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();\n            this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());\n            this.ui.count.setCount(this.ui.list.getCheckedCount());\n            switch (this._itemActivation) {\n                case ItemActivation.NONE:\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                case ItemActivation.SECOND:\n                    this.ui.list.focus(QuickInputListFocus.Second);\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                case ItemActivation.LAST:\n                    this.ui.list.focus(QuickInputListFocus.Last);\n                    this._itemActivation = ItemActivation.FIRST; // only valid once, then unset\n                    break;\n                default:\n                    this.trySelectFirst();\n                    break;\n            }\n        }\n        if (this.ui.container.classList.contains('show-checkboxes') !== !!this.canSelectMany) {\n            if (this.canSelectMany) {\n                this.ui.list.clearFocus();\n            }\n            else {\n                this.trySelectFirst();\n            }\n        }\n        if (this.activeItemsUpdated) {\n            this.activeItemsUpdated = false;\n            this.activeItemsToConfirm = this._activeItems;\n            this.ui.list.setFocusedElements(this.activeItems);\n            if (this.activeItemsToConfirm === this._activeItems) {\n                this.activeItemsToConfirm = null;\n            }\n        }\n        if (this.selectedItemsUpdated) {\n            this.selectedItemsUpdated = false;\n            this.selectedItemsToConfirm = this._selectedItems;\n            if (this.canSelectMany) {\n                this.ui.list.setCheckedElements(this.selectedItems);\n            }\n            else {\n                this.ui.list.setSelectedElements(this.selectedItems);\n            }\n            if (this.selectedItemsToConfirm === this._selectedItems) {\n                this.selectedItemsToConfirm = null;\n            }\n        }\n        this.ui.customButton.label = this.customLabel || '';\n        this.ui.customButton.element.title = this.customHover || '';\n        this.ui.setComboboxAccessibility(true);\n        if (!visibilities.inputBox) {\n            // we need to move focus into the tree to detect keybindings\n            // properly when the input box is not visible (quick nav)\n            this.ui.list.domFocus();\n            // Focus the first element in the list if multiselect is enabled\n            if (this.canSelectMany) {\n                this.ui.list.focus(QuickInputListFocus.First);\n            }\n        }\n        // Set the scroll position to what it was before updating the items\n        if (this.keepScrollPosition) {\n            this.scrollTop = scrollTopBefore;\n        }\n    }\n}\nQuickPick.DEFAULT_ARIA_LABEL = localize('quickInputBox.ariaLabel', \"Type to narrow down results.\");\nexport class QuickInputController extends Disposable {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.comboboxAccessibility = false;\n        this.enabled = true;\n        this.onDidAcceptEmitter = this._register(new Emitter());\n        this.onDidCustomEmitter = this._register(new Emitter());\n        this.onDidTriggerButtonEmitter = this._register(new Emitter());\n        this.keyMods = { ctrlCmd: false, alt: false };\n        this.controller = null;\n        this.onShowEmitter = this._register(new Emitter());\n        this.onShow = this.onShowEmitter.event;\n        this.onHideEmitter = this._register(new Emitter());\n        this.onHide = this.onHideEmitter.event;\n        this.idPrefix = options.idPrefix;\n        this.parentElement = options.container;\n        this.styles = options.styles;\n        this.registerKeyModsListeners();\n    }\n    registerKeyModsListeners() {\n        const listener = (e) => {\n            this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;\n            this.keyMods.alt = e.altKey;\n        };\n        this._register(dom.addDisposableListener(window, dom.EventType.KEY_DOWN, listener, true));\n        this._register(dom.addDisposableListener(window, dom.EventType.KEY_UP, listener, true));\n        this._register(dom.addDisposableListener(window, dom.EventType.MOUSE_DOWN, listener, true));\n    }\n    getUI() {\n        if (this.ui) {\n            return this.ui;\n        }\n        const container = dom.append(this.parentElement, $('.quick-input-widget.show-file-icons'));\n        container.tabIndex = -1;\n        container.style.display = 'none';\n        const styleSheet = dom.createStyleSheet(container);\n        const titleBar = dom.append(container, $('.quick-input-titlebar'));\n        const leftActionBar = this._register(new ActionBar(titleBar));\n        leftActionBar.domNode.classList.add('quick-input-left-action-bar');\n        const title = dom.append(titleBar, $('.quick-input-title'));\n        const rightActionBar = this._register(new ActionBar(titleBar));\n        rightActionBar.domNode.classList.add('quick-input-right-action-bar');\n        const description1 = dom.append(container, $('.quick-input-description'));\n        const headerContainer = dom.append(container, $('.quick-input-header'));\n        const checkAll = dom.append(headerContainer, $('input.quick-input-check-all'));\n        checkAll.type = 'checkbox';\n        this._register(dom.addStandardDisposableListener(checkAll, dom.EventType.CHANGE, e => {\n            const checked = checkAll.checked;\n            list.setAllVisibleChecked(checked);\n        }));\n        this._register(dom.addDisposableListener(checkAll, dom.EventType.CLICK, e => {\n            if (e.x || e.y) { // Avoid 'click' triggered by 'space'...\n                inputBox.setFocus();\n            }\n        }));\n        const description2 = dom.append(headerContainer, $('.quick-input-description'));\n        const extraContainer = dom.append(headerContainer, $('.quick-input-and-message'));\n        const filterContainer = dom.append(extraContainer, $('.quick-input-filter'));\n        const inputBox = this._register(new QuickInputBox(filterContainer));\n        inputBox.setAttribute('aria-describedby', `${this.idPrefix}message`);\n        const visibleCountContainer = dom.append(filterContainer, $('.quick-input-visible-count'));\n        visibleCountContainer.setAttribute('aria-live', 'polite');\n        visibleCountContainer.setAttribute('aria-atomic', 'true');\n        const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, \"{0} Results\") });\n        const countContainer = dom.append(filterContainer, $('.quick-input-count'));\n        countContainer.setAttribute('aria-live', 'polite');\n        const count = new CountBadge(countContainer, { countFormat: localize({ key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, \"{0} Selected\") });\n        const okContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const ok = new Button(okContainer);\n        ok.label = localize('ok', \"OK\");\n        this._register(ok.onDidClick(e => {\n            this.onDidAcceptEmitter.fire();\n        }));\n        const customButtonContainer = dom.append(headerContainer, $('.quick-input-action'));\n        const customButton = new Button(customButtonContainer);\n        customButton.label = localize('custom', \"Custom\");\n        this._register(customButton.onDidClick(e => {\n            this.onDidCustomEmitter.fire();\n        }));\n        const message = dom.append(extraContainer, $(`#${this.idPrefix}message.quick-input-message`));\n        const list = this._register(new QuickInputList(container, this.idPrefix + 'list', this.options));\n        this._register(list.onChangedAllVisibleChecked(checked => {\n            checkAll.checked = checked;\n        }));\n        this._register(list.onChangedVisibleCount(c => {\n            visibleCount.setCount(c);\n        }));\n        this._register(list.onChangedCheckedCount(c => {\n            count.setCount(c);\n        }));\n        this._register(list.onLeave(() => {\n            // Defer to avoid the input field reacting to the triggering key.\n            setTimeout(() => {\n                inputBox.setFocus();\n                if (this.controller instanceof QuickPick && this.controller.canSelectMany) {\n                    list.clearFocus();\n                }\n            }, 0);\n        }));\n        this._register(list.onDidChangeFocus(() => {\n            if (this.comboboxAccessibility) {\n                this.getUI().inputBox.setAttribute('aria-activedescendant', this.getUI().list.getActiveDescendant() || '');\n            }\n        }));\n        const progressBar = new ProgressBar(container);\n        progressBar.getContainer().classList.add('quick-input-progress');\n        const focusTracker = dom.trackFocus(container);\n        this._register(focusTracker);\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, e => {\n            this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : undefined;\n        }, true));\n        this._register(focusTracker.onDidBlur(() => {\n            if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {\n                this.hide(QuickInputHideReason.Blur);\n            }\n            this.previousFocusElement = undefined;\n        }));\n        this._register(dom.addDisposableListener(container, dom.EventType.FOCUS, (e) => {\n            inputBox.setFocus();\n        }));\n        this._register(dom.addDisposableListener(container, dom.EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            switch (event.keyCode) {\n                case 3 /* Enter */:\n                    dom.EventHelper.stop(e, true);\n                    this.onDidAcceptEmitter.fire();\n                    break;\n                case 9 /* Escape */:\n                    dom.EventHelper.stop(e, true);\n                    this.hide(QuickInputHideReason.Gesture);\n                    break;\n                case 2 /* Tab */:\n                    if (!event.altKey && !event.ctrlKey && !event.metaKey) {\n                        const selectors = ['.action-label.codicon'];\n                        if (container.classList.contains('show-checkboxes')) {\n                            selectors.push('input');\n                        }\n                        else {\n                            selectors.push('input[type=text]');\n                        }\n                        if (this.getUI().list.isDisplayed()) {\n                            selectors.push('.monaco-list');\n                        }\n                        const stops = container.querySelectorAll(selectors.join(', '));\n                        if (event.shiftKey && event.target === stops[0]) {\n                            dom.EventHelper.stop(e, true);\n                            stops[stops.length - 1].focus();\n                        }\n                        else if (!event.shiftKey && event.target === stops[stops.length - 1]) {\n                            dom.EventHelper.stop(e, true);\n                            stops[0].focus();\n                        }\n                    }\n                    break;\n            }\n        }));\n        this.ui = {\n            container,\n            styleSheet,\n            leftActionBar,\n            titleBar,\n            title,\n            description1,\n            description2,\n            rightActionBar,\n            checkAll,\n            filterContainer,\n            inputBox,\n            visibleCountContainer,\n            visibleCount,\n            countContainer,\n            count,\n            okContainer,\n            ok,\n            message,\n            customButtonContainer,\n            customButton,\n            list,\n            progressBar,\n            onDidAccept: this.onDidAcceptEmitter.event,\n            onDidCustom: this.onDidCustomEmitter.event,\n            onDidTriggerButton: this.onDidTriggerButtonEmitter.event,\n            ignoreFocusOut: false,\n            keyMods: this.keyMods,\n            isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),\n            show: controller => this.show(controller),\n            hide: () => this.hide(),\n            setVisibilities: visibilities => this.setVisibilities(visibilities),\n            setComboboxAccessibility: enabled => this.setComboboxAccessibility(enabled),\n            setEnabled: enabled => this.setEnabled(enabled),\n            setContextKey: contextKey => this.options.setContextKey(contextKey),\n        };\n        this.updateStyles();\n        return this.ui;\n    }\n    pick(picks, options = {}, token = CancellationToken.None) {\n        return new Promise((doResolve, reject) => {\n            let resolve = (result) => {\n                resolve = doResolve;\n                if (options.onKeyMods) {\n                    options.onKeyMods(input.keyMods);\n                }\n                doResolve(result);\n            };\n            if (token.isCancellationRequested) {\n                resolve(undefined);\n                return;\n            }\n            const input = this.createQuickPick();\n            let activeItem;\n            const disposables = [\n                input,\n                input.onDidAccept(() => {\n                    if (input.canSelectMany) {\n                        resolve(input.selectedItems.slice());\n                        input.hide();\n                    }\n                    else {\n                        const result = input.activeItems[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidChangeActive(items => {\n                    const focused = items[0];\n                    if (focused && options.onDidFocus) {\n                        options.onDidFocus(focused);\n                    }\n                }),\n                input.onDidChangeSelection(items => {\n                    if (!input.canSelectMany) {\n                        const result = items[0];\n                        if (result) {\n                            resolve(result);\n                            input.hide();\n                        }\n                    }\n                }),\n                input.onDidTriggerItemButton(event => options.onDidTriggerItemButton && options.onDidTriggerItemButton(Object.assign(Object.assign({}, event), { removeItem: () => {\n                        const index = input.items.indexOf(event.item);\n                        if (index !== -1) {\n                            const items = input.items.slice();\n                            const removed = items.splice(index, 1);\n                            const activeItems = input.activeItems.filter(activeItem => activeItem !== removed[0]);\n                            const keepScrollPositionBefore = input.keepScrollPosition;\n                            input.keepScrollPosition = true;\n                            input.items = items;\n                            if (activeItems) {\n                                input.activeItems = activeItems;\n                            }\n                            input.keepScrollPosition = keepScrollPositionBefore;\n                        }\n                    } }))),\n                input.onDidChangeValue(value => {\n                    if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {\n                        input.activeItems = [activeItem];\n                    }\n                }),\n                token.onCancellationRequested(() => {\n                    input.hide();\n                }),\n                input.onDidHide(() => {\n                    dispose(disposables);\n                    resolve(undefined);\n                }),\n            ];\n            input.title = options.title;\n            input.canSelectMany = !!options.canPickMany;\n            input.placeholder = options.placeHolder;\n            input.ignoreFocusOut = !!options.ignoreFocusLost;\n            input.matchOnDescription = !!options.matchOnDescription;\n            input.matchOnDetail = !!options.matchOnDetail;\n            input.matchOnLabel = (options.matchOnLabel === undefined) || options.matchOnLabel; // default to true\n            input.autoFocusOnList = (options.autoFocusOnList === undefined) || options.autoFocusOnList; // default to true\n            input.quickNavigate = options.quickNavigate;\n            input.contextKey = options.contextKey;\n            input.busy = true;\n            Promise.all([picks, options.activeItem])\n                .then(([items, _activeItem]) => {\n                activeItem = _activeItem;\n                input.busy = false;\n                input.items = items;\n                if (input.canSelectMany) {\n                    input.selectedItems = items.filter(item => item.type !== 'separator' && item.picked);\n                }\n                if (activeItem) {\n                    input.activeItems = [activeItem];\n                }\n            });\n            input.show();\n            Promise.resolve(picks).then(undefined, err => {\n                reject(err);\n                input.hide();\n            });\n        });\n    }\n    createQuickPick() {\n        const ui = this.getUI();\n        return new QuickPick(ui);\n    }\n    show(controller) {\n        const ui = this.getUI();\n        this.onShowEmitter.fire();\n        const oldController = this.controller;\n        this.controller = controller;\n        if (oldController) {\n            oldController.didHide();\n        }\n        this.setEnabled(true);\n        ui.leftActionBar.clear();\n        ui.title.textContent = '';\n        ui.description1.textContent = '';\n        ui.description2.textContent = '';\n        ui.rightActionBar.clear();\n        ui.checkAll.checked = false;\n        // ui.inputBox.value = ''; Avoid triggering an event.\n        ui.inputBox.placeholder = '';\n        ui.inputBox.password = false;\n        ui.inputBox.showDecoration(Severity.Ignore);\n        ui.visibleCount.setCount(0);\n        ui.count.setCount(0);\n        dom.reset(ui.message);\n        ui.progressBar.stop();\n        ui.list.setElements([]);\n        ui.list.matchOnDescription = false;\n        ui.list.matchOnDetail = false;\n        ui.list.matchOnLabel = true;\n        ui.list.sortByLabel = true;\n        ui.ignoreFocusOut = false;\n        this.setComboboxAccessibility(false);\n        ui.inputBox.ariaLabel = '';\n        const backKeybindingLabel = this.options.backKeybindingLabel();\n        backButton.tooltip = backKeybindingLabel ? localize('quickInput.backWithKeybinding', \"Back ({0})\", backKeybindingLabel) : localize('quickInput.back', \"Back\");\n        ui.container.style.display = '';\n        this.updateLayout();\n        ui.inputBox.setFocus();\n    }\n    setVisibilities(visibilities) {\n        const ui = this.getUI();\n        ui.title.style.display = visibilities.title ? '' : 'none';\n        ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? '' : 'none';\n        ui.checkAll.style.display = visibilities.checkAll ? '' : 'none';\n        ui.filterContainer.style.display = visibilities.inputBox ? '' : 'none';\n        ui.visibleCountContainer.style.display = visibilities.visibleCount ? '' : 'none';\n        ui.countContainer.style.display = visibilities.count ? '' : 'none';\n        ui.okContainer.style.display = visibilities.ok ? '' : 'none';\n        ui.customButtonContainer.style.display = visibilities.customButton ? '' : 'none';\n        ui.message.style.display = visibilities.message ? '' : 'none';\n        ui.progressBar.getContainer().style.display = visibilities.progressBar ? '' : 'none';\n        ui.list.display(!!visibilities.list);\n        ui.container.classList[visibilities.checkBox ? 'add' : 'remove']('show-checkboxes');\n        this.updateLayout(); // TODO\n    }\n    setComboboxAccessibility(enabled) {\n        if (enabled !== this.comboboxAccessibility) {\n            const ui = this.getUI();\n            this.comboboxAccessibility = enabled;\n            if (this.comboboxAccessibility) {\n                ui.inputBox.setAttribute('role', 'combobox');\n                ui.inputBox.setAttribute('aria-haspopup', 'true');\n                ui.inputBox.setAttribute('aria-autocomplete', 'list');\n                ui.inputBox.setAttribute('aria-activedescendant', ui.list.getActiveDescendant() || '');\n            }\n            else {\n                ui.inputBox.removeAttribute('role');\n                ui.inputBox.removeAttribute('aria-haspopup');\n                ui.inputBox.removeAttribute('aria-autocomplete');\n                ui.inputBox.removeAttribute('aria-activedescendant');\n            }\n        }\n    }\n    setEnabled(enabled) {\n        if (enabled !== this.enabled) {\n            this.enabled = enabled;\n            for (const item of this.getUI().leftActionBar.viewItems) {\n                item.getAction().enabled = enabled;\n            }\n            for (const item of this.getUI().rightActionBar.viewItems) {\n                item.getAction().enabled = enabled;\n            }\n            this.getUI().checkAll.disabled = !enabled;\n            // this.getUI().inputBox.enabled = enabled; Avoid loosing focus.\n            this.getUI().ok.enabled = enabled;\n            this.getUI().list.enabled = enabled;\n        }\n    }\n    hide(reason) {\n        var _a;\n        const controller = this.controller;\n        if (controller) {\n            const focusChanged = !((_a = this.ui) === null || _a === void 0 ? void 0 : _a.container.contains(document.activeElement));\n            this.controller = null;\n            this.onHideEmitter.fire();\n            this.getUI().container.style.display = 'none';\n            if (!focusChanged) {\n                let currentElement = this.previousFocusElement;\n                while (currentElement && !currentElement.offsetParent) {\n                    currentElement = withNullAsUndefined(currentElement.parentElement);\n                }\n                if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetParent) {\n                    currentElement.focus();\n                    this.previousFocusElement = undefined;\n                }\n                else {\n                    this.options.returnFocus();\n                }\n            }\n            controller.didHide(reason);\n        }\n    }\n    layout(dimension, titleBarOffset) {\n        this.dimension = dimension;\n        this.titleBarOffset = titleBarOffset;\n        this.updateLayout();\n    }\n    updateLayout() {\n        if (this.ui) {\n            this.ui.container.style.top = `${this.titleBarOffset}px`;\n            const style = this.ui.container.style;\n            const width = Math.min(this.dimension.width * 0.62 /* golden cut */, QuickInputController.MAX_WIDTH);\n            style.width = width + 'px';\n            style.marginLeft = '-' + (width / 2) + 'px';\n            this.ui.inputBox.layout();\n            this.ui.list.layout(this.dimension && this.dimension.height * 0.4);\n        }\n    }\n    applyStyles(styles) {\n        this.styles = styles;\n        this.updateStyles();\n    }\n    updateStyles() {\n        if (this.ui) {\n            const { quickInputTitleBackground, quickInputBackground, quickInputForeground, contrastBorder, widgetShadow, } = this.styles.widget;\n            this.ui.titleBar.style.backgroundColor = quickInputTitleBackground ? quickInputTitleBackground.toString() : '';\n            this.ui.container.style.backgroundColor = quickInputBackground ? quickInputBackground.toString() : '';\n            this.ui.container.style.color = quickInputForeground ? quickInputForeground.toString() : '';\n            this.ui.container.style.border = contrastBorder ? `1px solid ${contrastBorder}` : '';\n            this.ui.container.style.boxShadow = widgetShadow ? `0 0 8px 2px ${widgetShadow}` : '';\n            this.ui.inputBox.style(this.styles.inputBox);\n            this.ui.count.style(this.styles.countBadge);\n            this.ui.ok.style(this.styles.button);\n            this.ui.customButton.style(this.styles.button);\n            this.ui.progressBar.style(this.styles.progressBar);\n            this.ui.list.style(this.styles.list);\n            const content = [];\n            if (this.styles.list.pickerGroupBorder) {\n                content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`);\n            }\n            if (this.styles.list.pickerGroupForeground) {\n                content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`);\n            }\n            if (this.styles.keybindingLabel.keybindingLabelBackground ||\n                this.styles.keybindingLabel.keybindingLabelBorder ||\n                this.styles.keybindingLabel.keybindingLabelBottomBorder ||\n                this.styles.keybindingLabel.keybindingLabelShadow ||\n                this.styles.keybindingLabel.keybindingLabelForeground) {\n                content.push('.quick-input-list .monaco-keybinding > .monaco-keybinding-key {');\n                if (this.styles.keybindingLabel.keybindingLabelBackground) {\n                    content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBorder) {\n                    // Order matters here. `border-color` must come before `border-bottom-color`.\n                    content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {\n                    content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelShadow) {\n                    content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);\n                }\n                if (this.styles.keybindingLabel.keybindingLabelForeground) {\n                    content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);\n                }\n                content.push('}');\n            }\n            const newStyles = content.join('\\n');\n            if (newStyles !== this.ui.styleSheet.textContent) {\n                this.ui.styleSheet.textContent = newStyles;\n            }\n        }\n    }\n}\nQuickInputController.MAX_WIDTH = 600; // Max total width of quick input widget\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { once } from '../../../base/common/functional.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { DefaultQuickAccessFilterValue, Extensions } from '../common/quickAccess.js';\nimport { IQuickInputService, ItemActivation } from '../common/quickInput.js';\nimport { Registry } from '../../registry/common/platform.js';\nlet QuickAccessController = class QuickAccessController extends Disposable {\n    constructor(quickInputService, instantiationService) {\n        super();\n        this.quickInputService = quickInputService;\n        this.instantiationService = instantiationService;\n        this.registry = Registry.as(Extensions.Quickaccess);\n        this.mapProviderToDescriptor = new Map();\n        this.lastAcceptedPickerValues = new Map();\n        this.visibleQuickAccess = undefined;\n    }\n    show(value = '', options) {\n        this.doShowOrPick(value, false, options);\n    }\n    doShowOrPick(value, pick, options) {\n        var _a;\n        // Find provider for the value to show\n        const [provider, descriptor] = this.getOrInstantiateProvider(value);\n        // Return early if quick access is already showing on that same prefix\n        const visibleQuickAccess = this.visibleQuickAccess;\n        const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;\n        if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {\n            // Apply value only if it is more specific than the prefix\n            // from the provider and we are not instructed to preserve\n            if (value !== descriptor.prefix && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {\n                visibleQuickAccess.picker.value = value;\n            }\n            // Always adjust selection\n            this.adjustValueSelection(visibleQuickAccess.picker, descriptor, options);\n            return;\n        }\n        // Rewrite the filter value based on certain rules unless disabled\n        if (descriptor && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {\n            let newValue = undefined;\n            // If we have a visible provider with a value, take it's filter value but\n            // rewrite to new provider prefix in case they differ\n            if (visibleQuickAccess && visibleDescriptor && visibleDescriptor !== descriptor) {\n                const newValueCandidateWithoutPrefix = visibleQuickAccess.value.substr(visibleDescriptor.prefix.length);\n                if (newValueCandidateWithoutPrefix) {\n                    newValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;\n                }\n            }\n            // Otherwise, take a default value as instructed\n            if (!newValue) {\n                const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;\n                if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {\n                    newValue = this.lastAcceptedPickerValues.get(descriptor);\n                }\n                else if (typeof defaultFilterValue === 'string') {\n                    newValue = `${descriptor.prefix}${defaultFilterValue}`;\n                }\n            }\n            if (typeof newValue === 'string') {\n                value = newValue;\n            }\n        }\n        // Create a picker for the provider to use with the initial value\n        // and adjust the filtering to exclude the prefix from filtering\n        const disposables = new DisposableStore();\n        const picker = disposables.add(this.quickInputService.createQuickPick());\n        picker.value = value;\n        this.adjustValueSelection(picker, descriptor, options);\n        picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;\n        picker.quickNavigate = options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration;\n        picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess; // only hide input if there was no picker opened already\n        if (typeof (options === null || options === void 0 ? void 0 : options.itemActivation) === 'number' || (options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration)) {\n            picker.itemActivation = (_a = options === null || options === void 0 ? void 0 : options.itemActivation) !== null && _a !== void 0 ? _a : ItemActivation.SECOND /* quick nav is always second */;\n        }\n        picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;\n        picker.filterValue = (value) => value.substring(descriptor ? descriptor.prefix.length : 0);\n        if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder) {\n            picker.ariaLabel = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;\n        }\n        // Pick mode: setup a promise that can be resolved\n        // with the selected items and prevent execution\n        let pickPromise = undefined;\n        if (pick) {\n            pickPromise = new DeferredPromise();\n            disposables.add(once(picker.onWillAccept)(e => {\n                e.veto();\n                picker.hide();\n            }));\n        }\n        // Register listeners\n        disposables.add(this.registerPickerListeners(picker, provider, descriptor, value));\n        // Ask provider to fill the picker as needed if we have one\n        // and pass over a cancellation token that will indicate when\n        // the picker is hiding without a pick being made.\n        const cts = disposables.add(new CancellationTokenSource());\n        if (provider) {\n            disposables.add(provider.provide(picker, cts.token));\n        }\n        // Finally, trigger disposal and cancellation when the picker\n        // hides depending on items selected or not.\n        once(picker.onDidHide)(() => {\n            if (picker.selectedItems.length === 0) {\n                cts.cancel();\n            }\n            // Start to dispose once picker hides\n            disposables.dispose();\n            // Resolve pick promise with selected items\n            pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.complete(picker.selectedItems.slice(0));\n        });\n        // Finally, show the picker. This is important because a provider\n        // may not call this and then our disposables would leak that rely\n        // on the onDidHide event.\n        picker.show();\n        // Pick mode: return with promise\n        if (pick) {\n            return pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.p;\n        }\n    }\n    adjustValueSelection(picker, descriptor, options) {\n        var _a;\n        let valueSelection;\n        // Preserve: just always put the cursor at the end\n        if (options === null || options === void 0 ? void 0 : options.preserveValue) {\n            valueSelection = [picker.value.length, picker.value.length];\n        }\n        // Otherwise: select the value up until the prefix\n        else {\n            valueSelection = [(_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a !== void 0 ? _a : 0, picker.value.length];\n        }\n        picker.valueSelection = valueSelection;\n    }\n    registerPickerListeners(picker, provider, descriptor, value) {\n        const disposables = new DisposableStore();\n        // Remember as last visible picker and clean up once picker get's disposed\n        const visibleQuickAccess = this.visibleQuickAccess = { picker, descriptor, value };\n        disposables.add(toDisposable(() => {\n            if (visibleQuickAccess === this.visibleQuickAccess) {\n                this.visibleQuickAccess = undefined;\n            }\n        }));\n        // Whenever the value changes, check if the provider has\n        // changed and if so - re-create the picker from the beginning\n        disposables.add(picker.onDidChangeValue(value => {\n            const [providerForValue] = this.getOrInstantiateProvider(value);\n            if (providerForValue !== provider) {\n                this.show(value, { preserveValue: true } /* do not rewrite value from user typing! */);\n            }\n            else {\n                visibleQuickAccess.value = value; // remember the value in our visible one\n            }\n        }));\n        // Remember picker input for future use when accepting\n        if (descriptor) {\n            disposables.add(picker.onDidAccept(() => {\n                this.lastAcceptedPickerValues.set(descriptor, picker.value);\n            }));\n        }\n        return disposables;\n    }\n    getOrInstantiateProvider(value) {\n        const providerDescriptor = this.registry.getQuickAccessProvider(value);\n        if (!providerDescriptor) {\n            return [undefined, undefined];\n        }\n        let provider = this.mapProviderToDescriptor.get(providerDescriptor);\n        if (!provider) {\n            provider = this.instantiationService.createInstance(providerDescriptor.ctor);\n            this.mapProviderToDescriptor.set(providerDescriptor, provider);\n        }\n        return [provider, providerDescriptor];\n    }\n};\nQuickAccessController = __decorate([\n    __param(0, IQuickInputService),\n    __param(1, IInstantiationService)\n], QuickAccessController);\nexport { QuickAccessController };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { QuickInputController } from '../../../base/parts/quickinput/browser/quickInput.js';\nimport { IAccessibilityService } from '../../accessibility/common/accessibility.js';\nimport { IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { WorkbenchList } from '../../list/browser/listService.js';\nimport { QuickAccessController } from './quickAccess.js';\nimport { activeContrastBorder, badgeBackground, badgeForeground, buttonBackground, buttonForeground, buttonHoverBackground, contrastBorder, inputBackground, inputBorder, inputForeground, inputValidationErrorBackground, inputValidationErrorBorder, inputValidationErrorForeground, inputValidationInfoBackground, inputValidationInfoBorder, inputValidationInfoForeground, inputValidationWarningBackground, inputValidationWarningBorder, inputValidationWarningForeground, keybindingLabelBackground, keybindingLabelBorder, keybindingLabelBottomBorder, keybindingLabelForeground, pickerGroupBorder, pickerGroupForeground, progressBarBackground, quickInputBackground, quickInputForeground, quickInputListFocusBackground, quickInputListFocusForeground, quickInputListFocusIconForeground, quickInputTitleBackground, widgetShadow } from '../../theme/common/colorRegistry.js';\nimport { computeStyles } from '../../theme/common/styler.js';\nimport { IThemeService, Themable } from '../../theme/common/themeService.js';\nlet QuickInputService = class QuickInputService extends Themable {\n    constructor(instantiationService, contextKeyService, themeService, accessibilityService, layoutService) {\n        super(themeService);\n        this.instantiationService = instantiationService;\n        this.contextKeyService = contextKeyService;\n        this.accessibilityService = accessibilityService;\n        this.layoutService = layoutService;\n        this.contexts = new Map();\n    }\n    get controller() {\n        if (!this._controller) {\n            this._controller = this._register(this.createController());\n        }\n        return this._controller;\n    }\n    get quickAccess() {\n        if (!this._quickAccess) {\n            this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));\n        }\n        return this._quickAccess;\n    }\n    createController(host = this.layoutService, options) {\n        var _a, _b;\n        const defaultOptions = {\n            idPrefix: 'quickInput_',\n            container: host.container,\n            ignoreFocusOut: () => false,\n            isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),\n            backKeybindingLabel: () => undefined,\n            setContextKey: (id) => this.setContextKey(id),\n            returnFocus: () => host.focus(),\n            createList: (user, container, delegate, renderers, options) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options),\n            styles: this.computeStyles()\n        };\n        const controller = this._register(new QuickInputController(Object.assign(Object.assign({}, defaultOptions), options)));\n        controller.layout(host.dimension, (_b = (_a = host.offset) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : 0);\n        // Layout changes\n        this._register(host.onDidLayout(dimension => { var _a, _b; return controller.layout(dimension, (_b = (_a = host.offset) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : 0); }));\n        // Context keys\n        this._register(controller.onShow(() => this.resetContextKeys()));\n        this._register(controller.onHide(() => this.resetContextKeys()));\n        return controller;\n    }\n    setContextKey(id) {\n        let key;\n        if (id) {\n            key = this.contexts.get(id);\n            if (!key) {\n                key = new RawContextKey(id, false)\n                    .bindTo(this.contextKeyService);\n                this.contexts.set(id, key);\n            }\n        }\n        if (key && key.get()) {\n            return; // already active context\n        }\n        this.resetContextKeys();\n        if (key) {\n            key.set(true);\n        }\n    }\n    resetContextKeys() {\n        this.contexts.forEach(context => {\n            if (context.get()) {\n                context.reset();\n            }\n        });\n    }\n    pick(picks, options = {}, token = CancellationToken.None) {\n        return this.controller.pick(picks, options, token);\n    }\n    createQuickPick() {\n        return this.controller.createQuickPick();\n    }\n    updateStyles() {\n        this.controller.applyStyles(this.computeStyles());\n    }\n    computeStyles() {\n        return {\n            widget: Object.assign({}, computeStyles(this.theme, {\n                quickInputBackground,\n                quickInputForeground,\n                quickInputTitleBackground,\n                contrastBorder,\n                widgetShadow\n            })),\n            inputBox: computeStyles(this.theme, {\n                inputForeground,\n                inputBackground,\n                inputBorder,\n                inputValidationInfoBackground,\n                inputValidationInfoForeground,\n                inputValidationInfoBorder,\n                inputValidationWarningBackground,\n                inputValidationWarningForeground,\n                inputValidationWarningBorder,\n                inputValidationErrorBackground,\n                inputValidationErrorForeground,\n                inputValidationErrorBorder\n            }),\n            countBadge: computeStyles(this.theme, {\n                badgeBackground,\n                badgeForeground,\n                badgeBorder: contrastBorder\n            }),\n            button: computeStyles(this.theme, {\n                buttonForeground,\n                buttonBackground,\n                buttonHoverBackground,\n                buttonBorder: contrastBorder\n            }),\n            progressBar: computeStyles(this.theme, {\n                progressBarBackground\n            }),\n            keybindingLabel: computeStyles(this.theme, {\n                keybindingLabelBackground,\n                keybindingLabelForeground,\n                keybindingLabelBorder,\n                keybindingLabelBottomBorder,\n                keybindingLabelShadow: widgetShadow\n            }),\n            list: computeStyles(this.theme, {\n                listBackground: quickInputBackground,\n                // Look like focused when inactive.\n                listInactiveFocusForeground: quickInputListFocusForeground,\n                listInactiveSelectionIconForeground: quickInputListFocusIconForeground,\n                listInactiveFocusBackground: quickInputListFocusBackground,\n                listFocusOutline: activeContrastBorder,\n                listInactiveFocusOutline: activeContrastBorder,\n                pickerGroupBorder,\n                pickerGroupForeground\n            })\n        };\n    }\n};\nQuickInputService = __decorate([\n    __param(0, IInstantiationService),\n    __param(1, IContextKeyService),\n    __param(2, IThemeService),\n    __param(3, IAccessibilityService),\n    __param(4, ILayoutService)\n], QuickInputService);\nexport { QuickInputService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './standaloneQuickInput.css';\nimport { registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';\nimport { EditorScopedLayoutService } from '../standaloneLayoutService.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { QuickInputService } from '../../../../platform/quickinput/browser/quickInput.js';\nimport { once } from '../../../../base/common/functional.js';\nlet EditorScopedQuickInputService = class EditorScopedQuickInputService extends QuickInputService {\n    constructor(editor, instantiationService, contextKeyService, themeService, accessibilityService, codeEditorService) {\n        super(instantiationService, contextKeyService, themeService, accessibilityService, new EditorScopedLayoutService(editor.getContainerDomNode(), codeEditorService));\n        this.host = undefined;\n        // Use the passed in code editor as host for the quick input widget\n        const contribution = QuickInputEditorContribution.get(editor);\n        if (contribution) {\n            const widget = contribution.widget;\n            this.host = {\n                _serviceBrand: undefined,\n                get hasContainer() { return true; },\n                get container() { return widget.getDomNode(); },\n                get dimension() { return editor.getLayoutInfo(); },\n                get onDidLayout() { return editor.onDidLayoutChange; },\n                focus: () => editor.focus()\n            };\n        }\n        else {\n            this.host = undefined;\n        }\n    }\n    createController() {\n        return super.createController(this.host);\n    }\n};\nEditorScopedQuickInputService = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IContextKeyService),\n    __param(3, IThemeService),\n    __param(4, IAccessibilityService),\n    __param(5, ICodeEditorService)\n], EditorScopedQuickInputService);\nexport { EditorScopedQuickInputService };\nlet StandaloneQuickInputService = class StandaloneQuickInputService {\n    constructor(instantiationService, codeEditorService) {\n        this.instantiationService = instantiationService;\n        this.codeEditorService = codeEditorService;\n        this.mapEditorToService = new Map();\n    }\n    get activeService() {\n        const editor = this.codeEditorService.getFocusedCodeEditor();\n        if (!editor) {\n            throw new Error('Quick input service needs a focused editor to work.');\n        }\n        // Find the quick input implementation for the focused\n        // editor or create it lazily if not yet created\n        let quickInputService = this.mapEditorToService.get(editor);\n        if (!quickInputService) {\n            const newQuickInputService = quickInputService = this.instantiationService.createInstance(EditorScopedQuickInputService, editor);\n            this.mapEditorToService.set(editor, quickInputService);\n            once(editor.onDidDispose)(() => {\n                newQuickInputService.dispose();\n                this.mapEditorToService.delete(editor);\n            });\n        }\n        return quickInputService;\n    }\n    get quickAccess() { return this.activeService.quickAccess; }\n    pick(picks, options = {}, token = CancellationToken.None) {\n        return this.activeService /* TS fail */.pick(picks, options, token);\n    }\n    createQuickPick() {\n        return this.activeService.createQuickPick();\n    }\n};\nStandaloneQuickInputService = __decorate([\n    __param(0, IInstantiationService),\n    __param(1, ICodeEditorService)\n], StandaloneQuickInputService);\nexport { StandaloneQuickInputService };\nexport class QuickInputEditorContribution {\n    constructor(editor) {\n        this.editor = editor;\n        this.widget = new QuickInputEditorWidget(this.editor);\n    }\n    static get(editor) {\n        return editor.getContribution(QuickInputEditorContribution.ID);\n    }\n    dispose() {\n        this.widget.dispose();\n    }\n}\nQuickInputEditorContribution.ID = 'editor.controller.quickInput';\nexport class QuickInputEditorWidget {\n    constructor(codeEditor) {\n        this.codeEditor = codeEditor;\n        this.domNode = document.createElement('div');\n        this.codeEditor.addOverlayWidget(this);\n    }\n    getId() {\n        return QuickInputEditorWidget.ID;\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    getPosition() {\n        return { preference: 2 /* TOP_CENTER */ };\n    }\n    dispose() {\n        this.codeEditor.removeOverlayWidget(this);\n    }\n}\nQuickInputEditorWidget.ID = 'editor.contrib.quickInputWidget';\nregisterEditorContribution(QuickInputEditorContribution.ID, QuickInputEditorContribution);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (let color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* Comment */;\n        case 'string':\n            return 2 /* String */;\n        case 'regex':\n            return 3 /* RegEx */;\n        case 'regexp':\n            return 3 /* RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { editorActiveIndentGuides, editorIndentGuides } from '../../common/core/editorColorRegistry.js';\nimport { editorBackground, editorForeground, editorInactiveSelection, editorSelectionHighlight } from '../../../platform/theme/common/colorRegistry.js';\n/* -------------------------------- Begin vs theme -------------------------------- */\nexport const vs = {\n    base: 'vs',\n    inherit: false,\n    rules: [\n        { token: '', foreground: '000000', background: 'fffffe' },\n        { token: 'invalid', foreground: 'cd3131' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '001188' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'constant', foreground: 'dd0000' },\n        { token: 'comment', foreground: '008000' },\n        { token: 'number', foreground: '098658' },\n        { token: 'number.hex', foreground: '3030c0' },\n        { token: 'regexp', foreground: '800000' },\n        { token: 'annotation', foreground: '808080' },\n        { token: 'type', foreground: '008080' },\n        { token: 'delimiter', foreground: '000000' },\n        { token: 'delimiter.html', foreground: '383838' },\n        { token: 'delimiter.xml', foreground: '0000FF' },\n        { token: 'tag', foreground: '800000' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: '800000' },\n        { token: 'metatag', foreground: 'e00000' },\n        { token: 'metatag.content.html', foreground: 'FF0000' },\n        { token: 'metatag.html', foreground: '808080' },\n        { token: 'metatag.xml', foreground: '808080' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '863B00' },\n        { token: 'string.key.json', foreground: 'A31515' },\n        { token: 'string.value.json', foreground: '0451A5' },\n        { token: 'attribute.name', foreground: 'FF0000' },\n        { token: 'attribute.value', foreground: '0451A5' },\n        { token: 'attribute.value.number', foreground: '098658' },\n        { token: 'attribute.value.unit', foreground: '098658' },\n        { token: 'attribute.value.html', foreground: '0000FF' },\n        { token: 'attribute.value.xml', foreground: '0000FF' },\n        { token: 'string', foreground: 'A31515' },\n        { token: 'string.html', foreground: '0000FF' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'string.yaml', foreground: '0451A5' },\n        { token: 'keyword', foreground: '0000FF' },\n        { token: 'keyword.json', foreground: '0451A5' },\n        { token: 'keyword.flow', foreground: 'AF00DB' },\n        { token: 'keyword.flow.scss', foreground: '0000FF' },\n        { token: 'operator.scss', foreground: '666666' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '666666' },\n        { token: 'predefined.sql', foreground: 'C700C7' },\n    ],\n    colors: {\n        [editorBackground]: '#FFFFFE',\n        [editorForeground]: '#000000',\n        [editorInactiveSelection]: '#E5EBF1',\n        [editorIndentGuides]: '#D3D3D3',\n        [editorActiveIndentGuides]: '#939393',\n        [editorSelectionHighlight]: '#ADD6FF4D'\n    }\n};\n/* -------------------------------- End vs theme -------------------------------- */\n/* -------------------------------- Begin vs-dark theme -------------------------------- */\nexport const vs_dark = {\n    base: 'vs-dark',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'D4D4D4', background: '1E1E1E' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '74B0DF' },\n        { token: 'variable.predefined', foreground: '4864AA' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'B5CEA8' },\n        { token: 'number.hex', foreground: '5BB498' },\n        { token: 'regexp', foreground: 'B46695' },\n        { token: 'annotation', foreground: 'cc6666' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'DCDCDC' },\n        { token: 'delimiter.html', foreground: '808080' },\n        { token: 'delimiter.xml', foreground: '808080' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta.scss', foreground: 'A79873' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: 'DD6A6F' },\n        { token: 'metatag.content.html', foreground: '9CDCFE' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key.json', foreground: '9CDCFE' },\n        { token: 'string.value.json', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '9CDCFE' },\n        { token: 'attribute.value', foreground: 'CE9178' },\n        { token: 'attribute.value.number.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.unit.css', foreground: 'B5CEA8' },\n        { token: 'attribute.value.hex.css', foreground: 'D4D4D4' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'keyword.json', foreground: 'CE9178' },\n        { token: 'keyword.flow.scss', foreground: '569CD6' },\n        { token: 'operator.scss', foreground: '909090' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#1E1E1E',\n        [editorForeground]: '#D4D4D4',\n        [editorInactiveSelection]: '#3A3D41',\n        [editorIndentGuides]: '#404040',\n        [editorActiveIndentGuides]: '#707070',\n        [editorSelectionHighlight]: '#ADD6FF26'\n    }\n};\n/* -------------------------------- End vs-dark theme -------------------------------- */\n/* -------------------------------- Begin hc-black theme -------------------------------- */\nexport const hc_black = {\n    base: 'hc-black',\n    inherit: false,\n    rules: [\n        { token: '', foreground: 'FFFFFF', background: '000000' },\n        { token: 'invalid', foreground: 'f44747' },\n        { token: 'emphasis', fontStyle: 'italic' },\n        { token: 'strong', fontStyle: 'bold' },\n        { token: 'variable', foreground: '1AEBFF' },\n        { token: 'variable.parameter', foreground: '9CDCFE' },\n        { token: 'constant', foreground: '569CD6' },\n        { token: 'comment', foreground: '608B4E' },\n        { token: 'number', foreground: 'FFFFFF' },\n        { token: 'regexp', foreground: 'C0C0C0' },\n        { token: 'annotation', foreground: '569CD6' },\n        { token: 'type', foreground: '3DC9B0' },\n        { token: 'delimiter', foreground: 'FFFF00' },\n        { token: 'delimiter.html', foreground: 'FFFF00' },\n        { token: 'tag', foreground: '569CD6' },\n        { token: 'tag.id.pug', foreground: '4F76AC' },\n        { token: 'tag.class.pug', foreground: '4F76AC' },\n        { token: 'meta', foreground: 'D4D4D4' },\n        { token: 'meta.tag', foreground: 'CE9178' },\n        { token: 'metatag', foreground: '569CD6' },\n        { token: 'metatag.content.html', foreground: '1AEBFF' },\n        { token: 'metatag.html', foreground: '569CD6' },\n        { token: 'metatag.xml', foreground: '569CD6' },\n        { token: 'metatag.php', fontStyle: 'bold' },\n        { token: 'key', foreground: '9CDCFE' },\n        { token: 'string.key', foreground: '9CDCFE' },\n        { token: 'string.value', foreground: 'CE9178' },\n        { token: 'attribute.name', foreground: '569CD6' },\n        { token: 'attribute.value', foreground: '3FF23F' },\n        { token: 'string', foreground: 'CE9178' },\n        { token: 'string.sql', foreground: 'FF0000' },\n        { token: 'keyword', foreground: '569CD6' },\n        { token: 'keyword.flow', foreground: 'C586C0' },\n        { token: 'operator.sql', foreground: '778899' },\n        { token: 'operator.swift', foreground: '909090' },\n        { token: 'predefined.sql', foreground: 'FF00FF' },\n    ],\n    colors: {\n        [editorBackground]: '#000000',\n        [editorForeground]: '#FFFFFF',\n        [editorIndentGuides]: '#FFFFFF',\n        [editorActiveIndentGuides]: '#FFFFFF',\n    }\n};\n/* -------------------------------- End hc-black theme -------------------------------- */\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asCSSPropertyValue, asCSSUrl } from '../../../base/browser/dom.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { getIconRegistry } from '../common/iconRegistry.js';\nimport { ThemeIcon } from '../common/themeService.js';\nexport function getIconsStyleSheet(themeService) {\n    const onDidChangeEmmiter = new Emitter();\n    const iconRegistry = getIconRegistry();\n    iconRegistry.onDidChange(() => onDidChangeEmmiter.fire());\n    themeService === null || themeService === void 0 ? void 0 : themeService.onDidProductIconThemeChange(() => onDidChangeEmmiter.fire());\n    return {\n        onDidChange: onDidChangeEmmiter.event,\n        getCSS() {\n            const productIconTheme = themeService ? themeService.getProductIconTheme() : new UnthemedProductIconTheme();\n            const usedFontIds = {};\n            const formatIconRule = (contribution) => {\n                const definition = productIconTheme.getIcon(contribution);\n                if (!definition) {\n                    return undefined;\n                }\n                const fontContribution = definition.font;\n                if (fontContribution) {\n                    usedFontIds[fontContribution.id] = fontContribution.definition;\n                    return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontContribution.id)}; }`;\n                }\n                // default font (codicon)\n                return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`;\n            };\n            const rules = [];\n            for (let contribution of iconRegistry.getIcons()) {\n                const rule = formatIconRule(contribution);\n                if (rule) {\n                    rules.push(rule);\n                }\n            }\n            for (let id in usedFontIds) {\n                const definition = usedFontIds[id];\n                const fontWeight = definition.weight ? `font-weight: ${definition.weight};` : '';\n                const fontStyle = definition.style ? `font-style: ${definition.style};` : '';\n                const src = definition.src.map(l => `${asCSSUrl(l.location)} format('${l.format}')`).join(', ');\n                rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)};${fontWeight}${fontStyle} font-display: block; }`);\n            }\n            return rules.join('\\n');\n        }\n    };\n}\nexport class UnthemedProductIconTheme {\n    getIcon(contribution) {\n        const iconRegistry = getIconRegistry();\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../base/browser/dom.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { TokenizationRegistry, TokenMetadata } from '../../common/languages.js';\nimport { TokenTheme, generateTokensCSSForColorMap } from '../../common/languages/supports/tokenization.js';\nimport { hc_black, vs, vs_dark } from '../common/themes.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { asCssVariableName, Extensions } from '../../../platform/theme/common/colorRegistry.js';\nimport { Extensions as ThemingExtensions } from '../../../platform/theme/common/themeService.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ColorScheme } from '../../../platform/theme/common/theme.js';\nimport { getIconsStyleSheet, UnthemedProductIconTheme } from '../../../platform/theme/browser/iconsStyleSheet.js';\nconst VS_THEME_NAME = 'vs';\nconst VS_DARK_THEME_NAME = 'vs-dark';\nconst HC_BLACK_THEME_NAME = 'hc-black';\nconst colorRegistry = Registry.as(Extensions.ColorContribution);\nconst themingRegistry = Registry.as(ThemingExtensions.ThemingContribution);\nclass StandaloneTheme {\n    constructor(name, standaloneThemeData) {\n        this.semanticHighlighting = false;\n        this.themeData = standaloneThemeData;\n        const base = standaloneThemeData.base;\n        if (name.length > 0) {\n            if (isBuiltinTheme(name)) {\n                this.id = name;\n            }\n            else {\n                this.id = base + ' ' + name;\n            }\n            this.themeName = name;\n        }\n        else {\n            this.id = base;\n            this.themeName = base;\n        }\n        this.colors = null;\n        this.defaultColors = Object.create(null);\n        this._tokenTheme = null;\n    }\n    get base() {\n        return this.themeData.base;\n    }\n    notifyBaseUpdated() {\n        if (this.themeData.inherit) {\n            this.colors = null;\n            this._tokenTheme = null;\n        }\n    }\n    getColors() {\n        if (!this.colors) {\n            const colors = new Map();\n            for (let id in this.themeData.colors) {\n                colors.set(id, Color.fromHex(this.themeData.colors[id]));\n            }\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                for (let id in baseData.colors) {\n                    if (!colors.has(id)) {\n                        colors.set(id, Color.fromHex(baseData.colors[id]));\n                    }\n                }\n            }\n            this.colors = colors;\n        }\n        return this.colors;\n    }\n    getColor(colorId, useDefault) {\n        const color = this.getColors().get(colorId);\n        if (color) {\n            return color;\n        }\n        if (useDefault !== false) {\n            return this.getDefault(colorId);\n        }\n        return undefined;\n    }\n    getDefault(colorId) {\n        let color = this.defaultColors[colorId];\n        if (color) {\n            return color;\n        }\n        color = colorRegistry.resolveDefaultColor(colorId, this);\n        this.defaultColors[colorId] = color;\n        return color;\n    }\n    defines(colorId) {\n        return Object.prototype.hasOwnProperty.call(this.getColors(), colorId);\n    }\n    get type() {\n        switch (this.base) {\n            case VS_THEME_NAME: return ColorScheme.LIGHT;\n            case HC_BLACK_THEME_NAME: return ColorScheme.HIGH_CONTRAST;\n            default: return ColorScheme.DARK;\n        }\n    }\n    get tokenTheme() {\n        if (!this._tokenTheme) {\n            let rules = [];\n            let encodedTokensColors = [];\n            if (this.themeData.inherit) {\n                const baseData = getBuiltinRules(this.themeData.base);\n                rules = baseData.rules;\n                if (baseData.encodedTokensColors) {\n                    encodedTokensColors = baseData.encodedTokensColors;\n                }\n            }\n            // Pick up default colors from `editor.foreground` and `editor.background` if available\n            const editorForeground = this.themeData.colors['editor.foreground'];\n            const editorBackground = this.themeData.colors['editor.background'];\n            if (editorForeground || editorBackground) {\n                const rule = { token: '' };\n                if (editorForeground) {\n                    rule.foreground = editorForeground;\n                }\n                if (editorBackground) {\n                    rule.background = editorBackground;\n                }\n                rules.push(rule);\n            }\n            rules = rules.concat(this.themeData.rules);\n            if (this.themeData.encodedTokensColors) {\n                encodedTokensColors = this.themeData.encodedTokensColors;\n            }\n            this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);\n        }\n        return this._tokenTheme;\n    }\n    getTokenStyleMetadata(type, modifiers, modelLanguage) {\n        // use theme rules match\n        const style = this.tokenTheme._match([type].concat(modifiers).join('.'));\n        const metadata = style.metadata;\n        const foreground = TokenMetadata.getForeground(metadata);\n        const fontStyle = TokenMetadata.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* Italic */),\n            bold: Boolean(fontStyle & 2 /* Bold */),\n            underline: Boolean(fontStyle & 4 /* Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* Strikethrough */)\n        };\n    }\n}\nfunction isBuiltinTheme(themeName) {\n    return (themeName === VS_THEME_NAME\n        || themeName === VS_DARK_THEME_NAME\n        || themeName === HC_BLACK_THEME_NAME);\n}\nfunction getBuiltinRules(builtinTheme) {\n    switch (builtinTheme) {\n        case VS_THEME_NAME:\n            return vs;\n        case VS_DARK_THEME_NAME:\n            return vs_dark;\n        case HC_BLACK_THEME_NAME:\n            return hc_black;\n    }\n}\nfunction newBuiltInTheme(builtinTheme) {\n    const themeData = getBuiltinRules(builtinTheme);\n    return new StandaloneTheme(builtinTheme, themeData);\n}\nexport class StandaloneThemeService extends Disposable {\n    constructor() {\n        super();\n        this._onColorThemeChange = this._register(new Emitter());\n        this.onDidColorThemeChange = this._onColorThemeChange.event;\n        this._onProductIconThemeChange = this._register(new Emitter());\n        this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;\n        this._environment = Object.create(null);\n        this._builtInProductIconTheme = new UnthemedProductIconTheme();\n        this._autoDetectHighContrast = true;\n        this._knownThemes = new Map();\n        this._knownThemes.set(VS_THEME_NAME, newBuiltInTheme(VS_THEME_NAME));\n        this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));\n        this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));\n        const iconsStyleSheet = getIconsStyleSheet(this);\n        this._codiconCSS = iconsStyleSheet.getCSS();\n        this._themeCSS = '';\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._globalStyleElement = null;\n        this._styleElements = [];\n        this._colorMapOverride = null;\n        this.setTheme(VS_THEME_NAME);\n        iconsStyleSheet.onDidChange(() => {\n            this._codiconCSS = iconsStyleSheet.getCSS();\n            this._updateCSS();\n        });\n        dom.addMatchMediaChangeListener('(forced-colors: active)', () => {\n            this._updateActualTheme();\n        });\n    }\n    registerEditorContainer(domNode) {\n        if (dom.isInShadowDOM(domNode)) {\n            return this._registerShadowDomContainer(domNode);\n        }\n        return this._registerRegularEditorContainer();\n    }\n    _registerRegularEditorContainer() {\n        if (!this._globalStyleElement) {\n            this._globalStyleElement = dom.createStyleSheet();\n            this._globalStyleElement.className = 'monaco-colors';\n            this._globalStyleElement.textContent = this._allCSS;\n            this._styleElements.push(this._globalStyleElement);\n        }\n        return Disposable.None;\n    }\n    _registerShadowDomContainer(domNode) {\n        const styleElement = dom.createStyleSheet(domNode);\n        styleElement.className = 'monaco-colors';\n        styleElement.textContent = this._allCSS;\n        this._styleElements.push(styleElement);\n        return {\n            dispose: () => {\n                for (let i = 0; i < this._styleElements.length; i++) {\n                    if (this._styleElements[i] === styleElement) {\n                        this._styleElements.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    defineTheme(themeName, themeData) {\n        if (!/^[a-z0-9\\-]+$/i.test(themeName)) {\n            throw new Error('Illegal theme name!');\n        }\n        if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {\n            throw new Error('Illegal theme base!');\n        }\n        // set or replace theme\n        this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));\n        if (isBuiltinTheme(themeName)) {\n            this._knownThemes.forEach(theme => {\n                if (theme.base === themeName) {\n                    theme.notifyBaseUpdated();\n                }\n            });\n        }\n        if (this._theme.themeName === themeName) {\n            this.setTheme(themeName); // refresh theme\n        }\n    }\n    getColorTheme() {\n        return this._theme;\n    }\n    setColorMapOverride(colorMapOverride) {\n        this._colorMapOverride = colorMapOverride;\n        this._updateThemeOrColorMap();\n    }\n    setTheme(themeName) {\n        let theme;\n        if (this._knownThemes.has(themeName)) {\n            theme = this._knownThemes.get(themeName);\n        }\n        else {\n            theme = this._knownThemes.get(VS_THEME_NAME);\n        }\n        this._desiredTheme = theme;\n        this._updateActualTheme();\n    }\n    _updateActualTheme() {\n        const theme = (this._autoDetectHighContrast && window.matchMedia(`(forced-colors: active)`).matches\n            ? this._knownThemes.get(HC_BLACK_THEME_NAME)\n            : this._desiredTheme);\n        if (this._theme === theme) {\n            // Nothing to do\n            return;\n        }\n        this._theme = theme;\n        this._updateThemeOrColorMap();\n    }\n    setAutoDetectHighContrast(autoDetectHighContrast) {\n        this._autoDetectHighContrast = autoDetectHighContrast;\n        this._updateActualTheme();\n    }\n    _updateThemeOrColorMap() {\n        const cssRules = [];\n        const hasRule = {};\n        const ruleCollector = {\n            addRule: (rule) => {\n                if (!hasRule[rule]) {\n                    cssRules.push(rule);\n                    hasRule[rule] = true;\n                }\n            }\n        };\n        themingRegistry.getThemingParticipants().forEach(p => p(this._theme, ruleCollector, this._environment));\n        const colorVariables = [];\n        for (const item of colorRegistry.getColors()) {\n            const color = this._theme.getColor(item.id, true);\n            if (color) {\n                colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);\n            }\n        }\n        ruleCollector.addRule(`.monaco-editor { ${colorVariables.join('\\n')} }`);\n        const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();\n        ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));\n        this._themeCSS = cssRules.join('\\n');\n        this._updateCSS();\n        TokenizationRegistry.setColorMap(colorMap);\n        this._onColorThemeChange.fire(this._theme);\n    }\n    _updateCSS() {\n        this._allCSS = `${this._codiconCSS}\\n${this._themeCSS}`;\n        this._styleElements.forEach(styleElement => styleElement.textContent = this._allCSS);\n    }\n    getFileIconTheme() {\n        return {\n            hasFileIcons: false,\n            hasFolderIcons: false,\n            hidesExplorerArrows: false\n        };\n    }\n    getProductIconTheme() {\n        return this._builtInProductIconTheme;\n    }\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from '../common/accessibility.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nlet AccessibilityService = class AccessibilityService extends Disposable {\n    constructor(_contextKeyService, _configurationService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._configurationService = _configurationService;\n        this._accessibilitySupport = 0 /* Unknown */;\n        this._onDidChangeScreenReaderOptimized = new Emitter();\n        this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);\n        const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());\n        this._register(this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.accessibilitySupport')) {\n                updateContextKey();\n                this._onDidChangeScreenReaderOptimized.fire();\n            }\n        }));\n        updateContextKey();\n        this.onDidChangeScreenReaderOptimized(() => updateContextKey());\n    }\n    get onDidChangeScreenReaderOptimized() {\n        return this._onDidChangeScreenReaderOptimized.event;\n    }\n    isScreenReaderOptimized() {\n        const config = this._configurationService.getValue('editor.accessibilitySupport');\n        return config === 'on' || (config === 'auto' && this._accessibilitySupport === 2 /* Enabled */);\n    }\n    getAccessibilitySupport() {\n        return this._accessibilitySupport;\n    }\n};\nAccessibilityService = __decorate([\n    __param(0, IContextKeyService),\n    __param(1, IConfigurationService)\n], AccessibilityService);\nexport { AccessibilityService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { IMenuService, isIMenuItem, MenuItemAction, MenuRegistry, SubmenuItemAction } from './actions.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nlet MenuService = class MenuService {\n    constructor(_commandService) {\n        this._commandService = _commandService;\n        //\n    }\n    /**\n     * Create a new menu for the given menu identifier. A menu sends events when it's entries\n     * have changed (placement, enablement, checked-state). By default it does send events for\n     * sub menu entries. That is more expensive and must be explicitly enabled with the\n     * `emitEventsForSubmenuChanges` flag.\n     */\n    createMenu(id, contextKeyService, options) {\n        return new Menu(id, Object.assign({ emitEventsForSubmenuChanges: false, eventDebounceDelay: 50 }, options), this._commandService, contextKeyService, this);\n    }\n};\nMenuService = __decorate([\n    __param(0, ICommandService)\n], MenuService);\nexport { MenuService };\nlet Menu = class Menu {\n    constructor(_id, _options, _commandService, _contextKeyService, _menuService) {\n        this._id = _id;\n        this._options = _options;\n        this._commandService = _commandService;\n        this._contextKeyService = _contextKeyService;\n        this._menuService = _menuService;\n        this._disposables = new DisposableStore();\n        this._menuGroups = [];\n        this._contextKeys = new Set();\n        this._build();\n        // Rebuild this menu whenever the menu registry reports an event for this MenuId.\n        // This usually happen while code and extensions are loaded and affects the over\n        // structure of the menu\n        const rebuildMenuSoon = new RunOnceScheduler(() => {\n            this._build();\n            this._onDidChange.fire(this);\n        }, _options.eventDebounceDelay);\n        this._disposables.add(rebuildMenuSoon);\n        this._disposables.add(MenuRegistry.onDidChangeMenu(e => {\n            if (e.has(_id)) {\n                rebuildMenuSoon.schedule();\n            }\n        }));\n        // When context keys change we need to check if the menu also has changed. However,\n        // we only do that when someone listens on this menu because (1) context key events are\n        // firing often and (2) menu are often leaked\n        const contextKeyListener = this._disposables.add(new DisposableStore());\n        const startContextKeyListener = () => {\n            const fireChangeSoon = new RunOnceScheduler(() => this._onDidChange.fire(this), _options.eventDebounceDelay);\n            contextKeyListener.add(fireChangeSoon);\n            contextKeyListener.add(_contextKeyService.onDidChangeContext(e => {\n                if (e.affectsSome(this._contextKeys)) {\n                    fireChangeSoon.schedule();\n                }\n            }));\n        };\n        this._onDidChange = new Emitter({\n            // start/stop context key listener\n            onFirstListenerAdd: startContextKeyListener,\n            onLastListenerRemove: contextKeyListener.clear.bind(contextKeyListener)\n        });\n        this.onDidChange = this._onDidChange.event;\n    }\n    dispose() {\n        this._disposables.dispose();\n        this._onDidChange.dispose();\n    }\n    _build() {\n        // reset\n        this._menuGroups.length = 0;\n        this._contextKeys.clear();\n        const menuItems = MenuRegistry.getMenuItems(this._id);\n        let group;\n        menuItems.sort(Menu._compareMenuItems);\n        for (const item of menuItems) {\n            // group by groupId\n            const groupName = item.group || '';\n            if (!group || group[0] !== groupName) {\n                group = [groupName, []];\n                this._menuGroups.push(group);\n            }\n            group[1].push(item);\n            // keep keys for eventing\n            this._collectContextKeys(item);\n        }\n    }\n    _collectContextKeys(item) {\n        Menu._fillInKbExprKeys(item.when, this._contextKeys);\n        if (isIMenuItem(item)) {\n            // keep precondition keys for event if applicable\n            if (item.command.precondition) {\n                Menu._fillInKbExprKeys(item.command.precondition, this._contextKeys);\n            }\n            // keep toggled keys for event if applicable\n            if (item.command.toggled) {\n                const toggledExpression = item.command.toggled.condition || item.command.toggled;\n                Menu._fillInKbExprKeys(toggledExpression, this._contextKeys);\n            }\n        }\n        else if (this._options.emitEventsForSubmenuChanges) {\n            // recursively collect context keys from submenus so that this\n            // menu fires events when context key changes affect submenus\n            MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);\n        }\n    }\n    getActions(options) {\n        const result = [];\n        for (let group of this._menuGroups) {\n            const [id, items] = group;\n            const activeActions = [];\n            for (const item of items) {\n                if (this._contextKeyService.contextMatchesRules(item.when)) {\n                    const action = isIMenuItem(item)\n                        ? new MenuItemAction(item.command, item.alt, options, this._contextKeyService, this._commandService)\n                        : new SubmenuItemAction(item, this._menuService, this._contextKeyService, options);\n                    activeActions.push(action);\n                }\n            }\n            if (activeActions.length > 0) {\n                result.push([id, activeActions]);\n            }\n        }\n        return result;\n    }\n    static _fillInKbExprKeys(exp, set) {\n        if (exp) {\n            for (let key of exp.keys()) {\n                set.add(key);\n            }\n        }\n    }\n    static _compareMenuItems(a, b) {\n        let aGroup = a.group;\n        let bGroup = b.group;\n        if (aGroup !== bGroup) {\n            // Falsy groups come last\n            if (!aGroup) {\n                return 1;\n            }\n            else if (!bGroup) {\n                return -1;\n            }\n            // 'navigation' group comes first\n            if (aGroup === 'navigation') {\n                return -1;\n            }\n            else if (bGroup === 'navigation') {\n                return 1;\n            }\n            // lexical sort for groups\n            let value = aGroup.localeCompare(bGroup);\n            if (value !== 0) {\n                return value;\n            }\n        }\n        // sort on priority - default is 0\n        let aPrio = a.order || 0;\n        let bPrio = b.order || 0;\n        if (aPrio < bPrio) {\n            return -1;\n        }\n        else if (aPrio > bPrio) {\n            return 1;\n        }\n        // sort on titles\n        return Menu._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);\n    }\n    static _compareTitles(a, b) {\n        const aStr = typeof a === 'string' ? a : a.original;\n        const bStr = typeof b === 'string' ? b : b.original;\n        return aStr.localeCompare(bStr);\n    }\n};\nMenu = __decorate([\n    __param(2, ICommandService),\n    __param(3, IContextKeyService),\n    __param(4, IMenuService)\n], Menu);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener } from '../../../base/browser/dom.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\nlet BrowserClipboardService = class BrowserClipboardService extends Disposable {\n    constructor(layoutService, logService) {\n        super();\n        this.layoutService = layoutService;\n        this.logService = logService;\n        this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n        this.findText = ''; // unsupported in web (only in-memory)\n        if (isSafari || isWebkitWebView) {\n            this.installWebKitWriteTextWorkaround();\n        }\n    }\n    // In Safari, it has the following note:\n    //\n    // \"The request to write to the clipboard must be triggered during a user gesture.\n    // A call to clipboard.write or clipboard.writeText outside the scope of a user\n    // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n    // rejection of the promise returned by the API call.\"\n    // From: https://webkit.org/blog/10855/async-clipboard-api/\n    //\n    // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n    // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n    //\n    // This function sets up some handlers to work around that behavior.\n    installWebKitWriteTextWorkaround() {\n        const handler = () => {\n            const currentWritePromise = new DeferredPromise();\n            // Cancel the previous promise since we just created a new one in response to this new event\n            if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n                this.webKitPendingClipboardWritePromise.cancel();\n            }\n            this.webKitPendingClipboardWritePromise = currentWritePromise;\n            // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n            // This allows us to pass in a Promise that will either be cancelled by another event or\n            // resolved with the contents of the first call to this.writeText.\n            // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n            navigator.clipboard.write([new ClipboardItem({\n                    'text/plain': currentWritePromise.p,\n                })]).catch((err) => __awaiter(this, void 0, void 0, function* () {\n                if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n                    this.logService.error(err);\n                }\n            }));\n        };\n        if (this.layoutService.hasContainer) {\n            this._register(addDisposableListener(this.layoutService.container, 'click', handler));\n            this._register(addDisposableListener(this.layoutService.container, 'keydown', handler));\n        }\n    }\n    writeText(text, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // With type: only in-memory is supported\n            if (type) {\n                this.mapTextToType.set(type, text);\n                return;\n            }\n            if (this.webKitPendingClipboardWritePromise) {\n                // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n                // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n                // would throw an error because this call stack doesn't appear to originate from a user gesture.\n                return this.webKitPendingClipboardWritePromise.complete(text);\n            }\n            // Guard access to navigator.clipboard with try/catch\n            // as we have seen DOMExceptions in certain browsers\n            // due to security policies.\n            try {\n                return yield navigator.clipboard.writeText(text);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            // Fallback to textarea and execCommand solution\n            const activeElement = document.activeElement;\n            const textArea = document.body.appendChild($('textarea', { 'aria-hidden': true }));\n            textArea.style.height = '1px';\n            textArea.style.width = '1px';\n            textArea.style.position = 'absolute';\n            textArea.value = text;\n            textArea.focus();\n            textArea.select();\n            document.execCommand('copy');\n            if (activeElement instanceof HTMLElement) {\n                activeElement.focus();\n            }\n            document.body.removeChild(textArea);\n            return;\n        });\n    }\n    readText(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // With type: only in-memory is supported\n            if (type) {\n                return this.mapTextToType.get(type) || '';\n            }\n            // Guard access to navigator.clipboard with try/catch\n            // as we have seen DOMExceptions in certain browsers\n            // due to security policies.\n            try {\n                return yield navigator.clipboard.readText();\n            }\n            catch (error) {\n                console.error(error);\n                return '';\n            }\n        });\n    }\n    readFindText() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.findText;\n        });\n    }\n    writeFindText(text) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.findText = text;\n        });\n    }\n};\nBrowserClipboardService = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ILogService)\n], BrowserClipboardService);\nexport { BrowserClipboardService };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { PauseableEmitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/map.js';\nimport { localize } from '../../../nls.js';\nimport { CommandsRegistry } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IContextKeyService, RawContextKey, SET_CONTEXT_COMMAND_ID } from '../common/contextkey.js';\nconst KEYBINDING_CONTEXT_ATTR = 'data-keybinding-context';\nexport class Context {\n    constructor(id, parent) {\n        this._id = id;\n        this._parent = parent;\n        this._value = Object.create(null);\n        this._value['_contextId'] = id;\n    }\n    setValue(key, value) {\n        // console.log('SET ' + key + ' = ' + value + ' ON ' + this._id);\n        if (this._value[key] !== value) {\n            this._value[key] = value;\n            return true;\n        }\n        return false;\n    }\n    removeValue(key) {\n        // console.log('REMOVE ' + key + ' FROM ' + this._id);\n        if (key in this._value) {\n            delete this._value[key];\n            return true;\n        }\n        return false;\n    }\n    getValue(key) {\n        const ret = this._value[key];\n        if (typeof ret === 'undefined' && this._parent) {\n            return this._parent.getValue(key);\n        }\n        return ret;\n    }\n}\nclass NullContext extends Context {\n    constructor() {\n        super(-1, null);\n    }\n    setValue(key, value) {\n        return false;\n    }\n    removeValue(key) {\n        return false;\n    }\n    getValue(key) {\n        return undefined;\n    }\n}\nNullContext.INSTANCE = new NullContext();\nclass ConfigAwareContextValuesContainer extends Context {\n    constructor(id, _configurationService, emitter) {\n        super(id, null);\n        this._configurationService = _configurationService;\n        this._values = TernarySearchTree.forConfigKeys();\n        this._listener = this._configurationService.onDidChangeConfiguration(event => {\n            if (event.source === 6 /* DEFAULT */) {\n                // new setting, reset everything\n                const allKeys = Array.from(Iterable.map(this._values, ([k]) => k));\n                this._values.clear();\n                emitter.fire(new ArrayContextKeyChangeEvent(allKeys));\n            }\n            else {\n                const changedKeys = [];\n                for (const configKey of event.affectedKeys) {\n                    const contextKey = `config.${configKey}`;\n                    const cachedItems = this._values.findSuperstr(contextKey);\n                    if (cachedItems !== undefined) {\n                        changedKeys.push(...Iterable.map(cachedItems, ([key]) => key));\n                        this._values.deleteSuperstr(contextKey);\n                    }\n                    if (this._values.has(contextKey)) {\n                        changedKeys.push(contextKey);\n                        this._values.delete(contextKey);\n                    }\n                }\n                emitter.fire(new ArrayContextKeyChangeEvent(changedKeys));\n            }\n        });\n    }\n    dispose() {\n        this._listener.dispose();\n    }\n    getValue(key) {\n        if (key.indexOf(ConfigAwareContextValuesContainer._keyPrefix) !== 0) {\n            return super.getValue(key);\n        }\n        if (this._values.has(key)) {\n            return this._values.get(key);\n        }\n        const configKey = key.substr(ConfigAwareContextValuesContainer._keyPrefix.length);\n        const configValue = this._configurationService.getValue(configKey);\n        let value = undefined;\n        switch (typeof configValue) {\n            case 'number':\n            case 'boolean':\n            case 'string':\n                value = configValue;\n                break;\n            default:\n                if (Array.isArray(configValue)) {\n                    value = JSON.stringify(configValue);\n                }\n                else {\n                    value = configValue;\n                }\n        }\n        this._values.set(key, value);\n        return value;\n    }\n    setValue(key, value) {\n        return super.setValue(key, value);\n    }\n    removeValue(key) {\n        return super.removeValue(key);\n    }\n}\nConfigAwareContextValuesContainer._keyPrefix = 'config.';\nclass ContextKey {\n    constructor(service, key, defaultValue) {\n        this._service = service;\n        this._key = key;\n        this._defaultValue = defaultValue;\n        this.reset();\n    }\n    set(value) {\n        this._service.setContext(this._key, value);\n    }\n    reset() {\n        if (typeof this._defaultValue === 'undefined') {\n            this._service.removeContext(this._key);\n        }\n        else {\n            this._service.setContext(this._key, this._defaultValue);\n        }\n    }\n    get() {\n        return this._service.getContextKeyValue(this._key);\n    }\n}\nclass SimpleContextKeyChangeEvent {\n    constructor(key) {\n        this.key = key;\n    }\n    affectsSome(keys) {\n        return keys.has(this.key);\n    }\n}\nclass ArrayContextKeyChangeEvent {\n    constructor(keys) {\n        this.keys = keys;\n    }\n    affectsSome(keys) {\n        for (const key of this.keys) {\n            if (keys.has(key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nclass CompositeContextKeyChangeEvent {\n    constructor(events) {\n        this.events = events;\n    }\n    affectsSome(keys) {\n        for (const e of this.events) {\n            if (e.affectsSome(keys)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport class AbstractContextKeyService {\n    constructor(myContextId) {\n        this._onDidChangeContext = new PauseableEmitter({ merge: input => new CompositeContextKeyChangeEvent(input) });\n        this.onDidChangeContext = this._onDidChangeContext.event;\n        this._isDisposed = false;\n        this._myContextId = myContextId;\n    }\n    createKey(key, defaultValue) {\n        if (this._isDisposed) {\n            throw new Error(`AbstractContextKeyService has been disposed`);\n        }\n        return new ContextKey(this, key, defaultValue);\n    }\n    bufferChangeEvents(callback) {\n        this._onDidChangeContext.pause();\n        try {\n            callback();\n        }\n        finally {\n            this._onDidChangeContext.resume();\n        }\n    }\n    createScoped(domNode) {\n        if (this._isDisposed) {\n            throw new Error(`AbstractContextKeyService has been disposed`);\n        }\n        return new ScopedContextKeyService(this, domNode);\n    }\n    contextMatchesRules(rules) {\n        if (this._isDisposed) {\n            throw new Error(`AbstractContextKeyService has been disposed`);\n        }\n        const context = this.getContextValuesContainer(this._myContextId);\n        const result = (rules ? rules.evaluate(context) : true);\n        // console.group(rules.serialize() + ' -> ' + result);\n        // rules.keys().forEach(key => { console.log(key, ctx[key]); });\n        // console.groupEnd();\n        return result;\n    }\n    getContextKeyValue(key) {\n        if (this._isDisposed) {\n            return undefined;\n        }\n        return this.getContextValuesContainer(this._myContextId).getValue(key);\n    }\n    setContext(key, value) {\n        if (this._isDisposed) {\n            return;\n        }\n        const myContext = this.getContextValuesContainer(this._myContextId);\n        if (!myContext) {\n            return;\n        }\n        if (myContext.setValue(key, value)) {\n            this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));\n        }\n    }\n    removeContext(key) {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {\n            this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));\n        }\n    }\n    getContext(target) {\n        if (this._isDisposed) {\n            return NullContext.INSTANCE;\n        }\n        return this.getContextValuesContainer(findContextAttr(target));\n    }\n}\nlet ContextKeyService = class ContextKeyService extends AbstractContextKeyService {\n    constructor(configurationService) {\n        super(0);\n        this._contexts = new Map();\n        this._toDispose = new DisposableStore();\n        this._lastContextId = 0;\n        const myContext = new ConfigAwareContextValuesContainer(this._myContextId, configurationService, this._onDidChangeContext);\n        this._contexts.set(this._myContextId, myContext);\n        this._toDispose.add(myContext);\n        // Uncomment this to see the contexts continuously logged\n        // let lastLoggedValue: string | null = null;\n        // setInterval(() => {\n        // \tlet values = Object.keys(this._contexts).map((key) => this._contexts[key]);\n        // \tlet logValue = values.map(v => JSON.stringify(v._value, null, '\\t')).join('\\n');\n        // \tif (lastLoggedValue !== logValue) {\n        // \t\tlastLoggedValue = logValue;\n        // \t\tconsole.log(lastLoggedValue);\n        // \t}\n        // }, 2000);\n    }\n    dispose() {\n        this._onDidChangeContext.dispose();\n        this._isDisposed = true;\n        this._toDispose.dispose();\n    }\n    getContextValuesContainer(contextId) {\n        if (this._isDisposed) {\n            return NullContext.INSTANCE;\n        }\n        return this._contexts.get(contextId) || NullContext.INSTANCE;\n    }\n    createChildContext(parentContextId = this._myContextId) {\n        if (this._isDisposed) {\n            throw new Error(`ContextKeyService has been disposed`);\n        }\n        let id = (++this._lastContextId);\n        this._contexts.set(id, new Context(id, this.getContextValuesContainer(parentContextId)));\n        return id;\n    }\n    disposeContext(contextId) {\n        if (!this._isDisposed) {\n            this._contexts.delete(contextId);\n        }\n    }\n};\nContextKeyService = __decorate([\n    __param(0, IConfigurationService)\n], ContextKeyService);\nexport { ContextKeyService };\nclass ScopedContextKeyService extends AbstractContextKeyService {\n    constructor(parent, domNode) {\n        super(parent.createChildContext());\n        this._parentChangeListener = new MutableDisposable();\n        this._parent = parent;\n        this._updateParentChangeListener();\n        this._domNode = domNode;\n        if (this._domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {\n            let extraInfo = '';\n            if (this._domNode.classList) {\n                extraInfo = Array.from(this._domNode.classList.values()).join(', ');\n            }\n            console.error(`Element already has context attribute${extraInfo ? ': ' + extraInfo : ''}`);\n        }\n        this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));\n    }\n    _updateParentChangeListener() {\n        // Forward parent events to this listener. Parent will change.\n        this._parentChangeListener.value = this._parent.onDidChangeContext(this._onDidChangeContext.fire, this._onDidChangeContext);\n    }\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._onDidChangeContext.dispose();\n        this._parent.disposeContext(this._myContextId);\n        this._parentChangeListener.dispose();\n        this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);\n        this._isDisposed = true;\n    }\n    getContextValuesContainer(contextId) {\n        if (this._isDisposed) {\n            return NullContext.INSTANCE;\n        }\n        return this._parent.getContextValuesContainer(contextId);\n    }\n    createChildContext(parentContextId = this._myContextId) {\n        if (this._isDisposed) {\n            throw new Error(`ScopedContextKeyService has been disposed`);\n        }\n        return this._parent.createChildContext(parentContextId);\n    }\n    disposeContext(contextId) {\n        if (this._isDisposed) {\n            return;\n        }\n        this._parent.disposeContext(contextId);\n    }\n}\nfunction findContextAttr(domNode) {\n    while (domNode) {\n        if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {\n            const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);\n            if (attr) {\n                return parseInt(attr, 10);\n            }\n            return NaN;\n        }\n        domNode = domNode.parentElement;\n    }\n    return 0;\n}\nCommandsRegistry.registerCommand(SET_CONTEXT_COMMAND_ID, function (accessor, contextKey, contextValue) {\n    accessor.get(IContextKeyService).createKey(String(contextKey), contextValue);\n});\nCommandsRegistry.registerCommand({\n    id: 'getContextKeyInfo',\n    handler() {\n        return [...RawContextKey.all()].sort((a, b) => a.key.localeCompare(b.key));\n    },\n    description: {\n        description: localize('getContextKeyInfo', \"A command that returns information about context keys\"),\n        args: []\n    }\n});\nCommandsRegistry.registerCommand('_generateContextKeyInfo', function () {\n    const result = [];\n    const seen = new Set();\n    for (let info of RawContextKey.all()) {\n        if (!seen.has(info.key)) {\n            seen.add(info.key);\n            result.push(info);\n        }\n    }\n    result.sort((a, b) => a.key.localeCompare(b.key));\n    console.log(JSON.stringify(result, undefined, 2));\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Node {\n    constructor(data) {\n        this.incoming = new Map();\n        this.outgoing = new Map();\n        this.data = data;\n    }\n}\nexport class Graph {\n    constructor(_hashFn) {\n        this._hashFn = _hashFn;\n        this._nodes = new Map();\n        // empty\n    }\n    roots() {\n        const ret = [];\n        for (let node of this._nodes.values()) {\n            if (node.outgoing.size === 0) {\n                ret.push(node);\n            }\n        }\n        return ret;\n    }\n    insertEdge(from, to) {\n        const fromNode = this.lookupOrInsertNode(from);\n        const toNode = this.lookupOrInsertNode(to);\n        fromNode.outgoing.set(this._hashFn(to), toNode);\n        toNode.incoming.set(this._hashFn(from), fromNode);\n    }\n    removeNode(data) {\n        const key = this._hashFn(data);\n        this._nodes.delete(key);\n        for (let node of this._nodes.values()) {\n            node.outgoing.delete(key);\n            node.incoming.delete(key);\n        }\n    }\n    lookupOrInsertNode(data) {\n        const key = this._hashFn(data);\n        let node = this._nodes.get(key);\n        if (!node) {\n            node = new Node(data);\n            this._nodes.set(key, node);\n        }\n        return node;\n    }\n    isEmpty() {\n        return this._nodes.size === 0;\n    }\n    toString() {\n        let data = [];\n        for (let [key, value] of this._nodes) {\n            data.push(`${key}, (incoming)[${[...value.incoming.keys()].join(', ')}], (outgoing)[${[...value.outgoing.keys()].join(',')}]`);\n        }\n        return data.join('\\n');\n    }\n    /**\n     * This is brute force and slow and **only** be used\n     * to trouble shoot.\n     */\n    findCycleSlow() {\n        for (let [id, node] of this._nodes) {\n            const seen = new Set([id]);\n            const res = this._findCycle(node, seen);\n            if (res) {\n                return res;\n            }\n        }\n        return undefined;\n    }\n    _findCycle(node, seen) {\n        for (let [id, outgoing] of node.outgoing) {\n            if (seen.has(id)) {\n                return [...seen, id].join(' -> ');\n            }\n            seen.add(id);\n            const value = this._findCycle(outgoing, seen);\n            if (value) {\n                return value;\n            }\n            seen.delete(id);\n        }\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(services = new ServiceCollection(), strict = false, parent) {\n        this._activeInstantiations = new Set();\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(IInstantiationService, this);\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this);\n    }\n    invokeFunction(fn, ...args) {\n        let _trace = Trace.traceInvocation(fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        let serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            let delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return new ctor(...[...args, ...serviceArgs]);\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        let instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        let thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n        if (!_supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    let obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(printWarning);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    static traceInvocation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n    static traceCreation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\n    }\n    branch(id, first) {\n        let child = new Trace(2 /* Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        let dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            let res = [];\n            let prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    let nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        let lines = [\n            `${this.type === 0 /* Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    }\n}\nTrace._None = new class extends Trace {\n    constructor() { super(-1, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isFalsyOrEmpty } from '../../../base/common/arrays.js';\nimport { DebounceEmitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MarkerSeverity } from './markers.js';\nclass DoubleResourceMap {\n    constructor() {\n        this._byResource = new ResourceMap();\n        this._byOwner = new Map();\n    }\n    set(resource, owner, value) {\n        let ownerMap = this._byResource.get(resource);\n        if (!ownerMap) {\n            ownerMap = new Map();\n            this._byResource.set(resource, ownerMap);\n        }\n        ownerMap.set(owner, value);\n        let resourceMap = this._byOwner.get(owner);\n        if (!resourceMap) {\n            resourceMap = new ResourceMap();\n            this._byOwner.set(owner, resourceMap);\n        }\n        resourceMap.set(resource, value);\n    }\n    get(resource, owner) {\n        let ownerMap = this._byResource.get(resource);\n        return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);\n    }\n    delete(resource, owner) {\n        let removedA = false;\n        let removedB = false;\n        let ownerMap = this._byResource.get(resource);\n        if (ownerMap) {\n            removedA = ownerMap.delete(owner);\n        }\n        let resourceMap = this._byOwner.get(owner);\n        if (resourceMap) {\n            removedB = resourceMap.delete(resource);\n        }\n        if (removedA !== removedB) {\n            throw new Error('illegal state');\n        }\n        return removedA && removedB;\n    }\n    values(key) {\n        var _a, _b, _c, _d;\n        if (typeof key === 'string') {\n            return (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : Iterable.empty();\n        }\n        if (URI.isUri(key)) {\n            return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();\n        }\n        return Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);\n    }\n}\nclass MarkerStats {\n    constructor(service) {\n        this.errors = 0;\n        this.infos = 0;\n        this.warnings = 0;\n        this.unknowns = 0;\n        this._data = new ResourceMap();\n        this._service = service;\n        this._subscription = service.onMarkerChanged(this._update, this);\n    }\n    dispose() {\n        this._subscription.dispose();\n    }\n    _update(resources) {\n        for (const resource of resources) {\n            const oldStats = this._data.get(resource);\n            if (oldStats) {\n                this._substract(oldStats);\n            }\n            const newStats = this._resourceStats(resource);\n            this._add(newStats);\n            this._data.set(resource, newStats);\n        }\n    }\n    _resourceStats(resource) {\n        const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n        // TODO this is a hack\n        if (resource.scheme === Schemas.inMemory || resource.scheme === Schemas.walkThrough || resource.scheme === Schemas.walkThroughSnippet) {\n            return result;\n        }\n        for (const { severity } of this._service.read({ resource })) {\n            if (severity === MarkerSeverity.Error) {\n                result.errors += 1;\n            }\n            else if (severity === MarkerSeverity.Warning) {\n                result.warnings += 1;\n            }\n            else if (severity === MarkerSeverity.Info) {\n                result.infos += 1;\n            }\n            else {\n                result.unknowns += 1;\n            }\n        }\n        return result;\n    }\n    _substract(op) {\n        this.errors -= op.errors;\n        this.warnings -= op.warnings;\n        this.infos -= op.infos;\n        this.unknowns -= op.unknowns;\n    }\n    _add(op) {\n        this.errors += op.errors;\n        this.warnings += op.warnings;\n        this.infos += op.infos;\n        this.unknowns += op.unknowns;\n    }\n}\nexport class MarkerService {\n    constructor() {\n        this._onMarkerChanged = new DebounceEmitter({\n            delay: 0,\n            merge: MarkerService._merge\n        });\n        this.onMarkerChanged = this._onMarkerChanged.event;\n        this._data = new DoubleResourceMap();\n        this._stats = new MarkerStats(this);\n    }\n    dispose() {\n        this._stats.dispose();\n        this._onMarkerChanged.dispose();\n    }\n    remove(owner, resources) {\n        for (const resource of resources || []) {\n            this.changeOne(owner, resource, []);\n        }\n    }\n    changeOne(owner, resource, markerData) {\n        if (isFalsyOrEmpty(markerData)) {\n            // remove marker for this (owner,resource)-tuple\n            const removed = this._data.delete(resource, owner);\n            if (removed) {\n                this._onMarkerChanged.fire([resource]);\n            }\n        }\n        else {\n            // insert marker for this (owner,resource)-tuple\n            const markers = [];\n            for (const data of markerData) {\n                const marker = MarkerService._toMarker(owner, resource, data);\n                if (marker) {\n                    markers.push(marker);\n                }\n            }\n            this._data.set(resource, owner, markers);\n            this._onMarkerChanged.fire([resource]);\n        }\n    }\n    static _toMarker(owner, resource, data) {\n        let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags, } = data;\n        if (!message) {\n            return undefined;\n        }\n        // santize data\n        startLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n        startColumn = startColumn > 0 ? startColumn : 1;\n        endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n        endColumn = endColumn > 0 ? endColumn : startColumn;\n        return {\n            resource,\n            owner,\n            code,\n            severity,\n            message,\n            source,\n            startLineNumber,\n            startColumn,\n            endLineNumber,\n            endColumn,\n            relatedInformation,\n            tags,\n        };\n    }\n    read(filter = Object.create(null)) {\n        let { owner, resource, severities, take } = filter;\n        if (!take || take < 0) {\n            take = -1;\n        }\n        if (owner && resource) {\n            // exactly one owner AND resource\n            const data = this._data.get(resource, owner);\n            if (!data) {\n                return [];\n            }\n            else {\n                const result = [];\n                for (const marker of data) {\n                    if (MarkerService._accept(marker, severities)) {\n                        const newLen = result.push(marker);\n                        if (take > 0 && newLen === take) {\n                            break;\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        else if (!owner && !resource) {\n            // all\n            const result = [];\n            for (let markers of this._data.values()) {\n                for (let data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n        else {\n            // of one resource OR owner\n            const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);\n            const result = [];\n            for (const markers of iterable) {\n                for (const data of markers) {\n                    if (MarkerService._accept(data, severities)) {\n                        const newLen = result.push(data);\n                        if (take > 0 && newLen === take) {\n                            return result;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    static _accept(marker, severities) {\n        return severities === undefined || (severities & marker.severity) === marker.severity;\n    }\n    // --- event debounce logic\n    static _merge(all) {\n        const set = new ResourceMap();\n        for (let array of all) {\n            for (let item of array) {\n                set.set(item, true);\n            }\n        }\n        return Array.from(set.keys());\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookTypeResolver) {\n        this._notebookTypeResolver = _notebookTypeResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (let entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        if (!model) {\n            return;\n        }\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a;\n        const notebookType = (_a = this._notebookTypeResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        const candidate = {\n            uri: model.uri.toString(),\n            language: model.getLanguageId(),\n            notebookType\n        };\n        if (this._lastCandidate\n            && this._lastCandidate.language === candidate.language\n            && this._lastCandidate.uri === candidate.uri\n            && this._lastCandidate.notebookType === candidate.notebookType) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (let entry of this._entries) {\n            entry._score = score(entry.selector, model.uri, model.getLanguageId(), shouldSynchronizeModel(model), notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (let entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        else if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageFeatureRegistry } from '../languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageFeaturesService {\n    constructor() {\n        this.referenceProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.renameProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeActionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.definitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.typeDefinitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.declarationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.implementationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSymbolProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlayHintsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.colorProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeLensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.onTypeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.signatureHelpProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.hoverProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.selectionRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.foldingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n    }\n    _score(uri) {\n        var _a;\n        return (_a = this._notebookTypeResolver) === null || _a === void 0 ? void 0 : _a.call(this, uri);\n    }\n}\nregisterSingleton(ILanguageFeaturesService, LanguageFeaturesService, true);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport '../../common/languages/languageConfigurationRegistry.js';\nimport './standaloneCodeEditorService.js';\nimport './standaloneLayoutService.js';\nimport '../../../platform/undoRedo/common/undoRedoService.js';\nimport '../../common/services/languageFeatureDebounce.js';\nimport * as strings from '../../../base/common/strings.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { SimpleKeybinding, createKeybinding } from '../../../base/common/keybindings.js';\nimport { ImmortalReference, toDisposable, DisposableStore, Disposable } from '../../../base/common/lifecycle.js';\nimport { OS, isLinux, isMacintosh } from '../../../base/common/platform.js';\nimport Severity from '../../../base/common/severity.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IBulkEditService, ResourceTextEdit } from '../../browser/services/bulkEditService.js';\nimport { isDiffEditorConfigurationKey, isEditorConfigurationKey } from '../../common/config/editorConfigurationSchema.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position as Pos } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ITextModelService } from '../../common/services/resolverService.js';\nimport { ITextResourceConfigurationService, ITextResourcePropertiesService } from '../../common/services/textResourceConfiguration.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { Configuration, ConfigurationModel, DefaultConfigurationModel, ConfigurationChangeEvent } from '../../../platform/configuration/common/configurationModels.js';\nimport { IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IDialogService } from '../../../platform/dialogs/common/dialogs.js';\nimport { createDecorator, IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { AbstractKeybindingService } from '../../../platform/keybinding/common/abstractKeybindingService.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { KeybindingResolver } from '../../../platform/keybinding/common/keybindingResolver.js';\nimport { KeybindingsRegistry } from '../../../platform/keybinding/common/keybindingsRegistry.js';\nimport { ResolvedKeybindingItem } from '../../../platform/keybinding/common/resolvedKeybindingItem.js';\nimport { USLayoutResolvedKeybinding } from '../../../platform/keybinding/common/usLayoutResolvedKeybinding.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nimport { INotificationService, NoOpNotification } from '../../../platform/notification/common/notification.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { ITelemetryService } from '../../../platform/telemetry/common/telemetry.js';\nimport { IWorkspaceContextService, WorkspaceFolder } from '../../../platform/workspace/common/workspace.js';\nimport { ILayoutService } from '../../../platform/layout/browser/layoutService.js';\nimport { StandaloneServicesNLS } from '../../common/standaloneStrings.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { ConsoleLogger, ILogService, LogService } from '../../../platform/log/common/log.js';\nimport { IWorkspaceTrustManagementService } from '../../../platform/workspace/common/workspaceTrust.js';\nimport { IContextMenuService, IContextViewService } from '../../../platform/contextview/browser/contextView.js';\nimport { ContextViewService } from '../../../platform/contextview/browser/contextViewService.js';\nimport { LanguageService } from '../../common/services/languageService.js';\nimport { ContextMenuService } from '../../../platform/contextview/browser/contextMenuService.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { getSingletonServiceDescriptors, registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { OpenerService } from '../../browser/services/openerService.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { EditorWorkerService } from '../../browser/services/editorWorkerService.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { MarkerDecorationsService } from '../../common/services/markerDecorationsService.js';\nimport { IMarkerDecorationsService } from '../../common/services/markerDecorations.js';\nimport { ModelService } from '../../common/services/modelService.js';\nimport { StandaloneQuickInputService } from './quickInput/standaloneQuickInputService.js';\nimport { StandaloneThemeService } from './standaloneThemeService.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { AccessibilityService } from '../../../platform/accessibility/browser/accessibilityService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { IMenuService } from '../../../platform/actions/common/actions.js';\nimport { MenuService } from '../../../platform/actions/common/menuService.js';\nimport { BrowserClipboardService } from '../../../platform/clipboard/browser/clipboardService.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { ContextKeyService } from '../../../platform/contextkey/browser/contextKeyService.js';\nimport { SyncDescriptor } from '../../../platform/instantiation/common/descriptors.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IListService, ListService } from '../../../platform/list/browser/listService.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { MarkerService } from '../../../platform/markers/common/markerService.js';\nimport { IOpenerService } from '../../../platform/opener/common/opener.js';\nimport { IQuickInputService } from '../../../platform/quickinput/common/quickInput.js';\nimport { IStorageService, InMemoryStorageService } from '../../../platform/storage/common/storage.js';\nimport '../../common/services/languageFeaturesService.js';\nclass SimpleModel {\n    constructor(model) {\n        this.disposed = false;\n        this.model = model;\n        this._onWillDispose = new Emitter();\n    }\n    get textEditorModel() {\n        return this.model;\n    }\n    dispose() {\n        this.disposed = true;\n        this._onWillDispose.fire();\n    }\n}\nlet StandaloneTextModelService = class StandaloneTextModelService {\n    constructor(modelService) {\n        this.modelService = modelService;\n    }\n    createModelReference(resource) {\n        const model = this.modelService.getModel(resource);\n        if (!model) {\n            return Promise.reject(new Error(`Model not found`));\n        }\n        return Promise.resolve(new ImmortalReference(new SimpleModel(model)));\n    }\n};\nStandaloneTextModelService = __decorate([\n    __param(0, IModelService)\n], StandaloneTextModelService);\nclass StandaloneEditorProgressService {\n    show() {\n        return StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;\n    }\n    showWhile(promise, delay) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield promise;\n        });\n    }\n}\nStandaloneEditorProgressService.NULL_PROGRESS_RUNNER = {\n    done: () => { },\n    total: () => { },\n    worked: () => { }\n};\nclass StandaloneDialogService {\n    confirm(confirmation) {\n        return this.doConfirm(confirmation).then(confirmed => {\n            return {\n                confirmed,\n                checkboxChecked: false // unsupported\n            };\n        });\n    }\n    doConfirm(confirmation) {\n        let messageText = confirmation.message;\n        if (confirmation.detail) {\n            messageText = messageText + '\\n\\n' + confirmation.detail;\n        }\n        return Promise.resolve(window.confirm(messageText));\n    }\n    show(severity, message, buttons, options) {\n        return Promise.resolve({ choice: 0 });\n    }\n}\nexport class StandaloneNotificationService {\n    info(message) {\n        return this.notify({ severity: Severity.Info, message });\n    }\n    warn(message) {\n        return this.notify({ severity: Severity.Warning, message });\n    }\n    error(error) {\n        return this.notify({ severity: Severity.Error, message: error });\n    }\n    notify(notification) {\n        switch (notification.severity) {\n            case Severity.Error:\n                console.error(notification.message);\n                break;\n            case Severity.Warning:\n                console.warn(notification.message);\n                break;\n            default:\n                console.log(notification.message);\n                break;\n        }\n        return StandaloneNotificationService.NO_OP;\n    }\n    status(message, options) {\n        return Disposable.None;\n    }\n}\nStandaloneNotificationService.NO_OP = new NoOpNotification();\nlet StandaloneCommandService = class StandaloneCommandService {\n    constructor(instantiationService) {\n        this._onWillExecuteCommand = new Emitter();\n        this._onDidExecuteCommand = new Emitter();\n        this.onWillExecuteCommand = this._onWillExecuteCommand.event;\n        this.onDidExecuteCommand = this._onDidExecuteCommand.event;\n        this._instantiationService = instantiationService;\n    }\n    executeCommand(id, ...args) {\n        const command = CommandsRegistry.getCommand(id);\n        if (!command) {\n            return Promise.reject(new Error(`command '${id}' not found`));\n        }\n        try {\n            this._onWillExecuteCommand.fire({ commandId: id, args });\n            const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);\n            this._onDidExecuteCommand.fire({ commandId: id, args });\n            return Promise.resolve(result);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n};\nStandaloneCommandService = __decorate([\n    __param(0, IInstantiationService)\n], StandaloneCommandService);\nexport { StandaloneCommandService };\nlet StandaloneKeybindingService = class StandaloneKeybindingService extends AbstractKeybindingService {\n    constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {\n        super(contextKeyService, commandService, telemetryService, notificationService, logService);\n        this._cachedResolver = null;\n        this._dynamicKeybindings = [];\n        this._domNodeListeners = [];\n        const addContainer = (domNode) => {\n            const disposables = new DisposableStore();\n            // for standard keybindings\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                    keyEvent.stopPropagation();\n                }\n            }));\n            // for single modifier chord keybindings (e.g. shift shift)\n            disposables.add(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e) => {\n                const keyEvent = new StandardKeyboardEvent(e);\n                const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                }\n            }));\n            this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));\n        };\n        const removeContainer = (domNode) => {\n            for (let i = 0; i < this._domNodeListeners.length; i++) {\n                const domNodeListeners = this._domNodeListeners[i];\n                if (domNodeListeners.domNode === domNode) {\n                    this._domNodeListeners.splice(i, 1);\n                    domNodeListeners.dispose();\n                }\n            }\n        };\n        const addCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(54 /* inDiffEditor */)) {\n                return;\n            }\n            addContainer(codeEditor.getContainerDomNode());\n        };\n        const removeCodeEditor = (codeEditor) => {\n            if (codeEditor.getOption(54 /* inDiffEditor */)) {\n                return;\n            }\n            removeContainer(codeEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));\n        this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));\n        codeEditorService.listCodeEditors().forEach(addCodeEditor);\n        const addDiffEditor = (diffEditor) => {\n            addContainer(diffEditor.getContainerDomNode());\n        };\n        const removeDiffEditor = (diffEditor) => {\n            removeContainer(diffEditor.getContainerDomNode());\n        };\n        this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));\n        this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));\n        codeEditorService.listDiffEditors().forEach(addDiffEditor);\n    }\n    addDynamicKeybinding(commandId, _keybinding, handler, when) {\n        const keybinding = createKeybinding(_keybinding, OS);\n        const toDispose = new DisposableStore();\n        if (keybinding) {\n            this._dynamicKeybindings.push({\n                keybinding: keybinding.parts,\n                command: commandId,\n                when: when,\n                weight1: 1000,\n                weight2: 0,\n                extensionId: null,\n                isBuiltinExtension: false\n            });\n            toDispose.add(toDisposable(() => {\n                for (let i = 0; i < this._dynamicKeybindings.length; i++) {\n                    const kb = this._dynamicKeybindings[i];\n                    if (kb.command === commandId) {\n                        this._dynamicKeybindings.splice(i, 1);\n                        this.updateResolver({ source: 1 /* Default */ });\n                        return;\n                    }\n                }\n            }));\n        }\n        toDispose.add(CommandsRegistry.registerCommand(commandId, handler));\n        this.updateResolver({ source: 1 /* Default */ });\n        return toDispose;\n    }\n    updateResolver(event) {\n        this._cachedResolver = null;\n        this._onDidUpdateKeybindings.fire(event);\n    }\n    _getResolver() {\n        if (!this._cachedResolver) {\n            const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);\n            const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);\n            this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));\n        }\n        return this._cachedResolver;\n    }\n    _documentHasFocus() {\n        return document.hasFocus();\n    }\n    _toNormalizedKeybindingItems(items, isDefault) {\n        const result = [];\n        let resultLen = 0;\n        for (const item of items) {\n            const when = item.when || undefined;\n            const keybinding = item.keybinding;\n            if (!keybinding) {\n                // This might be a removal keybinding item in user settings => accept it\n                result[resultLen++] = new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false);\n            }\n            else {\n                const resolvedKeybindings = USLayoutResolvedKeybinding.resolveUserBinding(keybinding, OS);\n                for (const resolvedKeybinding of resolvedKeybindings) {\n                    result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);\n                }\n            }\n        }\n        return result;\n    }\n    resolveKeyboardEvent(keyboardEvent) {\n        const keybinding = new SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode).toChord();\n        return new USLayoutResolvedKeybinding(keybinding, OS);\n    }\n};\nStandaloneKeybindingService = __decorate([\n    __param(0, IContextKeyService),\n    __param(1, ICommandService),\n    __param(2, ITelemetryService),\n    __param(3, INotificationService),\n    __param(4, ILogService),\n    __param(5, ICodeEditorService)\n], StandaloneKeybindingService);\nexport { StandaloneKeybindingService };\nclass DomNodeListeners extends Disposable {\n    constructor(domNode, disposables) {\n        super();\n        this.domNode = domNode;\n        this._register(disposables);\n    }\n}\nfunction isConfigurationOverrides(thing) {\n    return thing\n        && typeof thing === 'object'\n        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n        && (!thing.resource || thing.resource instanceof URI);\n}\nexport class StandaloneConfigurationService {\n    constructor() {\n        this._onDidChangeConfiguration = new Emitter();\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this._configuration = new Configuration(new DefaultConfigurationModel(), new ConfigurationModel());\n    }\n    getValue(arg1, arg2) {\n        const section = typeof arg1 === 'string' ? arg1 : undefined;\n        const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};\n        return this._configuration.getValue(section, overrides, undefined);\n    }\n    updateValues(values) {\n        const previous = { data: this._configuration.toData() };\n        const changedKeys = [];\n        for (const entry of values) {\n            const [key, value] = entry;\n            if (this.getValue(key) === value) {\n                continue;\n            }\n            this._configuration.updateValue(key, value);\n            changedKeys.push(key);\n        }\n        if (changedKeys.length > 0) {\n            const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration);\n            configurationChangeEvent.source = 7 /* MEMORY */;\n            configurationChangeEvent.sourceConfig = null;\n            this._onDidChangeConfiguration.fire(configurationChangeEvent);\n        }\n        return Promise.resolve();\n    }\n    updateValue(key, value, arg3, arg4) {\n        return this.updateValues([[key, value]]);\n    }\n    inspect(key, options = {}) {\n        return this._configuration.inspect(key, options, undefined);\n    }\n}\nlet StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService {\n    constructor(configurationService) {\n        this.configurationService = configurationService;\n        this._onDidChangeConfiguration = new Emitter();\n        this.configurationService.onDidChangeConfiguration((e) => {\n            this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });\n        });\n    }\n    getValue(resource, arg2, arg3) {\n        const position = Pos.isIPosition(arg2) ? arg2 : null;\n        const section = position ? (typeof arg3 === 'string' ? arg3 : undefined) : (typeof arg2 === 'string' ? arg2 : undefined);\n        if (typeof section === 'undefined') {\n            return this.configurationService.getValue();\n        }\n        return this.configurationService.getValue(section);\n    }\n};\nStandaloneResourceConfigurationService = __decorate([\n    __param(0, IConfigurationService)\n], StandaloneResourceConfigurationService);\nlet StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService {\n    constructor(configurationService) {\n        this.configurationService = configurationService;\n    }\n    getEOL(resource, language) {\n        const eol = this.configurationService.getValue('files.eol', { overrideIdentifier: language, resource });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return (isLinux || isMacintosh) ? '\\n' : '\\r\\n';\n    }\n};\nStandaloneResourcePropertiesService = __decorate([\n    __param(0, IConfigurationService)\n], StandaloneResourcePropertiesService);\nclass StandaloneTelemetryService {\n    publicLog(eventName, data) {\n        return Promise.resolve(undefined);\n    }\n    publicLog2(eventName, data) {\n        return this.publicLog(eventName, data);\n    }\n}\nclass StandaloneWorkspaceContextService {\n    constructor() {\n        const resource = URI.from({ scheme: StandaloneWorkspaceContextService.SCHEME, authority: 'model', path: '/' });\n        this.workspace = { id: '4064f6ec-cb38-4ad0-af64-ee6467e63c82', folders: [new WorkspaceFolder({ uri: resource, name: '', index: 0 })] };\n    }\n    getWorkspace() {\n        return this.workspace;\n    }\n}\nStandaloneWorkspaceContextService.SCHEME = 'inmemory';\nexport function updateConfigurationService(configurationService, source, isDiffEditor) {\n    if (!source) {\n        return;\n    }\n    if (!(configurationService instanceof StandaloneConfigurationService)) {\n        return;\n    }\n    const toUpdate = [];\n    Object.keys(source).forEach((key) => {\n        if (isEditorConfigurationKey(key)) {\n            toUpdate.push([`editor.${key}`, source[key]]);\n        }\n        if (isDiffEditor && isDiffEditorConfigurationKey(key)) {\n            toUpdate.push([`diffEditor.${key}`, source[key]]);\n        }\n    });\n    if (toUpdate.length > 0) {\n        configurationService.updateValues(toUpdate);\n    }\n}\nlet StandaloneBulkEditService = class StandaloneBulkEditService {\n    constructor(_modelService) {\n        this._modelService = _modelService;\n        //\n    }\n    hasPreviewHandler() {\n        return false;\n    }\n    apply(edits, _options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const textEdits = new Map();\n            for (let edit of edits) {\n                if (!(edit instanceof ResourceTextEdit)) {\n                    throw new Error('bad edit - only text edits are supported');\n                }\n                const model = this._modelService.getModel(edit.resource);\n                if (!model) {\n                    throw new Error('bad edit - model not found');\n                }\n                if (typeof edit.versionId === 'number' && model.getVersionId() !== edit.versionId) {\n                    throw new Error('bad state - model changed in the meantime');\n                }\n                let array = textEdits.get(model);\n                if (!array) {\n                    array = [];\n                    textEdits.set(model, array);\n                }\n                array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));\n            }\n            let totalEdits = 0;\n            let totalFiles = 0;\n            for (const [model, edits] of textEdits) {\n                model.pushStackElement();\n                model.pushEditOperations([], edits, () => []);\n                model.pushStackElement();\n                totalFiles += 1;\n                totalEdits += edits.length;\n            }\n            return {\n                ariaSummary: strings.format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles)\n            };\n        });\n    }\n};\nStandaloneBulkEditService = __decorate([\n    __param(0, IModelService)\n], StandaloneBulkEditService);\nclass StandaloneUriLabelService {\n    getUriLabel(resource, options) {\n        if (resource.scheme === 'file') {\n            return resource.fsPath;\n        }\n        return resource.path;\n    }\n}\nlet StandaloneContextViewService = class StandaloneContextViewService extends ContextViewService {\n    constructor(layoutService, _codeEditorService) {\n        super(layoutService);\n        this._codeEditorService = _codeEditorService;\n    }\n    showContextView(delegate, container, shadowRoot) {\n        if (!container) {\n            const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();\n            if (codeEditor) {\n                container = codeEditor.getContainerDomNode();\n            }\n        }\n        return super.showContextView(delegate, container, shadowRoot);\n    }\n};\nStandaloneContextViewService = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ICodeEditorService)\n], StandaloneContextViewService);\nclass StandaloneWorkspaceTrustManagementService {\n    constructor() {\n        this._neverEmitter = new Emitter();\n        this.onDidChangeTrust = this._neverEmitter.event;\n    }\n    isWorkspaceTrusted() {\n        return true;\n    }\n}\nclass StandaloneLanguageService extends LanguageService {\n    constructor() {\n        super();\n    }\n}\nclass StandaloneLogService extends LogService {\n    constructor() {\n        super(new ConsoleLogger());\n    }\n}\nlet StandaloneContextMenuService = class StandaloneContextMenuService extends ContextMenuService {\n    constructor(telemetryService, notificationService, contextViewService, keybindingService, themeService) {\n        super(telemetryService, notificationService, contextViewService, keybindingService, themeService);\n        this.configure({ blockMouse: false }); // we do not want that in the standalone editor\n    }\n};\nStandaloneContextMenuService = __decorate([\n    __param(0, ITelemetryService),\n    __param(1, INotificationService),\n    __param(2, IContextViewService),\n    __param(3, IKeybindingService),\n    __param(4, IThemeService)\n], StandaloneContextMenuService);\nregisterSingleton(IConfigurationService, StandaloneConfigurationService);\nregisterSingleton(ITextResourceConfigurationService, StandaloneResourceConfigurationService);\nregisterSingleton(ITextResourcePropertiesService, StandaloneResourcePropertiesService);\nregisterSingleton(IWorkspaceContextService, StandaloneWorkspaceContextService);\nregisterSingleton(ILabelService, StandaloneUriLabelService);\nregisterSingleton(ITelemetryService, StandaloneTelemetryService);\nregisterSingleton(IDialogService, StandaloneDialogService);\nregisterSingleton(INotificationService, StandaloneNotificationService);\nregisterSingleton(IMarkerService, MarkerService);\nregisterSingleton(ILanguageService, StandaloneLanguageService);\nregisterSingleton(IStandaloneThemeService, StandaloneThemeService);\nregisterSingleton(ILogService, StandaloneLogService);\nregisterSingleton(IModelService, ModelService);\nregisterSingleton(IMarkerDecorationsService, MarkerDecorationsService);\nregisterSingleton(IContextKeyService, ContextKeyService);\nregisterSingleton(IEditorProgressService, StandaloneEditorProgressService);\nregisterSingleton(IStorageService, InMemoryStorageService);\nregisterSingleton(IEditorWorkerService, EditorWorkerService);\nregisterSingleton(IBulkEditService, StandaloneBulkEditService);\nregisterSingleton(IWorkspaceTrustManagementService, StandaloneWorkspaceTrustManagementService);\nregisterSingleton(ITextModelService, StandaloneTextModelService);\nregisterSingleton(IAccessibilityService, AccessibilityService);\nregisterSingleton(IListService, ListService);\nregisterSingleton(ICommandService, StandaloneCommandService);\nregisterSingleton(IKeybindingService, StandaloneKeybindingService);\nregisterSingleton(IQuickInputService, StandaloneQuickInputService);\nregisterSingleton(IContextViewService, StandaloneContextViewService);\nregisterSingleton(IOpenerService, OpenerService);\nregisterSingleton(IClipboardService, BrowserClipboardService);\nregisterSingleton(IContextMenuService, StandaloneContextMenuService);\nregisterSingleton(IMenuService, MenuService);\n/**\n * We don't want to eagerly instantiate services because embedders get a one time chance\n * to override services when they create the first editor.\n */\nexport var StandaloneServices;\n(function (StandaloneServices) {\n    const serviceCollection = new ServiceCollection();\n    for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n        serviceCollection.set(id, descriptor);\n    }\n    const instantiationService = new InstantiationService(serviceCollection, true);\n    serviceCollection.set(IInstantiationService, instantiationService);\n    function get(serviceId) {\n        const r = serviceCollection.get(serviceId);\n        if (!r) {\n            throw new Error('Missing service ' + serviceId);\n        }\n        if (r instanceof SyncDescriptor) {\n            return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));\n        }\n        else {\n            return r;\n        }\n    }\n    StandaloneServices.get = get;\n    let initialized = false;\n    function initialize(overrides) {\n        if (initialized) {\n            return instantiationService;\n        }\n        initialized = true;\n        // Add singletons that were registered after this module loaded\n        for (const [id, descriptor] of getSingletonServiceDescriptors()) {\n            if (!serviceCollection.get(id)) {\n                serviceCollection.set(id, descriptor);\n            }\n        }\n        // Initialize the service collection with the overrides, but only if the\n        // service was not instantiated in the meantime.\n        for (const serviceId in overrides) {\n            if (overrides.hasOwnProperty(serviceId)) {\n                const serviceIdentifier = createDecorator(serviceId);\n                const r = serviceCollection.get(serviceIdentifier);\n                if (r instanceof SyncDescriptor) {\n                    serviceCollection.set(serviceIdentifier, overrides[serviceId]);\n                }\n            }\n        }\n        return instantiationService;\n    }\n    StandaloneServices.initialize = initialize;\n})(StandaloneServices || (StandaloneServices = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as aria from '../../../base/browser/ui/aria/aria.js';\nimport { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { CodeEditorWidget } from '../../browser/widget/codeEditorWidget.js';\nimport { DiffEditorWidget } from '../../browser/widget/diffEditorWidget.js';\nimport { InternalEditorAction } from '../../common/editorAction.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorker.js';\nimport { StandaloneKeybindingService, updateConfigurationService } from './standaloneServices.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { MenuId, MenuRegistry } from '../../../platform/actions/common/actions.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { StandaloneCodeEditorNLS } from '../../common/standaloneStrings.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { StandaloneCodeEditorService } from './standaloneCodeEditorService.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../../common/languages/modesRegistry.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\nlet LAST_GENERATED_COMMAND_ID = 0;\nlet ariaDomNodeCreated = false;\n/**\n * Create ARIA dom node inside parent,\n * or only for the first editor instantiation inside document.body.\n * @param parent container element for ARIA dom node\n */\nfunction createAriaDomNode(parent) {\n    if (!parent) {\n        if (ariaDomNodeCreated) {\n            return;\n        }\n        ariaDomNodeCreated = true;\n    }\n    aria.setARIAContainer(parent || document.body);\n}\n/**\n * A code editor to be used both by the standalone editor and the standalone diff editor.\n */\nlet StandaloneCodeEditor = class StandaloneCodeEditor extends CodeEditorWidget {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {\n        const options = Object.assign({}, _options);\n        options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;\n        options.ariaLabel = options.ariaLabel + ';' + (StandaloneCodeEditorNLS.accessibilityHelpMessage);\n        super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        if (keybindingService instanceof StandaloneKeybindingService) {\n            this._standaloneKeybindingService = keybindingService;\n        }\n        else {\n            this._standaloneKeybindingService = null;\n        }\n        createAriaDomNode(options.ariaContainerElement);\n    }\n    addCommand(keybinding, handler, context) {\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');\n            return null;\n        }\n        const commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);\n        const whenExpression = ContextKeyExpr.deserialize(context);\n        this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);\n        return commandId;\n    }\n    createContextKey(key, defaultValue) {\n        return this._contextKeyService.createKey(key, defaultValue);\n    }\n    addAction(_descriptor) {\n        if ((typeof _descriptor.id !== 'string') || (typeof _descriptor.label !== 'string') || (typeof _descriptor.run !== 'function')) {\n            throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');\n        }\n        if (!this._standaloneKeybindingService) {\n            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');\n            return Disposable.None;\n        }\n        // Read descriptor options\n        const id = _descriptor.id;\n        const label = _descriptor.label;\n        const precondition = ContextKeyExpr.and(ContextKeyExpr.equals('editorId', this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));\n        const keybindings = _descriptor.keybindings;\n        const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));\n        const contextMenuGroupId = _descriptor.contextMenuGroupId || null;\n        const contextMenuOrder = _descriptor.contextMenuOrder || 0;\n        const run = (accessor, ...args) => {\n            return Promise.resolve(_descriptor.run(this, ...args));\n        };\n        const toDispose = new DisposableStore();\n        // Generate a unique id to allow the same descriptor.id across multiple editor instances\n        const uniqueId = this.getId() + ':' + id;\n        // Register the command\n        toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));\n        // Register the context menu item\n        if (contextMenuGroupId) {\n            const menuItem = {\n                command: {\n                    id: uniqueId,\n                    title: label\n                },\n                when: precondition,\n                group: contextMenuGroupId,\n                order: contextMenuOrder\n            };\n            toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));\n        }\n        // Register the keybindings\n        if (Array.isArray(keybindings)) {\n            for (const kb of keybindings) {\n                toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));\n            }\n        }\n        // Finally, register an internal editor action\n        const internalAction = new InternalEditorAction(uniqueId, label, label, precondition, run, this._contextKeyService);\n        // Store it under the original id, such that trigger with the original id will work\n        this._actions[id] = internalAction;\n        toDispose.add(toDisposable(() => {\n            delete this._actions[id];\n        }));\n        return toDispose;\n    }\n    _triggerCommand(handlerId, payload) {\n        if (this._codeEditorService instanceof StandaloneCodeEditorService) {\n            // Help commands find this editor as the active editor\n            try {\n                this._codeEditorService.setActiveCodeEditor(this);\n                super._triggerCommand(handlerId, payload);\n            }\n            finally {\n                this._codeEditorService.setActiveCodeEditor(null);\n            }\n        }\n        else {\n            super._triggerCommand(handlerId, payload);\n        }\n    }\n};\nStandaloneCodeEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IKeybindingService),\n    __param(7, IThemeService),\n    __param(8, INotificationService),\n    __param(9, IAccessibilityService),\n    __param(10, ILanguageConfigurationService),\n    __param(11, ILanguageFeaturesService)\n], StandaloneCodeEditor);\nexport { StandaloneCodeEditor };\nlet StandaloneEditor = class StandaloneEditor extends StandaloneCodeEditor {\n    constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {\n        const options = Object.assign({}, _options);\n        updateConfigurationService(configurationService, options, false);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        const _model = options.model;\n        delete options.model;\n        super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n        let model;\n        if (typeof _model === 'undefined') {\n            const languageId = languageService.getLanguageIdByMimeType(options.language) || options.language || PLAINTEXT_LANGUAGE_ID;\n            model = createTextModel(modelService, languageService, options.value || '', languageId, undefined);\n            this._ownsModel = true;\n        }\n        else {\n            model = _model;\n            this._ownsModel = false;\n        }\n        this._attachModel(model);\n        if (model) {\n            const e = {\n                oldModelUrl: null,\n                newModelUrl: model.uri\n            };\n            this._onDidChangeModel.fire(e);\n        }\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, false);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _postDetachModelCleanup(detachedModel) {\n        super._postDetachModelCleanup(detachedModel);\n        if (detachedModel && this._ownsModel) {\n            detachedModel.dispose();\n            this._ownsModel = false;\n        }\n    }\n};\nStandaloneEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, ICodeEditorService),\n    __param(4, ICommandService),\n    __param(5, IContextKeyService),\n    __param(6, IKeybindingService),\n    __param(7, IStandaloneThemeService),\n    __param(8, INotificationService),\n    __param(9, IConfigurationService),\n    __param(10, IAccessibilityService),\n    __param(11, IModelService),\n    __param(12, ILanguageService),\n    __param(13, ILanguageConfigurationService),\n    __param(14, ILanguageFeaturesService)\n], StandaloneEditor);\nexport { StandaloneEditor };\nlet StandaloneDiffEditor = class StandaloneDiffEditor extends DiffEditorWidget {\n    constructor(domElement, _options, instantiationService, contextKeyService, editorWorkerService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService) {\n        const options = Object.assign({}, _options);\n        updateConfigurationService(configurationService, options, true);\n        const themeDomRegistration = themeService.registerEditorContainer(domElement);\n        if (typeof options.theme === 'string') {\n            themeService.setTheme(options.theme);\n        }\n        if (typeof options.autoDetectHighContrast !== 'undefined') {\n            themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));\n        }\n        super(domElement, options, {}, clipboardService, editorWorkerService, contextKeyService, instantiationService, codeEditorService, themeService, notificationService, contextMenuService, editorProgressService);\n        this._configurationService = configurationService;\n        this._standaloneThemeService = themeService;\n        this._register(themeDomRegistration);\n    }\n    dispose() {\n        super.dispose();\n    }\n    updateOptions(newOptions) {\n        updateConfigurationService(this._configurationService, newOptions, true);\n        if (typeof newOptions.theme === 'string') {\n            this._standaloneThemeService.setTheme(newOptions.theme);\n        }\n        if (typeof newOptions.autoDetectHighContrast !== 'undefined') {\n            this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));\n        }\n        super.updateOptions(newOptions);\n    }\n    _createInnerEditor(instantiationService, container, options) {\n        return instantiationService.createInstance(StandaloneCodeEditor, container, options);\n    }\n    getOriginalEditor() {\n        return super.getOriginalEditor();\n    }\n    getModifiedEditor() {\n        return super.getModifiedEditor();\n    }\n    addCommand(keybinding, handler, context) {\n        return this.getModifiedEditor().addCommand(keybinding, handler, context);\n    }\n    createContextKey(key, defaultValue) {\n        return this.getModifiedEditor().createContextKey(key, defaultValue);\n    }\n    addAction(descriptor) {\n        return this.getModifiedEditor().addAction(descriptor);\n    }\n};\nStandaloneDiffEditor = __decorate([\n    __param(2, IInstantiationService),\n    __param(3, IContextKeyService),\n    __param(4, IEditorWorkerService),\n    __param(5, ICodeEditorService),\n    __param(6, IStandaloneThemeService),\n    __param(7, INotificationService),\n    __param(8, IConfigurationService),\n    __param(9, IContextMenuService),\n    __param(10, IEditorProgressService),\n    __param(11, IClipboardService)\n], StandaloneDiffEditor);\nexport { StandaloneDiffEditor };\n/**\n * @internal\n */\nexport function createTextModel(modelService, languageService, value, languageId, uri) {\n    value = value || '';\n    if (!languageId) {\n        const firstLF = value.indexOf('\\n');\n        let firstLine = value;\n        if (firstLF !== -1) {\n            firstLine = value.substring(0, firstLF);\n        }\n        return doCreateModel(modelService, value, languageService.createByFilepathOrFirstLine(uri || null, firstLine), uri);\n    }\n    return doCreateModel(modelService, value, languageService.createById(languageId), uri);\n}\n/**\n * @internal\n */\nfunction doCreateModel(modelService, value, languageSelection, uri) {\n    return modelService.createModel(value, languageSelection, uri);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './standalone-tokens.css';\nimport { splitLines } from '../../../base/common/strings.js';\nimport { FontMeasurements } from '../../browser/config/fontMeasurements.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { DiffNavigator } from '../../browser/widget/diffNavigator.js';\nimport { ApplyUpdateResult, ConfigurationChangedEvent, EditorOptions } from '../../common/config/editorOptions.js';\nimport { BareFontInfo, FontInfo } from '../../common/config/fontInfo.js';\nimport { EditorType } from '../../common/editorCommon.js';\nimport { FindMatch, TextModelResolvedOptions } from '../../common/model.js';\nimport * as languages from '../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry.js';\nimport { NullState, nullTokenize } from '../../common/languages/nullTokenize.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport { IModelService } from '../../common/services/model.js';\nimport { createWebWorker as actualCreateWebWorker } from '../../browser/services/webWorker.js';\nimport * as standaloneEnums from '../../common/standalone/standaloneEnums.js';\nimport { Colorizer } from './colorizer.js';\nimport { createTextModel, StandaloneDiffEditor, StandaloneEditor } from './standaloneCodeEditor.js';\nimport { StandaloneServices } from './standaloneServices.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\n/**\n * Create a new editor under `domElement`.\n * `domElement` should be empty (not contain other dom nodes).\n * The editor will read the size of `domElement`.\n */\nexport function create(domElement, options, override) {\n    const instantiationService = StandaloneServices.initialize(override || {});\n    return instantiationService.createInstance(StandaloneEditor, domElement, options);\n}\n/**\n * Emitted when an editor is created.\n * Creating a diff editor might cause this listener to be invoked with the two editors.\n * @event\n */\nexport function onDidCreateEditor(listener) {\n    const codeEditorService = StandaloneServices.get(ICodeEditorService);\n    return codeEditorService.onCodeEditorAdd((editor) => {\n        listener(editor);\n    });\n}\n/**\n * Create a new diff editor under `domElement`.\n * `domElement` should be empty (not contain other dom nodes).\n * The editor will read the size of `domElement`.\n */\nexport function createDiffEditor(domElement, options, override) {\n    const instantiationService = StandaloneServices.initialize(override || {});\n    return instantiationService.createInstance(StandaloneDiffEditor, domElement, options);\n}\nexport function createDiffNavigator(diffEditor, opts) {\n    return new DiffNavigator(diffEditor, opts);\n}\n/**\n * Create a new editor model.\n * You can specify the language that should be set for this model or let the language be inferred from the `uri`.\n */\nexport function createModel(value, language, uri) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const languageId = languageService.getLanguageIdByMimeType(language) || language;\n    return createTextModel(StandaloneServices.get(IModelService), languageService, value, languageId, uri);\n}\n/**\n * Change the language for a model.\n */\nexport function setModelLanguage(model, languageId) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const modelService = StandaloneServices.get(IModelService);\n    modelService.setMode(model, languageService.createById(languageId));\n}\n/**\n * Set the markers for a model.\n */\nexport function setModelMarkers(model, owner, markers) {\n    if (model) {\n        const markerService = StandaloneServices.get(IMarkerService);\n        markerService.changeOne(owner, model.uri, markers);\n    }\n}\n/**\n * Get markers for owner and/or resource\n *\n * @returns list of markers\n */\nexport function getModelMarkers(filter) {\n    const markerService = StandaloneServices.get(IMarkerService);\n    return markerService.read(filter);\n}\n/**\n * Emitted when markers change for a model.\n * @event\n */\nexport function onDidChangeMarkers(listener) {\n    const markerService = StandaloneServices.get(IMarkerService);\n    return markerService.onMarkerChanged(listener);\n}\n/**\n * Get the model that has `uri` if it exists.\n */\nexport function getModel(uri) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.getModel(uri);\n}\n/**\n * Get all the created models.\n */\nexport function getModels() {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.getModels();\n}\n/**\n * Emitted when a model is created.\n * @event\n */\nexport function onDidCreateModel(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelAdded(listener);\n}\n/**\n * Emitted right before a model is disposed.\n * @event\n */\nexport function onWillDisposeModel(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelRemoved(listener);\n}\n/**\n * Emitted when a different language is set to a model.\n * @event\n */\nexport function onDidChangeModelLanguage(listener) {\n    const modelService = StandaloneServices.get(IModelService);\n    return modelService.onModelLanguageChanged((e) => {\n        listener({\n            model: e.model,\n            oldLanguage: e.oldLanguageId\n        });\n    });\n}\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker(opts) {\n    return actualCreateWebWorker(StandaloneServices.get(IModelService), StandaloneServices.get(ILanguageConfigurationService), opts);\n}\n/**\n * Colorize the contents of `domNode` using attribute `data-lang`.\n */\nexport function colorizeElement(domNode, options) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(domNode);\n    return Colorizer.colorizeElement(themeService, languageService, domNode, options);\n}\n/**\n * Colorize `text` using language `languageId`.\n */\nexport function colorize(text, languageId, options) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(document.body);\n    return Colorizer.colorize(languageService, text, languageId, options);\n}\n/**\n * Colorize a line in a model.\n */\nexport function colorizeModelLine(model, lineNumber, tabSize = 4) {\n    const themeService = StandaloneServices.get(IStandaloneThemeService);\n    themeService.registerEditorContainer(document.body);\n    return Colorizer.colorizeModelLine(model, lineNumber, tabSize);\n}\n/**\n * @internal\n */\nfunction getSafeTokenizationSupport(language) {\n    const tokenizationSupport = languages.TokenizationRegistry.get(language);\n    if (tokenizationSupport) {\n        return tokenizationSupport;\n    }\n    return {\n        getInitialState: () => NullState,\n        tokenize: (line, hasEOL, state) => nullTokenize(language, state)\n    };\n}\n/**\n * Tokenize `text` using language `languageId`\n */\nexport function tokenize(text, languageId) {\n    // Needed in order to get the mode registered for subsequent look-ups\n    languages.TokenizationRegistry.getOrCreate(languageId);\n    const tokenizationSupport = getSafeTokenizationSupport(languageId);\n    const lines = splitLines(text);\n    const result = [];\n    let state = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        const tokenizationResult = tokenizationSupport.tokenize(line, true, state);\n        result[i] = tokenizationResult.tokens;\n        state = tokenizationResult.endState;\n    }\n    return result;\n}\n/**\n * Define a new theme or update an existing theme.\n */\nexport function defineTheme(themeName, themeData) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    standaloneThemeService.defineTheme(themeName, themeData);\n}\n/**\n * Switches to a theme.\n */\nexport function setTheme(themeName) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    standaloneThemeService.setTheme(themeName);\n}\n/**\n * Clears all cached font measurements and triggers re-measurement.\n */\nexport function remeasureFonts() {\n    FontMeasurements.clearAllFontInfos();\n}\n/**\n * Register a command.\n */\nexport function registerCommand(id, handler) {\n    return CommandsRegistry.registerCommand({ id, handler });\n}\n/**\n * @internal\n */\nexport function createMonacoEditorAPI() {\n    return {\n        // methods\n        create: create,\n        onDidCreateEditor: onDidCreateEditor,\n        createDiffEditor: createDiffEditor,\n        createDiffNavigator: createDiffNavigator,\n        createModel: createModel,\n        setModelLanguage: setModelLanguage,\n        setModelMarkers: setModelMarkers,\n        getModelMarkers: getModelMarkers,\n        onDidChangeMarkers: onDidChangeMarkers,\n        getModels: getModels,\n        getModel: getModel,\n        onDidCreateModel: onDidCreateModel,\n        onWillDisposeModel: onWillDisposeModel,\n        onDidChangeModelLanguage: onDidChangeModelLanguage,\n        createWebWorker: createWebWorker,\n        colorizeElement: colorizeElement,\n        colorize: colorize,\n        colorizeModelLine: colorizeModelLine,\n        tokenize: tokenize,\n        defineTheme: defineTheme,\n        setTheme: setTheme,\n        remeasureFonts: remeasureFonts,\n        registerCommand: registerCommand,\n        // enums\n        AccessibilitySupport: standaloneEnums.AccessibilitySupport,\n        ContentWidgetPositionPreference: standaloneEnums.ContentWidgetPositionPreference,\n        CursorChangeReason: standaloneEnums.CursorChangeReason,\n        DefaultEndOfLine: standaloneEnums.DefaultEndOfLine,\n        EditorAutoIndentStrategy: standaloneEnums.EditorAutoIndentStrategy,\n        EditorOption: standaloneEnums.EditorOption,\n        EndOfLinePreference: standaloneEnums.EndOfLinePreference,\n        EndOfLineSequence: standaloneEnums.EndOfLineSequence,\n        MinimapPosition: standaloneEnums.MinimapPosition,\n        MouseTargetType: standaloneEnums.MouseTargetType,\n        OverlayWidgetPositionPreference: standaloneEnums.OverlayWidgetPositionPreference,\n        OverviewRulerLane: standaloneEnums.OverviewRulerLane,\n        RenderLineNumbersType: standaloneEnums.RenderLineNumbersType,\n        RenderMinimap: standaloneEnums.RenderMinimap,\n        ScrollbarVisibility: standaloneEnums.ScrollbarVisibility,\n        ScrollType: standaloneEnums.ScrollType,\n        TextEditorCursorBlinkingStyle: standaloneEnums.TextEditorCursorBlinkingStyle,\n        TextEditorCursorStyle: standaloneEnums.TextEditorCursorStyle,\n        TrackedRangeStickiness: standaloneEnums.TrackedRangeStickiness,\n        WrappingIndent: standaloneEnums.WrappingIndent,\n        InjectedTextCursorStops: standaloneEnums.InjectedTextCursorStops,\n        PositionAffinity: standaloneEnums.PositionAffinity,\n        // classes\n        ConfigurationChangedEvent: ConfigurationChangedEvent,\n        BareFontInfo: BareFontInfo,\n        FontInfo: FontInfo,\n        TextModelResolvedOptions: TextModelResolvedOptions,\n        FindMatch: FindMatch,\n        ApplyUpdateResult: ApplyUpdateResult,\n        // vars\n        EditorType: EditorType,\n        EditorOptions: EditorOptions\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*\n * This module only exports 'compile' which compiles a JSON language definition\n * into a typed and checked ILexer definition.\n */\nimport * as monarchCommon from './monarchCommon.js';\n/*\n * Type helpers\n *\n * Note: this is just for sanity checks on the JSON description which is\n * helpful for the programmer. No checks are done anymore once the lexer is\n * already 'compiled and checked'.\n *\n */\nfunction isArrayOf(elemType, obj) {\n    if (!obj) {\n        return false;\n    }\n    if (!(Array.isArray(obj))) {\n        return false;\n    }\n    for (const el of obj) {\n        if (!(elemType(el))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction bool(prop, defValue) {\n    if (typeof prop === 'boolean') {\n        return prop;\n    }\n    return defValue;\n}\nfunction string(prop, defValue) {\n    if (typeof (prop) === 'string') {\n        return prop;\n    }\n    return defValue;\n}\nfunction arrayToHash(array) {\n    const result = {};\n    for (const e of array) {\n        result[e] = true;\n    }\n    return result;\n}\nfunction createKeywordMatcher(arr, caseInsensitive = false) {\n    if (caseInsensitive) {\n        arr = arr.map(function (x) { return x.toLowerCase(); });\n    }\n    const hash = arrayToHash(arr);\n    if (caseInsensitive) {\n        return function (word) {\n            return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n        };\n    }\n    else {\n        return function (word) {\n            return hash[word] !== undefined && hash.hasOwnProperty(word);\n        };\n    }\n}\n// Lexer helpers\n/**\n * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set, and the 'u' flag if 'unicode' is set.\n * Also replaces @\\w+ or sequences with the content of the specified attribute\n * @\\w+ replacement can be avoided by escaping `@` signs with another `@` sign.\n * @example /@attr/ will be replaced with the value of lexer[attr]\n * @example /@@text/ will not be replaced and will become /@text/.\n */\nfunction compileRegExp(lexer, str) {\n    // @@ must be interpreted as a literal @, so we replace all occurences of @@ with a placeholder character\n    str = str.replace(/@@/g, `\\x01`);\n    let n = 0;\n    let hadExpansion;\n    do {\n        hadExpansion = false;\n        str = str.replace(/@(\\w+)/g, function (s, attr) {\n            hadExpansion = true;\n            let sub = '';\n            if (typeof (lexer[attr]) === 'string') {\n                sub = lexer[attr];\n            }\n            else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n                sub = lexer[attr].source;\n            }\n            else {\n                if (lexer[attr] === undefined) {\n                    throw monarchCommon.createError(lexer, 'language definition does not contain attribute \\'' + attr + '\\', used at: ' + str);\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'attribute reference \\'' + attr + '\\' must be a string, used at: ' + str);\n                }\n            }\n            return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');\n        });\n        n++;\n    } while (hadExpansion && n < 5);\n    // handle escaped @@\n    str = str.replace(/\\x01/g, '@');\n    const flags = (lexer.ignoreCase ? 'i' : '') + (lexer.unicode ? 'u' : '');\n    return new RegExp(str, flags);\n}\n/**\n * Compiles guard functions for case matches.\n * This compiles 'cases' attributes into efficient match functions.\n *\n */\nfunction selectScrutinee(id, matches, state, num) {\n    if (num < 0) {\n        return id;\n    }\n    if (num < matches.length) {\n        return matches[num];\n    }\n    if (num >= 100) {\n        num = num - 100;\n        const parts = state.split('.');\n        parts.unshift(state);\n        if (num < parts.length) {\n            return parts[num];\n        }\n    }\n    return null;\n}\nfunction createGuard(lexer, ruleName, tkey, val) {\n    // get the scrutinee and pattern\n    let scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn\n    let oppat = tkey;\n    let matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n    if (matches) {\n        if (matches[3]) { // if digits\n            scrut = parseInt(matches[3]);\n            if (matches[2]) {\n                scrut = scrut + 100; // if [sS] present\n            }\n        }\n        oppat = matches[4];\n    }\n    // get operator\n    let op = '~';\n    let pat = oppat;\n    if (!oppat || oppat.length === 0) {\n        op = '!=';\n        pat = '';\n    }\n    else if (/^\\w*$/.test(pat)) { // just a word\n        op = '==';\n    }\n    else {\n        matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n        if (matches) {\n            op = matches[1];\n            pat = matches[2];\n        }\n    }\n    // set the tester function\n    let tester;\n    // special case a regexp that matches just words\n    if ((op === '~' || op === '!~') && /^(\\w|\\|)*$/.test(pat)) {\n        const inWords = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);\n        tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '@' || op === '!@') {\n        const words = lexer[pat];\n        if (!words) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' is not defined, in rule: ' + ruleName);\n        }\n        if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {\n            throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' must be an array of strings, in rule: ' + ruleName);\n        }\n        const inWords = createKeywordMatcher(words, lexer.ignoreCase);\n        tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };\n    }\n    else if (op === '~' || op === '!~') {\n        if (pat.indexOf('$') < 0) {\n            // precompile regular expression\n            const re = compileRegExp(lexer, '^' + pat + '$');\n            tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };\n        }\n        else {\n            tester = function (s, id, matches, state) {\n                const re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');\n                return re.test(s);\n            };\n        }\n    }\n    else { // if (op==='==' || op==='!=') {\n        if (pat.indexOf('$') < 0) {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s) { return (op === '==' ? s === patx : s !== patx); };\n        }\n        else {\n            const patx = monarchCommon.fixCase(lexer, pat);\n            tester = function (s, id, matches, state, eos) {\n                const patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);\n                return (op === '==' ? s === patexp : s !== patexp);\n            };\n        }\n    }\n    // return the branch object\n    if (scrut === -1) {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                return tester(id, id, matches, state, eos);\n            }\n        };\n    }\n    else {\n        return {\n            name: tkey, value: val, test: function (id, matches, state, eos) {\n                const scrutinee = selectScrutinee(id, matches, state, scrut);\n                return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);\n            }\n        };\n    }\n}\n/**\n * Compiles an action: i.e. optimize regular expressions and case matches\n * and do many sanity checks.\n *\n * This is called only during compilation but if the lexer definition\n * contains user functions as actions (which is usually not allowed), then this\n * may be called during lexing. It is important therefore to compile common cases efficiently\n */\nfunction compileAction(lexer, ruleName, action) {\n    if (!action) {\n        return { token: '' };\n    }\n    else if (typeof (action) === 'string') {\n        return action; // { token: action };\n    }\n    else if (action.token || action.token === '') {\n        if (typeof (action.token) !== 'string') {\n            throw monarchCommon.createError(lexer, 'a \\'token\\' attribute must be of type string, in rule: ' + ruleName);\n        }\n        else {\n            // only copy specific typed fields (only happens once during compile Lexer)\n            const newAction = { token: action.token };\n            if (action.token.indexOf('$') >= 0) {\n                newAction.tokenSubst = true;\n            }\n            if (typeof (action.bracket) === 'string') {\n                if (action.bracket === '@open') {\n                    newAction.bracket = 1 /* Open */;\n                }\n                else if (action.bracket === '@close') {\n                    newAction.bracket = -1 /* Close */;\n                }\n                else {\n                    throw monarchCommon.createError(lexer, 'a \\'bracket\\' attribute must be either \\'@open\\' or \\'@close\\', in rule: ' + ruleName);\n                }\n            }\n            if (action.next) {\n                if (typeof (action.next) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'the next state must be a string value in rule: ' + ruleName);\n                }\n                else {\n                    let next = action.next;\n                    if (!/^(@pop|@push|@popall)$/.test(next)) {\n                        if (next[0] === '@') {\n                            next = next.substr(1); // peel off starting @ sign\n                        }\n                        if (next.indexOf('$') < 0) { // no dollar substitution, we can check if the state exists\n                            if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {\n                                throw monarchCommon.createError(lexer, 'the next state \\'' + action.next + '\\' is not defined in rule: ' + ruleName);\n                            }\n                        }\n                    }\n                    newAction.next = next;\n                }\n            }\n            if (typeof (action.goBack) === 'number') {\n                newAction.goBack = action.goBack;\n            }\n            if (typeof (action.switchTo) === 'string') {\n                newAction.switchTo = action.switchTo;\n            }\n            if (typeof (action.log) === 'string') {\n                newAction.log = action.log;\n            }\n            if (typeof (action.nextEmbedded) === 'string') {\n                newAction.nextEmbedded = action.nextEmbedded;\n                lexer.usesEmbedded = true;\n            }\n            return newAction;\n        }\n    }\n    else if (Array.isArray(action)) {\n        const results = [];\n        for (let i = 0, len = action.length; i < len; i++) {\n            results[i] = compileAction(lexer, ruleName, action[i]);\n        }\n        return { group: results };\n    }\n    else if (action.cases) {\n        // build an array of test cases\n        const cases = [];\n        // for each case, push a test function and result value\n        for (let tkey in action.cases) {\n            if (action.cases.hasOwnProperty(tkey)) {\n                const val = compileAction(lexer, ruleName, action.cases[tkey]);\n                // what kind of case\n                if (tkey === '@default' || tkey === '@' || tkey === '') {\n                    cases.push({ test: undefined, value: val, name: tkey });\n                }\n                else if (tkey === '@eos') {\n                    cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });\n                }\n                else {\n                    cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture\n                }\n            }\n        }\n        // create a matching function\n        const def = lexer.defaultToken;\n        return {\n            test: function (id, matches, state, eos) {\n                for (const _case of cases) {\n                    const didmatch = (!_case.test || _case.test(id, matches, state, eos));\n                    if (didmatch) {\n                        return _case.value;\n                    }\n                }\n                return def;\n            }\n        };\n    }\n    else {\n        throw monarchCommon.createError(lexer, 'an action must be a string, an object with a \\'token\\' or \\'cases\\' attribute, or an array of actions; in rule: ' + ruleName);\n    }\n}\n/**\n * Helper class for creating matching rules\n */\nclass Rule {\n    constructor(name) {\n        this.regex = new RegExp('');\n        this.action = { token: '' };\n        this.matchOnlyAtLineStart = false;\n        this.name = '';\n        this.name = name;\n    }\n    setRegex(lexer, re) {\n        let sregex;\n        if (typeof (re) === 'string') {\n            sregex = re;\n        }\n        else if (re instanceof RegExp) {\n            sregex = re.source;\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'rules must start with a match string or regular expression: ' + this.name);\n        }\n        this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');\n        this.name = this.name + ': ' + sregex;\n        this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');\n    }\n    setAction(lexer, act) {\n        this.action = compileAction(lexer, this.name, act);\n    }\n}\n/**\n * Compiles a json description function into json where all regular expressions,\n * case matches etc, are compiled and all include rules are expanded.\n * We also compile the bracket definitions, supply defaults, and do many sanity checks.\n * If the 'jsonStrict' parameter is 'false', we allow at certain locations\n * regular expression objects and functions that get called during lexing.\n * (Currently we have no samples that need this so perhaps we should always have\n * jsonStrict to true).\n */\nexport function compile(languageId, json) {\n    if (!json || typeof (json) !== 'object') {\n        throw new Error('Monarch: expecting a language definition object');\n    }\n    // Create our lexer\n    const lexer = {};\n    lexer.languageId = languageId;\n    lexer.includeLF = bool(json.includeLF, false);\n    lexer.noThrow = false; // raise exceptions during compilation\n    lexer.maxStack = 100;\n    // Set standard fields: be defensive about types\n    lexer.start = (typeof json.start === 'string' ? json.start : null);\n    lexer.ignoreCase = bool(json.ignoreCase, false);\n    lexer.unicode = bool(json.unicode, false);\n    lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);\n    lexer.defaultToken = string(json.defaultToken, 'source');\n    lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action\n    // For calling compileAction later on\n    const lexerMin = json;\n    lexerMin.languageId = languageId;\n    lexerMin.includeLF = lexer.includeLF;\n    lexerMin.ignoreCase = lexer.ignoreCase;\n    lexerMin.unicode = lexer.unicode;\n    lexerMin.noThrow = lexer.noThrow;\n    lexerMin.usesEmbedded = lexer.usesEmbedded;\n    lexerMin.stateNames = json.tokenizer;\n    lexerMin.defaultToken = lexer.defaultToken;\n    // Compile an array of rules into newrules where RegExp objects are created.\n    function addRules(state, newrules, rules) {\n        for (const rule of rules) {\n            let include = rule.include;\n            if (include) {\n                if (typeof (include) !== 'string') {\n                    throw monarchCommon.createError(lexer, 'an \\'include\\' attribute must be a string at: ' + state);\n                }\n                if (include[0] === '@') {\n                    include = include.substr(1); // peel off starting @\n                }\n                if (!json.tokenizer[include]) {\n                    throw monarchCommon.createError(lexer, 'include target \\'' + include + '\\' is not defined at: ' + state);\n                }\n                addRules(state + '.' + include, newrules, json.tokenizer[include]);\n            }\n            else {\n                const newrule = new Rule(state);\n                // Set up new rule attributes\n                if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n                    newrule.setRegex(lexerMin, rule[0]);\n                    if (rule.length >= 3) {\n                        if (typeof (rule[1]) === 'string') {\n                            newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });\n                        }\n                        else if (typeof (rule[1]) === 'object') {\n                            const rule1 = rule[1];\n                            rule1.next = rule[2];\n                            newrule.setAction(lexerMin, rule1);\n                        }\n                        else {\n                            throw monarchCommon.createError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);\n                        }\n                    }\n                    else {\n                        newrule.setAction(lexerMin, rule[1]);\n                    }\n                }\n                else {\n                    if (!rule.regex) {\n                        throw monarchCommon.createError(lexer, 'a rule must either be an array, or an object with a \\'regex\\' or \\'include\\' field at: ' + state);\n                    }\n                    if (rule.name) {\n                        if (typeof rule.name === 'string') {\n                            newrule.name = rule.name;\n                        }\n                    }\n                    if (rule.matchOnlyAtStart) {\n                        newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n                    }\n                    newrule.setRegex(lexerMin, rule.regex);\n                    newrule.setAction(lexerMin, rule.action);\n                }\n                newrules.push(newrule);\n            }\n        }\n    }\n    // compile the tokenizer rules\n    if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {\n        throw monarchCommon.createError(lexer, 'a language definition must define the \\'tokenizer\\' attribute as an object');\n    }\n    lexer.tokenizer = [];\n    for (let key in json.tokenizer) {\n        if (json.tokenizer.hasOwnProperty(key)) {\n            if (!lexer.start) {\n                lexer.start = key;\n            }\n            const rules = json.tokenizer[key];\n            lexer.tokenizer[key] = new Array();\n            addRules('tokenizer.' + key, lexer.tokenizer[key], rules);\n        }\n    }\n    lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction\n    // Set simple brackets\n    if (json.brackets) {\n        if (!(Array.isArray(json.brackets))) {\n            throw monarchCommon.createError(lexer, 'the \\'brackets\\' attribute must be defined as an array');\n        }\n    }\n    else {\n        json.brackets = [\n            { open: '{', close: '}', token: 'delimiter.curly' },\n            { open: '[', close: ']', token: 'delimiter.square' },\n            { open: '(', close: ')', token: 'delimiter.parenthesis' },\n            { open: '<', close: '>', token: 'delimiter.angle' }\n        ];\n    }\n    const brackets = [];\n    for (let el of json.brackets) {\n        let desc = el;\n        if (desc && Array.isArray(desc) && desc.length === 3) {\n            desc = { token: desc[2], open: desc[0], close: desc[1] };\n        }\n        if (desc.open === desc.close) {\n            throw monarchCommon.createError(lexer, 'open and close brackets in a \\'brackets\\' attribute must be different: ' + desc.open +\n                '\\n hint: use the \\'bracket\\' attribute if matching on equal brackets is required.');\n        }\n        if (typeof desc.open === 'string' && typeof desc.token === 'string' && typeof desc.close === 'string') {\n            brackets.push({\n                token: desc.token + lexer.tokenPostfix,\n                open: monarchCommon.fixCase(lexer, desc.open),\n                close: monarchCommon.fixCase(lexer, desc.close)\n            });\n        }\n        else {\n            throw monarchCommon.createError(lexer, 'every element in the \\'brackets\\' array must be a \\'{open,close,token}\\' object or array');\n        }\n    }\n    lexer.brackets = brackets;\n    // Disable throw so the syntax highlighter goes, no matter what\n    lexer.noThrow = true;\n    return lexer;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Color } from '../../../base/common/color.js';\nimport { Range } from '../../common/core/range.js';\nimport * as languages from '../../common/languages.js';\nimport { LanguageConfigurationRegistry } from '../../common/languages/languageConfigurationRegistry.js';\nimport { ModesRegistry } from '../../common/languages/modesRegistry.js';\nimport { ILanguageService } from '../../common/languages/language.js';\nimport * as standaloneEnums from '../../common/standalone/standaloneEnums.js';\nimport { StandaloneServices } from './standaloneServices.js';\nimport { compile } from '../common/monarch/monarchCompile.js';\nimport { MonarchTokenizer } from '../common/monarch/monarchLexer.js';\nimport { IStandaloneThemeService } from '../common/standaloneTheme.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { ILanguageFeaturesService } from '../../common/services/languageFeatures.js';\n/**\n * Register information about a new language.\n */\nexport function register(language) {\n    ModesRegistry.registerLanguage(language);\n}\n/**\n * Get the information of all the registered languages.\n */\nexport function getLanguages() {\n    let result = [];\n    result = result.concat(ModesRegistry.getLanguages());\n    return result;\n}\nexport function getEncodedLanguageId(languageId) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    return languageService.languageIdCodec.encodeLanguageId(languageId);\n}\n/**\n * An event emitted when a language is needed for the first time (e.g. a model has it set).\n * @event\n */\nexport function onLanguage(languageId, callback) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    const disposable = languageService.onDidEncounterLanguage((encounteredLanguageId) => {\n        if (encounteredLanguageId === languageId) {\n            // stop listening\n            disposable.dispose();\n            // invoke actual listener\n            callback();\n        }\n    });\n    return disposable;\n}\n/**\n * Set the editing configuration for a language.\n */\nexport function setLanguageConfiguration(languageId, configuration) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    if (!languageService.isRegisteredLanguageId(languageId)) {\n        throw new Error(`Cannot set configuration for unknown language ${languageId}`);\n    }\n    return LanguageConfigurationRegistry.register(languageId, configuration, 100);\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationSupportAdapter {\n    constructor(languageId, actual) {\n        this._languageId = languageId;\n        this._actual = actual;\n    }\n    getInitialState() {\n        return this._actual.getInitialState();\n    }\n    tokenize(line, hasEOL, state) {\n        if (typeof this._actual.tokenize === 'function') {\n            return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);\n        }\n        throw new Error('Not supported!');\n    }\n    tokenizeEncoded(line, hasEOL, state) {\n        const result = this._actual.tokenizeEncoded(line, state);\n        return new languages.EncodedTokenizationResult(result.tokens, result.endState);\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationSupportAdapter {\n    constructor(_languageId, _actual, _languageService, _standaloneThemeService) {\n        this._languageId = _languageId;\n        this._actual = _actual;\n        this._languageService = _languageService;\n        this._standaloneThemeService = _standaloneThemeService;\n    }\n    getInitialState() {\n        return this._actual.getInitialState();\n    }\n    static _toClassicTokens(tokens, language) {\n        const result = [];\n        let previousStartIndex = 0;\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const t = tokens[i];\n            let startIndex = t.startIndex;\n            // Prevent issues stemming from a buggy external tokenizer.\n            if (i === 0) {\n                // Force first token to start at first index!\n                startIndex = 0;\n            }\n            else if (startIndex < previousStartIndex) {\n                // Force tokens to be after one another!\n                startIndex = previousStartIndex;\n            }\n            result[i] = new languages.Token(startIndex, t.scopes, language);\n            previousStartIndex = startIndex;\n        }\n        return result;\n    }\n    static adaptTokenize(language, actual, line, state) {\n        const actualResult = actual.tokenize(line, state);\n        const tokens = TokenizationSupportAdapter._toClassicTokens(actualResult.tokens, language);\n        let endState;\n        // try to save an object if possible\n        if (actualResult.endState.equals(state)) {\n            endState = state;\n        }\n        else {\n            endState = actualResult.endState;\n        }\n        return new languages.TokenizationResult(tokens, endState);\n    }\n    tokenize(line, hasEOL, state) {\n        return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);\n    }\n    _toBinaryTokens(languageIdCodec, tokens) {\n        const languageId = languageIdCodec.encodeLanguageId(this._languageId);\n        const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;\n        const result = [];\n        let resultLen = 0;\n        let previousStartIndex = 0;\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const t = tokens[i];\n            const metadata = tokenTheme.match(languageId, t.scopes);\n            if (resultLen > 0 && result[resultLen - 1] === metadata) {\n                // same metadata\n                continue;\n            }\n            let startIndex = t.startIndex;\n            // Prevent issues stemming from a buggy external tokenizer.\n            if (i === 0) {\n                // Force first token to start at first index!\n                startIndex = 0;\n            }\n            else if (startIndex < previousStartIndex) {\n                // Force tokens to be after one another!\n                startIndex = previousStartIndex;\n            }\n            result[resultLen++] = startIndex;\n            result[resultLen++] = metadata;\n            previousStartIndex = startIndex;\n        }\n        const actualResult = new Uint32Array(resultLen);\n        for (let i = 0; i < resultLen; i++) {\n            actualResult[i] = result[i];\n        }\n        return actualResult;\n    }\n    tokenizeEncoded(line, hasEOL, state) {\n        const actualResult = this._actual.tokenize(line, state);\n        const tokens = this._toBinaryTokens(this._languageService.languageIdCodec, actualResult.tokens);\n        let endState;\n        // try to save an object if possible\n        if (actualResult.endState.equals(state)) {\n            endState = state;\n        }\n        else {\n            endState = actualResult.endState;\n        }\n        return new languages.EncodedTokenizationResult(tokens, endState);\n    }\n}\nfunction isATokensProvider(provider) {\n    return (typeof provider.getInitialState === 'function');\n}\nfunction isEncodedTokensProvider(provider) {\n    return 'tokenizeEncoded' in provider;\n}\nfunction isThenable(obj) {\n    return obj && typeof obj.then === 'function';\n}\n/**\n * Change the color map that is used for token colors.\n * Supported formats (hex): #RRGGBB, $RRGGBBAA, #RGB, #RGBA\n */\nexport function setColorMap(colorMap) {\n    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);\n    if (colorMap) {\n        const result = [null];\n        for (let i = 1, len = colorMap.length; i < len; i++) {\n            result[i] = Color.fromHex(colorMap[i]);\n        }\n        standaloneThemeService.setColorMapOverride(result);\n    }\n    else {\n        standaloneThemeService.setColorMapOverride(null);\n    }\n}\n/**\n * @internal\n */\nfunction createTokenizationSupportAdapter(languageId, provider) {\n    if (isEncodedTokensProvider(provider)) {\n        return new EncodedTokenizationSupportAdapter(languageId, provider);\n    }\n    else {\n        return new TokenizationSupportAdapter(languageId, provider, StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService));\n    }\n}\n/**\n * Register a tokens provider factory for a language. This tokenizer will be exclusive with a tokenizer\n * set using `setTokensProvider` or one created using `setMonarchTokensProvider`, but will work together\n * with a tokens provider set using `registerDocumentSemanticTokensProvider` or `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function registerTokensProviderFactory(languageId, factory) {\n    const adaptedFactory = {\n        createTokenizationSupport: () => __awaiter(this, void 0, void 0, function* () {\n            const result = yield Promise.resolve(factory.create());\n            if (!result) {\n                return null;\n            }\n            if (isATokensProvider(result)) {\n                return createTokenizationSupportAdapter(languageId, result);\n            }\n            return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, result));\n        })\n    };\n    return languages.TokenizationRegistry.registerFactory(languageId, adaptedFactory);\n}\n/**\n * Set the tokens provider for a language (manual implementation). This tokenizer will be exclusive\n * with a tokenizer created using `setMonarchTokensProvider`, or with `registerTokensProviderFactory`,\n * but will work together with a tokens provider set using `registerDocumentSemanticTokensProvider`\n * or `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function setTokensProvider(languageId, provider) {\n    const languageService = StandaloneServices.get(ILanguageService);\n    if (!languageService.isRegisteredLanguageId(languageId)) {\n        throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);\n    }\n    if (isThenable(provider)) {\n        return registerTokensProviderFactory(languageId, { create: () => provider });\n    }\n    return languages.TokenizationRegistry.register(languageId, createTokenizationSupportAdapter(languageId, provider));\n}\n/**\n * Set the tokens provider for a language (monarch implementation). This tokenizer will be exclusive\n * with a tokenizer set using `setTokensProvider`, or with `registerTokensProviderFactory`, but will\n * work together with a tokens provider set using `registerDocumentSemanticTokensProvider` or\n * `registerDocumentRangeSemanticTokensProvider`.\n */\nexport function setMonarchTokensProvider(languageId, languageDef) {\n    const create = (languageDef) => {\n        return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, languageDef));\n    };\n    if (isThenable(languageDef)) {\n        return registerTokensProviderFactory(languageId, { create: () => languageDef });\n    }\n    return languages.TokenizationRegistry.register(languageId, create(languageDef));\n}\n/**\n * Register a reference provider (used by e.g. reference search).\n */\nexport function registerReferenceProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.referenceProvider.register(languageSelector, provider);\n}\n/**\n * Register a rename provider (used by e.g. rename symbol).\n */\nexport function registerRenameProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.renameProvider.register(languageSelector, provider);\n}\n/**\n * Register a signature help provider (used by e.g. parameter hints).\n */\nexport function registerSignatureHelpProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.signatureHelpProvider.register(languageSelector, provider);\n}\n/**\n * Register a hover provider (used by e.g. editor hover).\n */\nexport function registerHoverProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.hoverProvider.register(languageSelector, {\n        provideHover: (model, position, token) => {\n            const word = model.getWordAtPosition(position);\n            return Promise.resolve(provider.provideHover(model, position, token)).then((value) => {\n                if (!value) {\n                    return undefined;\n                }\n                if (!value.range && word) {\n                    value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);\n                }\n                if (!value.range) {\n                    value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);\n                }\n                return value;\n            });\n        }\n    });\n}\n/**\n * Register a document symbol provider (used by e.g. outline).\n */\nexport function registerDocumentSymbolProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentSymbolProvider.register(languageSelector, provider);\n}\n/**\n * Register a document highlight provider (used by e.g. highlight occurrences).\n */\nexport function registerDocumentHighlightProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentHighlightProvider.register(languageSelector, provider);\n}\n/**\n * Register an linked editing range provider.\n */\nexport function registerLinkedEditingRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.linkedEditingRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a definition provider (used by e.g. go to definition).\n */\nexport function registerDefinitionProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.definitionProvider.register(languageSelector, provider);\n}\n/**\n * Register a implementation provider (used by e.g. go to implementation).\n */\nexport function registerImplementationProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.implementationProvider.register(languageSelector, provider);\n}\n/**\n * Register a type definition provider (used by e.g. go to type definition).\n */\nexport function registerTypeDefinitionProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.typeDefinitionProvider.register(languageSelector, provider);\n}\n/**\n * Register a code lens provider (used by e.g. inline code lenses).\n */\nexport function registerCodeLensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.codeLensProvider.register(languageSelector, provider);\n}\n/**\n * Register a code action provider (used by e.g. quick fix).\n */\nexport function registerCodeActionProvider(languageSelector, provider, metadata) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.codeActionProvider.register(languageSelector, {\n        providedCodeActionKinds: metadata === null || metadata === void 0 ? void 0 : metadata.providedCodeActionKinds,\n        provideCodeActions: (model, range, context, token) => {\n            const markerService = StandaloneServices.get(IMarkerService);\n            const markers = markerService.read({ resource: model.uri }).filter(m => {\n                return Range.areIntersectingOrTouching(m, range);\n            });\n            return provider.provideCodeActions(model, range, { markers, only: context.only }, token);\n        },\n        resolveCodeAction: provider.resolveCodeAction\n    });\n}\n/**\n * Register a formatter that can handle only entire models.\n */\nexport function registerDocumentFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a formatter that can handle a range inside a model.\n */\nexport function registerDocumentRangeFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentRangeFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a formatter than can do formatting as the user types.\n */\nexport function registerOnTypeFormattingEditProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.onTypeFormattingEditProvider.register(languageSelector, provider);\n}\n/**\n * Register a link provider that can find links in text.\n */\nexport function registerLinkProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.linkProvider.register(languageSelector, provider);\n}\n/**\n * Register a completion item provider (use by e.g. suggestions).\n */\nexport function registerCompletionItemProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.completionProvider.register(languageSelector, provider);\n}\n/**\n * Register a document color provider (used by Color Picker, Color Decorator).\n */\nexport function registerColorProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.colorProvider.register(languageSelector, provider);\n}\n/**\n * Register a folding range provider\n */\nexport function registerFoldingRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.foldingRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a declaration provider\n */\nexport function registerDeclarationProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.declarationProvider.register(languageSelector, provider);\n}\n/**\n * Register a selection range provider\n */\nexport function registerSelectionRangeProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.selectionRangeProvider.register(languageSelector, provider);\n}\n/**\n * Register a document semantic tokens provider. A semantic tokens provider will complement and enhance a\n * simple top-down tokenizer. Simple top-down tokenizers can be set either via `setMonarchTokensProvider`\n * or `setTokensProvider`.\n *\n * For the best user experience, register both a semantic tokens provider and a top-down tokenizer.\n */\nexport function registerDocumentSemanticTokensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentSemanticTokensProvider.register(languageSelector, provider);\n}\n/**\n * Register a document range semantic tokens provider. A semantic tokens provider will complement and enhance a\n * simple top-down tokenizer. Simple top-down tokenizers can be set either via `setMonarchTokensProvider`\n * or `setTokensProvider`.\n *\n * For the best user experience, register both a semantic tokens provider and a top-down tokenizer.\n */\nexport function registerDocumentRangeSemanticTokensProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.documentRangeSemanticTokensProvider.register(languageSelector, provider);\n}\n/**\n * Register an inline completions provider.\n */\nexport function registerInlineCompletionsProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.inlineCompletionsProvider.register(languageSelector, provider);\n}\n/**\n * Register an inlay hints provider.\n */\nexport function registerInlayHintsProvider(languageSelector, provider) {\n    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);\n    return languageFeaturesService.inlayHintsProvider.register(languageSelector, provider);\n}\n/**\n * @internal\n */\nexport function createMonacoLanguagesAPI() {\n    return {\n        register: register,\n        getLanguages: getLanguages,\n        onLanguage: onLanguage,\n        getEncodedLanguageId: getEncodedLanguageId,\n        // provider methods\n        setLanguageConfiguration: setLanguageConfiguration,\n        setColorMap: setColorMap,\n        registerTokensProviderFactory: registerTokensProviderFactory,\n        setTokensProvider: setTokensProvider,\n        setMonarchTokensProvider: setMonarchTokensProvider,\n        registerReferenceProvider: registerReferenceProvider,\n        registerRenameProvider: registerRenameProvider,\n        registerCompletionItemProvider: registerCompletionItemProvider,\n        registerSignatureHelpProvider: registerSignatureHelpProvider,\n        registerHoverProvider: registerHoverProvider,\n        registerDocumentSymbolProvider: registerDocumentSymbolProvider,\n        registerDocumentHighlightProvider: registerDocumentHighlightProvider,\n        registerLinkedEditingRangeProvider: registerLinkedEditingRangeProvider,\n        registerDefinitionProvider: registerDefinitionProvider,\n        registerImplementationProvider: registerImplementationProvider,\n        registerTypeDefinitionProvider: registerTypeDefinitionProvider,\n        registerCodeLensProvider: registerCodeLensProvider,\n        registerCodeActionProvider: registerCodeActionProvider,\n        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,\n        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,\n        registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,\n        registerLinkProvider: registerLinkProvider,\n        registerColorProvider: registerColorProvider,\n        registerFoldingRangeProvider: registerFoldingRangeProvider,\n        registerDeclarationProvider: registerDeclarationProvider,\n        registerSelectionRangeProvider: registerSelectionRangeProvider,\n        registerDocumentSemanticTokensProvider: registerDocumentSemanticTokensProvider,\n        registerDocumentRangeSemanticTokensProvider: registerDocumentRangeSemanticTokensProvider,\n        registerInlineCompletionsProvider: registerInlineCompletionsProvider,\n        registerInlayHintsProvider: registerInlayHintsProvider,\n        // enums\n        DocumentHighlightKind: standaloneEnums.DocumentHighlightKind,\n        CompletionItemKind: standaloneEnums.CompletionItemKind,\n        CompletionItemTag: standaloneEnums.CompletionItemTag,\n        CompletionItemInsertTextRule: standaloneEnums.CompletionItemInsertTextRule,\n        SymbolKind: standaloneEnums.SymbolKind,\n        SymbolTag: standaloneEnums.SymbolTag,\n        IndentAction: standaloneEnums.IndentAction,\n        CompletionTriggerKind: standaloneEnums.CompletionTriggerKind,\n        SignatureHelpTriggerKind: standaloneEnums.SignatureHelpTriggerKind,\n        InlayHintKind: standaloneEnums.InlayHintKind,\n        InlineCompletionTriggerKind: standaloneEnums.InlineCompletionTriggerKind,\n        // classes\n        FoldingRangeKind: languages.FoldingRangeKind,\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { EditorOptions } from './common/config/editorOptions.js';\nimport { createMonacoBaseAPI } from './common/services/editorBaseApi.js';\nimport { createMonacoEditorAPI } from './standalone/browser/standaloneEditor.js';\nimport { createMonacoLanguagesAPI } from './standalone/browser/standaloneLanguages.js';\nimport { globals } from '../base/common/platform.js';\nimport { FormattingConflicts } from './contrib/format/browser/format.js';\n// Set defaults for standalone editor\nEditorOptions.wrappingIndent.defaultValue = 0 /* None */;\nEditorOptions.glyphMargin.defaultValue = false;\nEditorOptions.autoIndent.defaultValue = 3 /* Advanced */;\nEditorOptions.overviewRulerLanes.defaultValue = 2;\n// We need to register a formatter selector which simply picks the first available formatter.\n// See https://github.com/microsoft/monaco-editor/issues/2327\nFormattingConflicts.setFormatterSelector((formatter, document, mode) => Promise.resolve(formatter[0]));\nconst api = createMonacoBaseAPI();\napi.editor = createMonacoEditorAPI();\napi.languages = createMonacoLanguagesAPI();\nexport const CancellationTokenSource = api.CancellationTokenSource;\nexport const Emitter = api.Emitter;\nexport const KeyCode = api.KeyCode;\nexport const KeyMod = api.KeyMod;\nexport const Position = api.Position;\nexport const Range = api.Range;\nexport const Selection = api.Selection;\nexport const SelectionDirection = api.SelectionDirection;\nexport const MarkerSeverity = api.MarkerSeverity;\nexport const MarkerTag = api.MarkerTag;\nexport const Uri = api.Uri;\nexport const Token = api.Token;\nexport const editor = api.editor;\nexport const languages = api.languages;\nif (((_a = globals.MonacoEnvironment) === null || _a === void 0 ? void 0 : _a.globalAPI) || (typeof define === 'function' && define.amd)) {\n    self.monaco = api;\n}\nif (typeof self.require !== 'undefined' && typeof self.require.config === 'function') {\n    self.require.config({\n        ignoreDuplicateModules: [\n            'vscode-languageserver-types',\n            'vscode-languageserver-types/main',\n            'vscode-languageserver-textdocument',\n            'vscode-languageserver-textdocument/main',\n            'vscode-nls',\n            'vscode-nls/vscode-nls',\n            'jsonc-parser',\n            'jsonc-parser/main',\n            'vscode-uri',\n            'vscode-uri/index',\n            'vs/basic-languages/typescript/typescript'\n        ]\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './accessibilityHelp.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { renderFormattedText } from '../../../../base/browser/formattedTextRenderer.js';\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { Widget } from '../../../../base/browser/ui/widget.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ToggleTabFocusModeAction } from '../../../contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { IOpenerService } from '../../../../platform/opener/common/opener.js';\nimport { contrastBorder, editorWidgetBackground, widgetShadow, editorWidgetForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { AccessibilityHelpNLS } from '../../../common/standaloneStrings.js';\nconst CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey('accessibilityHelpWidgetVisible', false);\nlet AccessibilityHelpController = class AccessibilityHelpController extends Disposable {\n    constructor(editor, instantiationService) {\n        super();\n        this._editor = editor;\n        this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));\n    }\n    static get(editor) {\n        return editor.getContribution(AccessibilityHelpController.ID);\n    }\n    show() {\n        this._widget.show();\n    }\n    hide() {\n        this._widget.hide();\n    }\n};\nAccessibilityHelpController.ID = 'editor.contrib.accessibilityHelpController';\nAccessibilityHelpController = __decorate([\n    __param(1, IInstantiationService)\n], AccessibilityHelpController);\nfunction getSelectionLabel(selections, charactersSelected) {\n    if (!selections || selections.length === 0) {\n        return AccessibilityHelpNLS.noSelection;\n    }\n    if (selections.length === 1) {\n        if (charactersSelected) {\n            return strings.format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);\n        }\n        return strings.format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);\n    }\n    if (charactersSelected) {\n        return strings.format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);\n    }\n    if (selections.length > 0) {\n        return strings.format(AccessibilityHelpNLS.multiSelection, selections.length);\n    }\n    return '';\n}\nlet AccessibilityHelpWidget = class AccessibilityHelpWidget extends Widget {\n    constructor(editor, _contextKeyService, _keybindingService, _openerService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._keybindingService = _keybindingService;\n        this._openerService = _openerService;\n        this._editor = editor;\n        this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        this._domNode.setClassName('accessibilityHelpWidget');\n        this._domNode.setDisplay('none');\n        this._domNode.setAttribute('role', 'dialog');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._contentDomNode = createFastDomNode(document.createElement('div'));\n        this._contentDomNode.setAttribute('role', 'document');\n        this._domNode.appendChild(this._contentDomNode);\n        this._isVisible = false;\n        this._register(this._editor.onDidLayoutChange(() => {\n            if (this._isVisible) {\n                this._layout();\n            }\n        }));\n        // Intentionally not configurable!\n        this._register(dom.addStandardDisposableListener(this._contentDomNode.domNode, 'keydown', (e) => {\n            if (!this._isVisible) {\n                return;\n            }\n            if (e.equals(2048 /* CtrlCmd */ | 35 /* KeyE */)) {\n                alert(AccessibilityHelpNLS.emergencyConfOn);\n                this._editor.updateOptions({\n                    accessibilitySupport: 'on'\n                });\n                dom.clearNode(this._contentDomNode.domNode);\n                this._buildContent();\n                this._contentDomNode.domNode.focus();\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            if (e.equals(2048 /* CtrlCmd */ | 38 /* KeyH */)) {\n                alert(AccessibilityHelpNLS.openingDocs);\n                let url = this._editor.getRawOptions().accessibilityHelpUrl;\n                if (typeof url === 'undefined') {\n                    url = 'https://go.microsoft.com/fwlink/?linkid=852450';\n                }\n                this._openerService.open(URI.parse(url));\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }));\n        this.onblur(this._contentDomNode.domNode, () => {\n            this.hide();\n        });\n        this._editor.addOverlayWidget(this);\n    }\n    dispose() {\n        this._editor.removeOverlayWidget(this);\n        super.dispose();\n    }\n    getId() {\n        return AccessibilityHelpWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode.domNode;\n    }\n    getPosition() {\n        return {\n            preference: null\n        };\n    }\n    show() {\n        if (this._isVisible) {\n            return;\n        }\n        this._isVisible = true;\n        this._isVisibleKey.set(true);\n        this._layout();\n        this._domNode.setDisplay('block');\n        this._domNode.setAttribute('aria-hidden', 'false');\n        this._contentDomNode.domNode.tabIndex = 0;\n        this._buildContent();\n        this._contentDomNode.domNode.focus();\n    }\n    _descriptionForCommand(commandId, msg, noKbMsg) {\n        const kb = this._keybindingService.lookupKeybinding(commandId);\n        if (kb) {\n            return strings.format(msg, kb.getAriaLabel());\n        }\n        return strings.format(noKbMsg, commandId);\n    }\n    _buildContent() {\n        const options = this._editor.getOptions();\n        const selections = this._editor.getSelections();\n        let charactersSelected = 0;\n        if (selections) {\n            const model = this._editor.getModel();\n            if (model) {\n                selections.forEach((selection) => {\n                    charactersSelected += model.getValueLengthInRange(selection);\n                });\n            }\n        }\n        let text = getSelectionLabel(selections, charactersSelected);\n        if (options.get(54 /* inDiffEditor */)) {\n            if (options.get(81 /* readOnly */)) {\n                text += AccessibilityHelpNLS.readonlyDiffEditor;\n            }\n            else {\n                text += AccessibilityHelpNLS.editableDiffEditor;\n            }\n        }\n        else {\n            if (options.get(81 /* readOnly */)) {\n                text += AccessibilityHelpNLS.readonlyEditor;\n            }\n            else {\n                text += AccessibilityHelpNLS.editableEditor;\n            }\n        }\n        const turnOnMessage = (platform.isMacintosh\n            ? AccessibilityHelpNLS.changeConfigToOnMac\n            : AccessibilityHelpNLS.changeConfigToOnWinLinux);\n        switch (options.get(2 /* accessibilitySupport */)) {\n            case 0 /* Unknown */:\n                text += '\\n\\n - ' + turnOnMessage;\n                break;\n            case 2 /* Enabled */:\n                text += '\\n\\n - ' + AccessibilityHelpNLS.auto_on;\n                break;\n            case 1 /* Disabled */:\n                text += '\\n\\n - ' + AccessibilityHelpNLS.auto_off;\n                text += ' ' + turnOnMessage;\n                break;\n        }\n        if (options.get(130 /* tabFocusMode */)) {\n            text += '\\n\\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);\n        }\n        else {\n            text += '\\n\\n - ' + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);\n        }\n        const openDocMessage = (platform.isMacintosh\n            ? AccessibilityHelpNLS.openDocMac\n            : AccessibilityHelpNLS.openDocWinLinux);\n        text += '\\n\\n - ' + openDocMessage;\n        text += '\\n\\n' + AccessibilityHelpNLS.outroMsg;\n        this._contentDomNode.domNode.appendChild(renderFormattedText(text));\n        // Per https://www.w3.org/TR/wai-aria/roles#document, Authors SHOULD provide a title or label for documents\n        this._contentDomNode.domNode.setAttribute('aria-label', text);\n    }\n    hide() {\n        if (!this._isVisible) {\n            return;\n        }\n        this._isVisible = false;\n        this._isVisibleKey.reset();\n        this._domNode.setDisplay('none');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._contentDomNode.domNode.tabIndex = -1;\n        dom.clearNode(this._contentDomNode.domNode);\n        this._editor.focus();\n    }\n    _layout() {\n        const editorLayout = this._editor.getLayoutInfo();\n        const w = Math.max(5, Math.min(AccessibilityHelpWidget.WIDTH, editorLayout.width - 40));\n        const h = Math.max(5, Math.min(AccessibilityHelpWidget.HEIGHT, editorLayout.height - 40));\n        this._domNode.setWidth(w);\n        this._domNode.setHeight(h);\n        const top = Math.round((editorLayout.height - h) / 2);\n        this._domNode.setTop(top);\n        const left = Math.round((editorLayout.width - w) / 2);\n        this._domNode.setLeft(left);\n    }\n};\nAccessibilityHelpWidget.ID = 'editor.contrib.accessibilityHelpWidget';\nAccessibilityHelpWidget.WIDTH = 500;\nAccessibilityHelpWidget.HEIGHT = 300;\nAccessibilityHelpWidget = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, IKeybindingService),\n    __param(3, IOpenerService)\n], AccessibilityHelpWidget);\nclass ShowAccessibilityHelpAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.showAccessibilityHelp',\n            label: AccessibilityHelpNLS.showAccessibilityHelpAction,\n            alias: 'Show Accessibility Help',\n            precondition: undefined,\n            kbOpts: {\n                primary: 512 /* Alt */ | 59 /* F1 */,\n                weight: 100 /* EditorContrib */,\n                linux: {\n                    primary: 512 /* Alt */ | 1024 /* Shift */ | 59 /* F1 */,\n                    secondary: [512 /* Alt */ | 59 /* F1 */]\n                }\n            }\n        });\n    }\n    run(accessor, editor) {\n        const controller = AccessibilityHelpController.get(editor);\n        if (controller) {\n            controller.show();\n        }\n    }\n}\nregisterEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);\nregisterEditorAction(ShowAccessibilityHelpAction);\nconst AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);\nregisterEditorCommand(new AccessibilityHelpCommand({\n    id: 'closeAccessibilityHelp',\n    precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,\n    handler: x => x.hide(),\n    kbOpts: {\n        weight: 100 /* EditorContrib */ + 100,\n        kbExpr: EditorContextKeys.focus,\n        primary: 9 /* Escape */,\n        secondary: [1024 /* Shift */ | 9 /* Escape */]\n    }\n}));\nregisterThemingParticipant((theme, collector) => {\n    const widgetBackground = theme.getColor(editorWidgetBackground);\n    if (widgetBackground) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);\n    }\n    const widgetForeground = theme.getColor(editorWidgetForeground);\n    if (widgetForeground) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);\n    }\n    const widgetShadowColor = theme.getColor(widgetShadow);\n    if (widgetShadowColor) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);\n    }\n    const hcBorder = theme.getColor(contrastBorder);\n    if (hcBorder) {\n        collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './iPadShowKeyboard.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { isIOS } from '../../../../base/common/platform.js';\nexport class IPadShowKeyboard extends Disposable {\n    constructor(editor) {\n        super();\n        this.editor = editor;\n        this.widget = null;\n        if (isIOS) {\n            this._register(editor.onDidChangeConfiguration(() => this.update()));\n            this.update();\n        }\n    }\n    update() {\n        const shouldHaveWidget = (!this.editor.getOption(81 /* readOnly */));\n        if (!this.widget && shouldHaveWidget) {\n            this.widget = new ShowKeyboardWidget(this.editor);\n        }\n        else if (this.widget && !shouldHaveWidget) {\n            this.widget.dispose();\n            this.widget = null;\n        }\n    }\n    dispose() {\n        super.dispose();\n        if (this.widget) {\n            this.widget.dispose();\n            this.widget = null;\n        }\n    }\n}\nIPadShowKeyboard.ID = 'editor.contrib.iPadShowKeyboard';\nclass ShowKeyboardWidget extends Disposable {\n    constructor(editor) {\n        super();\n        this.editor = editor;\n        this._domNode = document.createElement('textarea');\n        this._domNode.className = 'iPadShowKeyboard';\n        this._register(dom.addDisposableListener(this._domNode, 'touchstart', (e) => {\n            this.editor.focus();\n        }));\n        this._register(dom.addDisposableListener(this._domNode, 'focus', (e) => {\n            this.editor.focus();\n        }));\n        this.editor.addOverlayWidget(this);\n    }\n    dispose() {\n        this.editor.removeOverlayWidget(this);\n        super.dispose();\n    }\n    // ----- IOverlayWidget API\n    getId() {\n        return ShowKeyboardWidget.ID;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        return {\n            preference: 1 /* BOTTOM_RIGHT_CORNER */\n        };\n    }\n}\nShowKeyboardWidget.ID = 'editor.contrib.ShowKeyboardWidget';\nregisterEditorContribution(IPadShowKeyboard.ID, IPadShowKeyboard);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './inspectTokens.css';\nimport { $, append, reset } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { TokenMetadata, TokenizationRegistry } from '../../../common/languages.js';\nimport { NullState, nullTokenize, nullTokenizeEncoded } from '../../../common/languages/nullTokenize.js';\nimport { ILanguageService } from '../../../common/languages/language.js';\nimport { IStandaloneThemeService } from '../../common/standaloneTheme.js';\nimport { editorHoverBackground, editorHoverBorder, editorHoverForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { InspectTokensNLS } from '../../../common/standaloneStrings.js';\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\nlet InspectTokensController = class InspectTokensController extends Disposable {\n    constructor(editor, standaloneColorService, languageService) {\n        super();\n        this._editor = editor;\n        this._languageService = languageService;\n        this._widget = null;\n        this._register(this._editor.onDidChangeModel((e) => this.stop()));\n        this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));\n        this._register(TokenizationRegistry.onDidChange((e) => this.stop()));\n        this._register(this._editor.onKeyUp((e) => e.keyCode === 9 /* Escape */ && this.stop()));\n    }\n    static get(editor) {\n        return editor.getContribution(InspectTokensController.ID);\n    }\n    dispose() {\n        this.stop();\n        super.dispose();\n    }\n    launch() {\n        if (this._widget) {\n            return;\n        }\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._widget = new InspectTokensWidget(this._editor, this._languageService);\n    }\n    stop() {\n        if (this._widget) {\n            this._widget.dispose();\n            this._widget = null;\n        }\n    }\n};\nInspectTokensController.ID = 'editor.contrib.inspectTokens';\nInspectTokensController = __decorate([\n    __param(1, IStandaloneThemeService),\n    __param(2, ILanguageService)\n], InspectTokensController);\nclass InspectTokens extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.inspectTokens',\n            label: InspectTokensNLS.inspectTokensAction,\n            alias: 'Developer: Inspect Tokens',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        const controller = InspectTokensController.get(editor);\n        if (controller) {\n            controller.launch();\n        }\n    }\n}\nfunction renderTokenText(tokenText) {\n    let result = '';\n    for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {\n        const charCode = tokenText.charCodeAt(charIndex);\n        switch (charCode) {\n            case 9 /* Tab */:\n                result += '\\u2192'; // &rarr;\n                break;\n            case 32 /* Space */:\n                result += '\\u00B7'; // &middot;\n                break;\n            default:\n                result += String.fromCharCode(charCode);\n        }\n    }\n    return result;\n}\nfunction getSafeTokenizationSupport(languageIdCodec, languageId) {\n    const tokenizationSupport = TokenizationRegistry.get(languageId);\n    if (tokenizationSupport) {\n        return tokenizationSupport;\n    }\n    const encodedLanguageId = languageIdCodec.encodeLanguageId(languageId);\n    return {\n        getInitialState: () => NullState,\n        tokenize: (line, hasEOL, state) => nullTokenize(languageId, state),\n        tokenizeEncoded: (line, hasEOL, state) => nullTokenizeEncoded(encodedLanguageId, state)\n    };\n}\nclass InspectTokensWidget extends Disposable {\n    constructor(editor, languageService) {\n        super();\n        // Editor.IContentWidget.allowEditorOverflow\n        this.allowEditorOverflow = true;\n        this._editor = editor;\n        this._languageService = languageService;\n        this._model = this._editor.getModel();\n        this._domNode = document.createElement('div');\n        this._domNode.className = 'tokens-inspect-widget';\n        this._tokenizationSupport = getSafeTokenizationSupport(this._languageService.languageIdCodec, this._model.getLanguageId());\n        this._compute(this._editor.getPosition());\n        this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));\n        this._editor.addContentWidget(this);\n    }\n    dispose() {\n        this._editor.removeContentWidget(this);\n        super.dispose();\n    }\n    getId() {\n        return InspectTokensWidget._ID;\n    }\n    _compute(position) {\n        const data = this._getTokensAtLine(position.lineNumber);\n        let token1Index = 0;\n        for (let i = data.tokens1.length - 1; i >= 0; i--) {\n            const t = data.tokens1[i];\n            if (position.column - 1 >= t.offset) {\n                token1Index = i;\n                break;\n            }\n        }\n        let token2Index = 0;\n        for (let i = (data.tokens2.length >>> 1); i >= 0; i--) {\n            if (position.column - 1 >= data.tokens2[(i << 1)]) {\n                token2Index = i;\n                break;\n            }\n        }\n        const lineContent = this._model.getLineContent(position.lineNumber);\n        let tokenText = '';\n        if (token1Index < data.tokens1.length) {\n            const tokenStartIndex = data.tokens1[token1Index].offset;\n            const tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;\n            tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);\n        }\n        reset(this._domNode, $('h2.tm-token', undefined, renderTokenText(tokenText), $('span.tm-token-length', undefined, `${tokenText.length} ${tokenText.length === 1 ? 'char' : 'chars'}`)));\n        append(this._domNode, $('hr.tokens-inspect-separator', { 'style': 'clear:both' }));\n        const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;\n        append(this._domNode, $('table.tm-metadata-table', undefined, $('tbody', undefined, $('tr', undefined, $('td.tm-metadata-key', undefined, 'language'), $('td.tm-metadata-value', undefined, `${metadata ? metadata.languageId : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'token type'), $('td.tm-metadata-value', undefined, `${metadata ? this._tokenTypeToString(metadata.tokenType) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'font style'), $('td.tm-metadata-value', undefined, `${metadata ? this._fontStyleToString(metadata.fontStyle) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'foreground'), $('td.tm-metadata-value', undefined, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : '-?-'}`)), $('tr', undefined, $('td.tm-metadata-key', undefined, 'background'), $('td.tm-metadata-value', undefined, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : '-?-'}`)))));\n        append(this._domNode, $('hr.tokens-inspect-separator'));\n        if (token1Index < data.tokens1.length) {\n            append(this._domNode, $('span.tm-token-type', undefined, data.tokens1[token1Index].type));\n        }\n        this._editor.layoutContentWidget(this);\n    }\n    _decodeMetadata(metadata) {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        const tokenType = TokenMetadata.getTokenType(metadata);\n        const fontStyle = TokenMetadata.getFontStyle(metadata);\n        const foreground = TokenMetadata.getForeground(metadata);\n        const background = TokenMetadata.getBackground(metadata);\n        return {\n            languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),\n            tokenType: tokenType,\n            fontStyle: fontStyle,\n            foreground: colorMap[foreground],\n            background: colorMap[background]\n        };\n    }\n    _tokenTypeToString(tokenType) {\n        switch (tokenType) {\n            case 0 /* Other */: return 'Other';\n            case 1 /* Comment */: return 'Comment';\n            case 2 /* String */: return 'String';\n            case 3 /* RegEx */: return 'RegEx';\n            default: return '??';\n        }\n    }\n    _fontStyleToString(fontStyle) {\n        let r = '';\n        if (fontStyle & 1 /* Italic */) {\n            r += 'italic ';\n        }\n        if (fontStyle & 2 /* Bold */) {\n            r += 'bold ';\n        }\n        if (fontStyle & 4 /* Underline */) {\n            r += 'underline ';\n        }\n        if (fontStyle & 8 /* Strikethrough */) {\n            r += 'strikethrough ';\n        }\n        if (r.length === 0) {\n            r = '---';\n        }\n        return r;\n    }\n    _getTokensAtLine(lineNumber) {\n        const stateBeforeLine = this._getStateBeforeLine(lineNumber);\n        const tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine);\n        const tokenizationResult2 = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(lineNumber), true, stateBeforeLine);\n        return {\n            startState: stateBeforeLine,\n            tokens1: tokenizationResult1.tokens,\n            tokens2: tokenizationResult2.tokens,\n            endState: tokenizationResult1.endState\n        };\n    }\n    _getStateBeforeLine(lineNumber) {\n        let state = this._tokenizationSupport.getInitialState();\n        for (let i = 1; i < lineNumber; i++) {\n            const tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), true, state);\n            state = tokenizationResult.endState;\n        }\n        return state;\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    getPosition() {\n        return {\n            position: this._editor.getPosition(),\n            preference: [2 /* BELOW */, 1 /* ABOVE */]\n        };\n    }\n}\nInspectTokensWidget._ID = 'editor.contrib.inspectTokensWidget';\nregisterEditorContribution(InspectTokensController.ID, InspectTokensController);\nregisterEditorAction(InspectTokens);\nregisterThemingParticipant((theme, collector) => {\n    const border = theme.getColor(editorHoverBorder);\n    if (border) {\n        const borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;\n        collector.addRule(`.monaco-editor .tokens-inspect-widget { border: ${borderWidth}px solid ${border}; }`);\n        collector.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${border}; }`);\n    }\n    const background = theme.getColor(editorHoverBackground);\n    if (background) {\n        collector.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${background}; }`);\n    }\n    const foreground = theme.getColor(editorHoverForeground);\n    if (foreground) {\n        collector.addRule(`.monaco-editor .tokens-inspect-widget { color: ${foreground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as types from './types.js';\nimport * as nls from '../../nls.js';\nfunction exceptionToErrorMessage(exception, verbose) {\n    if (verbose && (exception.stack || exception.stacktrace)) {\n        return nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));\n    }\n    return detectSystemErrorMessage(exception);\n}\nfunction stackToString(stack) {\n    if (Array.isArray(stack)) {\n        return stack.join('\\n');\n    }\n    return stack;\n}\nfunction detectSystemErrorMessage(exception) {\n    // See https://nodejs.org/api/errors.html#errors_class_system_error\n    if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n        return nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n    }\n    return exception.message || nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error = null, verbose = false) {\n    if (!error) {\n        return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n    }\n    if (Array.isArray(error)) {\n        const errors = arrays.coalesce(error);\n        const msg = toErrorMessage(errors[0], verbose);\n        if (errors.length > 1) {\n            return nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n        }\n        return msg;\n    }\n    if (types.isString(error)) {\n        return error;\n    }\n    if (error.detail) {\n        const detail = error.detail;\n        if (detail.error) {\n            return exceptionToErrorMessage(detail.error, verbose);\n        }\n        if (detail.exception) {\n            return exceptionToErrorMessage(detail.exception, verbose);\n        }\n    }\n    if (error.stack) {\n        return exceptionToErrorMessage(error, verbose);\n    }\n    if (error.message) {\n        return error.message;\n    }\n    return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nexport var TriggerAction;\n(function (TriggerAction) {\n    /**\n     * Do nothing after the button was clicked.\n     */\n    TriggerAction[TriggerAction[\"NO_ACTION\"] = 0] = \"NO_ACTION\";\n    /**\n     * Close the picker.\n     */\n    TriggerAction[TriggerAction[\"CLOSE_PICKER\"] = 1] = \"CLOSE_PICKER\";\n    /**\n     * Update the results of the picker.\n     */\n    TriggerAction[TriggerAction[\"REFRESH_PICKER\"] = 2] = \"REFRESH_PICKER\";\n    /**\n     * Remove the item from the picker.\n     */\n    TriggerAction[TriggerAction[\"REMOVE_ITEM\"] = 3] = \"REMOVE_ITEM\";\n})(TriggerAction || (TriggerAction = {}));\nfunction isPicksWithActive(obj) {\n    const candidate = obj;\n    return Array.isArray(candidate.items);\n}\nfunction isFastAndSlowPicks(obj) {\n    const candidate = obj;\n    return !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\nexport class PickerQuickAccessProvider extends Disposable {\n    constructor(prefix, options) {\n        super();\n        this.prefix = prefix;\n        this.options = options;\n    }\n    provide(picker, token) {\n        var _a;\n        const disposables = new DisposableStore();\n        // Apply options if any\n        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\n        // Disable filtering & sorting, we control the results\n        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const picksDisposable = disposables.add(new MutableDisposable());\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n            const picksDisposables = picksDisposable.value = new DisposableStore();\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect picks and support both long running and short or combined\n            const picksToken = picksCts.token;\n            const picksFilter = picker.value.substr(this.prefix.length).trim();\n            const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken);\n            const applyPicks = (picks, skipEmpty) => {\n                var _a;\n                let items;\n                let activeItem = undefined;\n                if (isPicksWithActive(picks)) {\n                    items = picks.items;\n                    activeItem = picks.active;\n                }\n                else {\n                    items = picks;\n                }\n                if (items.length === 0) {\n                    if (skipEmpty) {\n                        return false;\n                    }\n                    if (picksFilter.length > 0 && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {\n                        items = [this.options.noResultsPick];\n                    }\n                }\n                picker.items = items;\n                if (activeItem) {\n                    picker.activeItems = [activeItem];\n                }\n                return true;\n            };\n            // No Picks\n            if (providedPicks === null) {\n                // Ignore\n            }\n            // Fast and Slow Picks\n            else if (isFastAndSlowPicks(providedPicks)) {\n                let fastPicksApplied = false;\n                let slowPicksApplied = false;\n                yield Promise.all([\n                    // Fast Picks: to reduce amount of flicker, we race against\n                    // the slow picks over 500ms and then set the fast picks.\n                    // If the slow picks are faster, we reduce the flicker by\n                    // only setting the items once.\n                    (() => __awaiter(this, void 0, void 0, function* () {\n                        yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);\n                        if (picksToken.isCancellationRequested) {\n                            return;\n                        }\n                        if (!slowPicksApplied) {\n                            fastPicksApplied = applyPicks(providedPicks.picks, true /* skip over empty to reduce flicker */);\n                        }\n                    }))(),\n                    // Slow Picks: we await the slow picks and then set them at\n                    // once together with the fast picks, but only if we actually\n                    // have additional results.\n                    (() => __awaiter(this, void 0, void 0, function* () {\n                        picker.busy = true;\n                        try {\n                            const awaitedAdditionalPicks = yield providedPicks.additionalPicks;\n                            if (picksToken.isCancellationRequested) {\n                                return;\n                            }\n                            let picks;\n                            let activePick = undefined;\n                            if (isPicksWithActive(providedPicks.picks)) {\n                                picks = providedPicks.picks.items;\n                                activePick = providedPicks.picks.active;\n                            }\n                            else {\n                                picks = providedPicks.picks;\n                            }\n                            let additionalPicks;\n                            let additionalActivePick = undefined;\n                            if (isPicksWithActive(awaitedAdditionalPicks)) {\n                                additionalPicks = awaitedAdditionalPicks.items;\n                                additionalActivePick = awaitedAdditionalPicks.active;\n                            }\n                            else {\n                                additionalPicks = awaitedAdditionalPicks;\n                            }\n                            if (additionalPicks.length > 0 || !fastPicksApplied) {\n                                // If we do not have any activePick or additionalActivePick\n                                // we try to preserve the currently active pick from the\n                                // fast results. This fixes an issue where the user might\n                                // have made a pick active before the additional results\n                                // kick in.\n                                // See https://github.com/microsoft/vscode/issues/102480\n                                let fallbackActivePick = undefined;\n                                if (!activePick && !additionalActivePick) {\n                                    const fallbackActivePickCandidate = picker.activeItems[0];\n                                    if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n                                        fallbackActivePick = fallbackActivePickCandidate;\n                                    }\n                                }\n                                applyPicks({\n                                    items: [...picks, ...additionalPicks],\n                                    active: activePick || additionalActivePick || fallbackActivePick\n                                });\n                            }\n                        }\n                        finally {\n                            if (!picksToken.isCancellationRequested) {\n                                picker.busy = false;\n                            }\n                            slowPicksApplied = true;\n                        }\n                    }))()\n                ]);\n            }\n            // Fast Picks\n            else if (!(providedPicks instanceof Promise)) {\n                applyPicks(providedPicks);\n            }\n            // Slow Picks\n            else {\n                picker.busy = true;\n                try {\n                    const awaitedPicks = yield providedPicks;\n                    if (picksToken.isCancellationRequested) {\n                        return;\n                    }\n                    applyPicks(awaitedPicks);\n                }\n                finally {\n                    if (!picksToken.isCancellationRequested) {\n                        picker.busy = false;\n                    }\n                }\n            }\n        });\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n        updatePickerItems();\n        // Accept the pick on accept and hide picker\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {\n                if (!event.inBackground) {\n                    picker.hide(); // hide picker unless we accept in background\n                }\n                item.accept(picker.keyMods, event);\n            }\n        }));\n        // Trigger the pick with button index if button triggered\n        disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            if (typeof item.trigger === 'function') {\n                const buttonIndex = (_c = (_b = item.buttons) === null || _b === void 0 ? void 0 : _b.indexOf(button)) !== null && _c !== void 0 ? _c : -1;\n                if (buttonIndex >= 0) {\n                    const result = item.trigger(buttonIndex, picker.keyMods);\n                    const action = (typeof result === 'number') ? result : yield result;\n                    if (token.isCancellationRequested) {\n                        return;\n                    }\n                    switch (action) {\n                        case TriggerAction.NO_ACTION:\n                            break;\n                        case TriggerAction.CLOSE_PICKER:\n                            picker.hide();\n                            break;\n                        case TriggerAction.REFRESH_PICKER:\n                            updatePickerItems();\n                            break;\n                        case TriggerAction.REMOVE_ITEM: {\n                            const index = picker.items.indexOf(item);\n                            if (index !== -1) {\n                                const items = picker.items.slice();\n                                const removed = items.splice(index, 1);\n                                const activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);\n                                const keepScrollPositionBefore = picker.keepScrollPosition;\n                                picker.keepScrollPosition = true;\n                                picker.items = items;\n                                if (activeItems) {\n                                    picker.activeItems = activeItems;\n                                }\n                                picker.keepScrollPosition = keepScrollPositionBefore;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        })));\n        return disposables;\n    }\n}\nPickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200; // timeout before we accept fast results before slow results are present\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport Severity from '../../../base/common/severity.js';\nimport { withNullAsUndefined } from '../../../base/common/types.js';\nimport { localize } from '../../../nls.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { PickerQuickAccessProvider } from './pickerQuickAccess.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nlet AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {\n    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n        super(AbstractCommandsQuickAccessProvider.PREFIX, options);\n        this.instantiationService = instantiationService;\n        this.keybindingService = keybindingService;\n        this.commandService = commandService;\n        this.telemetryService = telemetryService;\n        this.dialogService = dialogService;\n        this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n        this.options = options;\n    }\n    _getPicks(filter, disposables, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ask subclass for all command picks\n            const allCommandPicks = yield this.getCommandPicks(disposables, token);\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            // Filter\n            const filteredCommandPicks = [];\n            for (const commandPick of allCommandPicks) {\n                const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.label));\n                const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.commandAlias)) : undefined;\n                // Add if matching in label or alias\n                if (labelHighlights || aliasHighlights) {\n                    commandPick.highlights = {\n                        label: labelHighlights,\n                        detail: this.options.showAlias ? aliasHighlights : undefined\n                    };\n                    filteredCommandPicks.push(commandPick);\n                }\n                // Also add if we have a 100% command ID match\n                else if (filter === commandPick.commandId) {\n                    filteredCommandPicks.push(commandPick);\n                }\n            }\n            // Add description to commands that have duplicate labels\n            const mapLabelToCommand = new Map();\n            for (const commandPick of filteredCommandPicks) {\n                const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n                if (existingCommandForLabel) {\n                    commandPick.description = commandPick.commandId;\n                    existingCommandForLabel.description = existingCommandForLabel.commandId;\n                }\n                else {\n                    mapLabelToCommand.set(commandPick.label, commandPick);\n                }\n            }\n            // Sort by MRU order and fallback to name otherwise\n            filteredCommandPicks.sort((commandPickA, commandPickB) => {\n                const commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n                const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n                if (commandACounter && commandBCounter) {\n                    return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n                }\n                if (commandACounter) {\n                    return -1; // first command was used, so it wins over the non used one\n                }\n                if (commandBCounter) {\n                    return 1; // other command was used so it wins over the command\n                }\n                // both commands were never used, so we sort by name\n                return commandPickA.label.localeCompare(commandPickB.label);\n            });\n            const commandPicks = [];\n            let addSeparator = false;\n            for (let i = 0; i < filteredCommandPicks.length; i++) {\n                const commandPick = filteredCommandPicks[i];\n                const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n                const ariaLabel = keybinding ?\n                    localize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) :\n                    commandPick.label;\n                // Separator: recently used\n                if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n                    commandPicks.push({ type: 'separator', label: localize('recentlyUsed', \"recently used\") });\n                    addSeparator = true;\n                }\n                // Separator: other commands\n                if (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {\n                    commandPicks.push({ type: 'separator', label: localize('morecCommands', \"other commands\") });\n                    addSeparator = false; // only once\n                }\n                // Command\n                commandPicks.push(Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined, keybinding, accept: () => __awaiter(this, void 0, void 0, function* () {\n                        // Add to history\n                        this.commandsHistory.push(commandPick.commandId);\n                        // Telementry\n                        this.telemetryService.publicLog2('workbenchActionExecuted', {\n                            id: commandPick.commandId,\n                            from: 'quick open'\n                        });\n                        // Run\n                        try {\n                            yield this.commandService.executeCommand(commandPick.commandId);\n                        }\n                        catch (error) {\n                            if (!isCancellationError(error)) {\n                                this.dialogService.show(Severity.Error, localize('canNotRun', \"Command '{0}' resulted in an error ({1})\", commandPick.label, toErrorMessage(error)));\n                            }\n                        }\n                    }) }));\n            }\n            return commandPicks;\n        });\n    }\n};\nAbstractCommandsQuickAccessProvider.PREFIX = '>';\nAbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);\nAbstractCommandsQuickAccessProvider = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IKeybindingService),\n    __param(3, ICommandService),\n    __param(4, ITelemetryService),\n    __param(5, IDialogService)\n], AbstractCommandsQuickAccessProvider);\nexport { AbstractCommandsQuickAccessProvider };\nlet CommandsHistory = class CommandsHistory extends Disposable {\n    constructor(storageService, configurationService) {\n        super();\n        this.storageService = storageService;\n        this.configurationService = configurationService;\n        this.configuredCommandsHistoryLength = 0;\n        this.updateConfiguration();\n        this.load();\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));\n    }\n    updateConfiguration() {\n        this.configuredCommandsHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(this.configurationService);\n        if (CommandsHistory.cache && CommandsHistory.cache.limit !== this.configuredCommandsHistoryLength) {\n            CommandsHistory.cache.limit = this.configuredCommandsHistoryLength;\n            CommandsHistory.saveState(this.storageService);\n        }\n    }\n    load() {\n        const raw = this.storageService.get(CommandsHistory.PREF_KEY_CACHE, 0 /* GLOBAL */);\n        let serializedCache;\n        if (raw) {\n            try {\n                serializedCache = JSON.parse(raw);\n            }\n            catch (error) {\n                // invalid data\n            }\n        }\n        const cache = CommandsHistory.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);\n        if (serializedCache) {\n            let entries;\n            if (serializedCache.usesLRU) {\n                entries = serializedCache.entries;\n            }\n            else {\n                entries = serializedCache.entries.sort((a, b) => a.value - b.value);\n            }\n            entries.forEach(entry => cache.set(entry.key, entry.value));\n        }\n        CommandsHistory.counter = this.storageService.getNumber(CommandsHistory.PREF_KEY_COUNTER, 0 /* GLOBAL */, CommandsHistory.counter);\n    }\n    push(commandId) {\n        if (!CommandsHistory.cache) {\n            return;\n        }\n        CommandsHistory.cache.set(commandId, CommandsHistory.counter++); // set counter to command\n        CommandsHistory.saveState(this.storageService);\n    }\n    peek(commandId) {\n        var _a;\n        return (_a = CommandsHistory.cache) === null || _a === void 0 ? void 0 : _a.peek(commandId);\n    }\n    static saveState(storageService) {\n        if (!CommandsHistory.cache) {\n            return;\n        }\n        const serializedCache = { usesLRU: true, entries: [] };\n        CommandsHistory.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));\n        storageService.store(CommandsHistory.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* GLOBAL */, 0 /* USER */);\n        storageService.store(CommandsHistory.PREF_KEY_COUNTER, CommandsHistory.counter, 0 /* GLOBAL */, 0 /* USER */);\n    }\n    static getConfiguredCommandHistoryLength(configurationService) {\n        var _a, _b;\n        const config = configurationService.getValue();\n        const configuredCommandHistoryLength = (_b = (_a = config.workbench) === null || _a === void 0 ? void 0 : _a.commandPalette) === null || _b === void 0 ? void 0 : _b.history;\n        if (typeof configuredCommandHistoryLength === 'number') {\n            return configuredCommandHistoryLength;\n        }\n        return CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;\n    }\n};\nCommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;\nCommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache';\nCommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter';\nCommandsHistory.counter = 1;\nCommandsHistory = __decorate([\n    __param(0, IStorageService),\n    __param(1, IConfigurationService)\n], CommandsHistory);\nexport { CommandsHistory };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { stripIcons } from '../../../../base/common/iconLabels.js';\nimport { AbstractCommandsQuickAccessProvider } from '../../../../platform/quickinput/browser/commandsQuickAccess.js';\nexport class AbstractEditorCommandsQuickAccessProvider extends AbstractCommandsQuickAccessProvider {\n    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n        super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);\n    }\n    getCodeEditorCommandPicks() {\n        const activeTextEditorControl = this.activeTextEditorControl;\n        if (!activeTextEditorControl) {\n            return [];\n        }\n        const editorCommandPicks = [];\n        for (const editorAction of activeTextEditorControl.getSupportedActions()) {\n            editorCommandPicks.push({\n                commandId: editorAction.id,\n                commandAlias: editorAction.alias,\n                label: stripIcons(editorAction.label) || editorAction.id,\n            });\n        }\n        return editorCommandPicks;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';\nimport { QuickCommandNLS } from '../../../common/standaloneStrings.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { AbstractEditorCommandsQuickAccessProvider } from '../../../contrib/quickAccess/browser/commandsQuickAccess.js';\nimport { withNullAsUndefined } from '../../../../base/common/types.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.js';\nimport { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nlet StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider extends AbstractEditorCommandsQuickAccessProvider {\n    constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {\n        super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);\n        this.codeEditorService = codeEditorService;\n    }\n    get activeTextEditorControl() { return withNullAsUndefined(this.codeEditorService.getFocusedCodeEditor()); }\n    getCommandPicks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getCodeEditorCommandPicks();\n        });\n    }\n};\nStandaloneCommandsQuickAccessProvider = __decorate([\n    __param(0, IInstantiationService),\n    __param(1, ICodeEditorService),\n    __param(2, IKeybindingService),\n    __param(3, ICommandService),\n    __param(4, ITelemetryService),\n    __param(5, IDialogService)\n], StandaloneCommandsQuickAccessProvider);\nexport { StandaloneCommandsQuickAccessProvider };\nRegistry.as(Extensions.Quickaccess).registerQuickAccessProvider({\n    ctor: StandaloneCommandsQuickAccessProvider,\n    prefix: StandaloneCommandsQuickAccessProvider.PREFIX,\n    helpEntries: [{ description: QuickCommandNLS.quickCommandHelp, needsEditor: true }]\n});\nexport class GotoLineAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.quickCommand',\n            label: QuickCommandNLS.quickCommandActionLabel,\n            alias: 'Command Palette',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 59 /* F1 */,\n                weight: 100 /* EditorContrib */\n            },\n            contextMenuOpts: {\n                group: 'z_commands',\n                order: 1\n            }\n        });\n    }\n    run(accessor) {\n        accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);\n    }\n}\nregisterEditorAction(GotoLineAction);\n","import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n    // Score: multiple inputs\n    const preparedQuery = query;\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n    }\n    // Score: single input\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n    let totalScore = 0;\n    const totalMatches = [];\n    for (const queryPiece of query) {\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n        if (typeof score !== 'number') {\n            // if a single query value does not match, return with\n            // no score entirely, we require all queries to match\n            return NO_SCORE2;\n        }\n        totalScore += score;\n        totalMatches.push(...matches);\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n    return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\n    if (!score) {\n        return NO_SCORE2;\n    }\n    return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({ score: 0 });\nfunction normalizeMatches(matches) {\n    // sort matches by start to be able to normalize\n    const sortedMatches = matches.sort((matchA, matchB) => {\n        return matchA.start - matchB.start;\n    });\n    // merge matches that overlap\n    const normalizedMatches = [];\n    let currentMatch = undefined;\n    for (const match of sortedMatches) {\n        // if we have no current match or the matches\n        // do not overlap, we take it as is and remember\n        // it for future merging\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n            currentMatch = match;\n            normalizedMatches.push(match);\n        }\n        // otherwise we merge the matches\n        else {\n            currentMatch.start = Math.min(currentMatch.start, match.start);\n            currentMatch.end = Math.max(currentMatch.end, match.end);\n        }\n    }\n    return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n    if (matchA.end < matchB.start) {\n        return false; // A ends before B starts\n    }\n    if (matchB.end < matchA.start) {\n        return false; // B ends before A starts\n    }\n    return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n    return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n    if (typeof original !== 'string') {\n        original = '';\n    }\n    const originalLowercase = original.toLowerCase();\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n    const expectExactMatch = queryExpectsExactMatch(original);\n    let values = undefined;\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n    if (originalSplit.length > 1) {\n        for (const originalPiece of originalSplit) {\n            const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\n            if (normalizedPiece) {\n                if (!values) {\n                    values = [];\n                }\n                values.push({\n                    original: originalPiece,\n                    originalLowercase: originalPiece.toLowerCase(),\n                    pathNormalized: pathNormalizedPiece,\n                    normalized: normalizedPiece,\n                    normalizedLowercase: normalizedLowercasePiece,\n                    expectContiguousMatch: expectExactMatchPiece\n                });\n            }\n        }\n    }\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\nfunction normalizeQuery(original) {\n    let pathNormalized;\n    if (isWindows) {\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n    }\n    else {\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n    }\n    // we remove quotes here because quotes are used for exact match search\n    const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n    return {\n        pathNormalized,\n        normalized,\n        normalizedLowercase: normalized.toLowerCase()\n    };\n}\nexport function pieceToQuery(arg1) {\n    if (Array.isArray(arg1)) {\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n    }\n    return prepareQuery(arg1.original);\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from '../../../../base/common/functional.js';\nimport { DisposableStore, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { withNullAsUndefined } from '../../../../base/common/types.js';\nimport { getCodeEditor, isDiffEditor } from '../../../browser/editorBrowser.js';\nimport { OverviewRulerLane } from '../../../common/model.js';\nimport { overviewRulerRangeHighlight } from '../../../common/core/editorColorRegistry.js';\nimport { themeColorFromId } from '../../../../platform/theme/common/themeService.js';\n/**\n * A reusable quick access provider for the editor with support\n * for adding decorations for navigating in the currently active file\n * (for example \"Go to line\", \"Go to symbol\").\n */\nexport class AbstractEditorNavigationQuickAccessProvider {\n    constructor(options) {\n        this.options = options;\n        //#endregion\n        //#region Decorations Utils\n        this.rangeHighlightDecorationId = undefined;\n    }\n    //#region Provider methods\n    provide(picker, token) {\n        var _a;\n        const disposables = new DisposableStore();\n        // Apply options if any\n        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\n        // Disable filtering & sorting, we control the results\n        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n        // Provide based on current active editor\n        const pickerDisposable = disposables.add(new MutableDisposable());\n        pickerDisposable.value = this.doProvide(picker, token);\n        // Re-create whenever the active editor changes\n        disposables.add(this.onDidActiveTextEditorControlChange(() => {\n            // Clear old\n            pickerDisposable.value = undefined;\n            // Add new\n            pickerDisposable.value = this.doProvide(picker, token);\n        }));\n        return disposables;\n    }\n    doProvide(picker, token) {\n        const disposables = new DisposableStore();\n        // With text control\n        const editor = this.activeTextEditorControl;\n        if (editor && this.canProvideWithTextEditor(editor)) {\n            const context = { editor };\n            // Restore any view state if this picker was closed\n            // without actually going to a line\n            const codeEditor = getCodeEditor(editor);\n            if (codeEditor) {\n                // Remember view state and update it when the cursor position\n                // changes even later because it could be that the user has\n                // configured quick access to remain open when focus is lost and\n                // we always want to restore the current location.\n                let lastKnownEditorViewState = withNullAsUndefined(editor.saveViewState());\n                disposables.add(codeEditor.onDidChangeCursorPosition(() => {\n                    lastKnownEditorViewState = withNullAsUndefined(editor.saveViewState());\n                }));\n                context.restoreViewState = () => {\n                    if (lastKnownEditorViewState && editor === this.activeTextEditorControl) {\n                        editor.restoreViewState(lastKnownEditorViewState);\n                    }\n                };\n                disposables.add(once(token.onCancellationRequested)(() => { var _a; return (_a = context.restoreViewState) === null || _a === void 0 ? void 0 : _a.call(context); }));\n            }\n            // Clean up decorations on dispose\n            disposables.add(toDisposable(() => this.clearDecorations(editor)));\n            // Ask subclass for entries\n            disposables.add(this.provideWithTextEditor(context, picker, token));\n        }\n        // Without text control\n        else {\n            disposables.add(this.provideWithoutTextEditor(picker, token));\n        }\n        return disposables;\n    }\n    /**\n     * Subclasses to implement if they can operate on the text editor.\n     */\n    canProvideWithTextEditor(editor) {\n        return true;\n    }\n    gotoLocation({ editor }, options) {\n        editor.setSelection(options.range);\n        editor.revealRangeInCenter(options.range, 0 /* Smooth */);\n        if (!options.preserveFocus) {\n            editor.focus();\n        }\n    }\n    getModel(editor) {\n        var _a;\n        return isDiffEditor(editor) ?\n            (_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.modified :\n            editor.getModel();\n    }\n    addDecorations(editor, range) {\n        editor.changeDecorations(changeAccessor => {\n            // Reset old decorations if any\n            const deleteDecorations = [];\n            if (this.rangeHighlightDecorationId) {\n                deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);\n                deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);\n                this.rangeHighlightDecorationId = undefined;\n            }\n            // Add new decorations for the range\n            const newDecorations = [\n                // highlight the entire line on the range\n                {\n                    range,\n                    options: {\n                        description: 'quick-access-range-highlight',\n                        className: 'rangeHighlight',\n                        isWholeLine: true\n                    }\n                },\n                // also add overview ruler highlight\n                {\n                    range,\n                    options: {\n                        description: 'quick-access-range-highlight-overview',\n                        overviewRuler: {\n                            color: themeColorFromId(overviewRulerRangeHighlight),\n                            position: OverviewRulerLane.Full\n                        }\n                    }\n                }\n            ];\n            const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);\n            this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };\n        });\n    }\n    clearDecorations(editor) {\n        const rangeHighlightDecorationId = this.rangeHighlightDecorationId;\n        if (rangeHighlightDecorationId) {\n            editor.changeDecorations(changeAccessor => {\n                changeAccessor.deltaDecorations([\n                    rangeHighlightDecorationId.overviewRulerDecorationId,\n                    rangeHighlightDecorationId.rangeHighlightId\n                ], []);\n            });\n            this.rangeHighlightDecorationId = undefined;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        }))();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* String */ }];\n        picker.ariaLabel = label;\n    }\n    waitForLanguageSymbolRegistry(model, disposables) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                return true;\n            }\n            const symbolProviderRegistryPromise = new DeferredPromise();\n            // Resolve promise when registry knows model\n            const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n                if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                    symbolProviderListener.dispose();\n                    symbolProviderRegistryPromise.complete(true);\n                }\n            }));\n            // Resolve promise when we get disposed too\n            disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n            return symbolProviderRegistryPromise.p;\n        });\n    }\n    doProvideWithEditorSymbols(context, model, picker, token) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        });\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n        updatePickerItems();\n        // Reveal and decorate when active item changes\n        // However, ignore the very first event so that\n        // opening the picker is not immediately revealing\n        // and decorating the first entry.\n        let ignoreFirstActiveEvent = true;\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                if (ignoreFirstActiveEvent) {\n                    ignoreFirstActiveEvent = false;\n                    return;\n                }\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    doGetSymbolPicks(symbolsPromise, query, options, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbols = yield symbolsPromise;\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n            const filterPos = filterBySymbolKind ? 1 : 0;\n            // Split between symbol and container query\n            let symbolQuery;\n            let containerQuery;\n            if (query.values && query.values.length > 1) {\n                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n            }\n            else {\n                symbolQuery = query;\n            }\n            // Convert to symbol picks and apply filtering\n            const filteredSymbolPicks = [];\n            for (let index = 0; index < symbols.length; index++) {\n                const symbol = symbols[index];\n                const symbolLabel = trim(symbol.name);\n                const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n                let containerLabel = symbol.containerName;\n                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n                    if (containerLabel) {\n                        containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                    }\n                    else {\n                        containerLabel = options.extraContainerLabel;\n                    }\n                }\n                let symbolScore = undefined;\n                let symbolMatches = undefined;\n                let containerScore = undefined;\n                let containerMatches = undefined;\n                if (query.original.length > filterPos) {\n                    // First: try to score on the entire query, it is possible that\n                    // the symbol matches perfectly (e.g. searching for \"change log\"\n                    // can be a match on a markdown symbol \"change log\"). In that\n                    // case we want to skip the container query altogether.\n                    let skipContainerQuery = false;\n                    if (symbolQuery !== query) {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore === 'number') {\n                            skipContainerQuery = true; // since we consumed the query, skip any container matching\n                        }\n                    }\n                    // Otherwise: score on the symbol query and match on the container later\n                    if (typeof symbolScore !== 'number') {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore !== 'number') {\n                            continue;\n                        }\n                    }\n                    // Score by container if specified\n                    if (!skipContainerQuery && containerQuery) {\n                        if (containerLabel && containerQuery.original.length > 0) {\n                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                        }\n                        if (typeof containerScore !== 'number') {\n                            continue;\n                        }\n                        if (typeof symbolScore === 'number') {\n                            symbolScore += containerScore; // boost symbolScore by containerScore\n                        }\n                    }\n                }\n                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* Deprecated */) >= 0;\n                filteredSymbolPicks.push({\n                    index,\n                    kind: symbol.kind,\n                    score: symbolScore,\n                    label: symbolLabelWithIcon,\n                    ariaLabel: symbolLabel,\n                    description: containerLabel,\n                    highlights: deprecated ? undefined : {\n                        label: symbolMatches,\n                        description: containerMatches\n                    },\n                    range: {\n                        selection: Range.collapseToStart(symbol.selectionRange),\n                        decoration: symbol.range\n                    },\n                    strikethrough: deprecated,\n                    buttons: (() => {\n                        var _a, _b;\n                        const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n                        if (!openSideBySideDirection) {\n                            return undefined;\n                        }\n                        return [\n                            {\n                                iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n                                tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                            }\n                        ];\n                    })()\n                });\n            }\n            // Sort by score\n            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n                this.compareByKindAndScore(symbolA, symbolB) :\n                this.compareByScore(symbolA, symbolB));\n            // Add separator for types\n            // - @  only total number of symbols\n            // - @: grouped by symbol kind\n            let symbolPicks = [];\n            if (filterBySymbolKind) {\n                let lastSymbolKind = undefined;\n                let lastSeparator = undefined;\n                let lastSymbolKindCounter = 0;\n                function updateLastSeparatorLabel() {\n                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                    }\n                }\n                for (const symbolPick of sortedFilteredSymbolPicks) {\n                    // Found new kind\n                    if (lastSymbolKind !== symbolPick.kind) {\n                        // Update last separator with number of symbols we found for kind\n                        updateLastSeparatorLabel();\n                        lastSymbolKind = symbolPick.kind;\n                        lastSymbolKindCounter = 1;\n                        // Add new separator for new kind\n                        lastSeparator = { type: 'separator' };\n                        symbolPicks.push(lastSeparator);\n                    }\n                    // Existing kind, keep counting\n                    else {\n                        lastSymbolKindCounter++;\n                    }\n                    // Add to final result\n                    symbolPicks.push(symbolPick);\n                }\n                // Update last separator with number of symbols we found for kind\n                updateLastSeparatorLabel();\n            }\n            else if (sortedFilteredSymbolPicks.length > 0) {\n                symbolPicks = [\n                    { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                    ...sortedFilteredSymbolPicks\n                ];\n            }\n            return symbolPicks;\n        });\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    getDocumentSymbols(document, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = yield this._outlineModelService.getOrCreate(document, token);\n            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n        });\n    }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* Method */]: localize('method', \"methods ({0})\"),\n    [11 /* Function */]: localize('function', \"functions ({0})\"),\n    [8 /* Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* Class */]: localize('class', \"classes ({0})\"),\n    [22 /* Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* Event */]: localize('event', \"events ({0})\"),\n    [24 /* Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* Package */]: localize('package', \"packages ({0})\"),\n    [25 /* TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* Property */]: localize('property', \"properties ({0})\"),\n    [9 /* Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* String */]: localize('string', \"strings ({0})\"),\n    [0 /* File */]: localize('file', \"files ({0})\"),\n    [17 /* Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* Object */]: localize('object', \"objects ({0})\"),\n    [19 /* Key */]: localize('key', \"keys ({0})\"),\n    [7 /* Field */]: localize('field', \"fields ({0})\"),\n    [13 /* Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport '../../../../base/browser/ui/codicons/codiconStyles.js'; // The codicon symbol styles are defined here and must be loaded\nimport '../../../contrib/symbolIcons/browser/symbolIcons.js'; // The codicon symbol colors are defined here and must be loaded to get colors\nimport { AbstractGotoSymbolQuickAccessProvider } from '../../../contrib/quickAccess/browser/gotoSymbolQuickAccess.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { withNullAsUndefined } from '../../../../base/common/types.js';\nimport { QuickOutlineNLS } from '../../../common/standaloneStrings.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { IOutlineModelService } from '../../../contrib/documentSymbols/browser/outlineModel.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nlet StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider extends AbstractGotoSymbolQuickAccessProvider {\n    constructor(editorService, languageFeaturesService, outlineModelService) {\n        super(languageFeaturesService, outlineModelService);\n        this.editorService = editorService;\n        this.onDidActiveTextEditorControlChange = Event.None;\n    }\n    get activeTextEditorControl() {\n        return withNullAsUndefined(this.editorService.getFocusedCodeEditor());\n    }\n};\nStandaloneGotoSymbolQuickAccessProvider = __decorate([\n    __param(0, ICodeEditorService),\n    __param(1, ILanguageFeaturesService),\n    __param(2, IOutlineModelService)\n], StandaloneGotoSymbolQuickAccessProvider);\nexport { StandaloneGotoSymbolQuickAccessProvider };\nRegistry.as(Extensions.Quickaccess).registerQuickAccessProvider({\n    ctor: StandaloneGotoSymbolQuickAccessProvider,\n    prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,\n    helpEntries: [\n        { description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, needsEditor: true },\n        { description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY, needsEditor: true }\n    ]\n});\nexport class GotoLineAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.quickOutline',\n            label: QuickOutlineNLS.quickOutlineActionLabel,\n            alias: 'Go to Symbol...',\n            precondition: EditorContextKeys.hasDocumentSymbolProvider,\n            kbOpts: {\n                kbExpr: EditorContextKeys.focus,\n                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 45 /* KeyO */,\n                weight: 100 /* EditorContrib */\n            },\n            contextMenuOpts: {\n                group: 'navigation',\n                order: 3\n            }\n        });\n    }\n    run(accessor) {\n        accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX);\n    }\n}\nregisterEditorAction(GotoLineAction);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorAction, registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { IStandaloneThemeService } from '../../common/standaloneTheme.js';\nimport { ToggleHighContrastNLS } from '../../../common/standaloneStrings.js';\nclass ToggleHighContrast extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.toggleHighContrast',\n            label: ToggleHighContrastNLS.toggleHighContrast,\n            alias: 'Toggle High Contrast Theme',\n            precondition: undefined\n        });\n        this._originalThemeName = null;\n    }\n    run(accessor, editor) {\n        const standaloneThemeService = accessor.get(IStandaloneThemeService);\n        if (this._originalThemeName) {\n            // We must toggle back to the integrator's theme\n            standaloneThemeService.setTheme(this._originalThemeName);\n            this._originalThemeName = null;\n        }\n        else {\n            this._originalThemeName = standaloneThemeService.getColorTheme().themeName;\n            standaloneThemeService.setTheme('hc-black');\n        }\n    }\n}\nregisterEditorAction(ToggleHighContrast);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IStandaloneThemeService = createDecorator('themeService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction _format(message, args) {\n    let result;\n    if (args.length === 0) {\n        result = message;\n    }\n    else {\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\n            const index = rest[0];\n            return typeof args[index] !== 'undefined' ? args[index] : match;\n        });\n    }\n    return result;\n}\nexport function localize(data, message, ...args) {\n    return _format(message, args);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IAccessibilityService = createDecorator('accessibilityService');\nexport const CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey('accessibilityModeEnabled', false);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, addDisposableListener, append, EventHelper, EventType } from '../../dom.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { EventType as GestureEventType, Gesture } from '../../touch.js';\nimport { ActionRunner } from '../../../common/actions.js';\nimport { Emitter } from '../../../common/event.js';\nimport './dropdown.css';\nexport class BaseDropdown extends ActionRunner {\n    constructor(container, options) {\n        super();\n        this._onDidChangeVisibility = this._register(new Emitter());\n        this.onDidChangeVisibility = this._onDidChangeVisibility.event;\n        this._element = append(container, $('.monaco-dropdown'));\n        this._label = append(this._element, $('.dropdown-label'));\n        let labelRenderer = options.labelRenderer;\n        if (!labelRenderer) {\n            labelRenderer = (container) => {\n                container.textContent = options.label || '';\n                return null;\n            };\n        }\n        for (const event of [EventType.CLICK, EventType.MOUSE_DOWN, GestureEventType.Tap]) {\n            this._register(addDisposableListener(this.element, event, e => EventHelper.stop(e, true))); // prevent default click behaviour to trigger\n        }\n        for (const event of [EventType.MOUSE_DOWN, GestureEventType.Tap]) {\n            this._register(addDisposableListener(this._label, event, e => {\n                if (e instanceof MouseEvent && e.detail > 1) {\n                    return; // prevent multiple clicks to open multiple context menus (https://github.com/microsoft/vscode/issues/41363)\n                }\n                if (this.visible) {\n                    this.hide();\n                }\n                else {\n                    this.show();\n                }\n            }));\n        }\n        this._register(addDisposableListener(this._label, EventType.KEY_UP, e => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {\n                EventHelper.stop(e, true); // https://github.com/microsoft/vscode/issues/57997\n                if (this.visible) {\n                    this.hide();\n                }\n                else {\n                    this.show();\n                }\n            }\n        }));\n        const cleanupFn = labelRenderer(this._label);\n        if (cleanupFn) {\n            this._register(cleanupFn);\n        }\n        this._register(Gesture.addTarget(this._label));\n    }\n    get element() {\n        return this._element;\n    }\n    show() {\n        if (!this.visible) {\n            this.visible = true;\n            this._onDidChangeVisibility.fire(true);\n        }\n    }\n    hide() {\n        if (this.visible) {\n            this.visible = false;\n            this._onDidChangeVisibility.fire(false);\n        }\n    }\n    dispose() {\n        super.dispose();\n        this.hide();\n        if (this.boxContainer) {\n            this.boxContainer.remove();\n            this.boxContainer = undefined;\n        }\n        if (this.contents) {\n            this.contents.remove();\n            this.contents = undefined;\n        }\n        if (this._label) {\n            this._label.remove();\n            this._label = undefined;\n        }\n    }\n}\nexport class DropdownMenu extends BaseDropdown {\n    constructor(container, options) {\n        super(container, options);\n        this._actions = [];\n        this._contextMenuProvider = options.contextMenuProvider;\n        this.actions = options.actions || [];\n        this.actionProvider = options.actionProvider;\n        this.menuClassName = options.menuClassName || '';\n        this.menuAsChild = !!options.menuAsChild;\n    }\n    set menuOptions(options) {\n        this._menuOptions = options;\n    }\n    get menuOptions() {\n        return this._menuOptions;\n    }\n    get actions() {\n        if (this.actionProvider) {\n            return this.actionProvider.getActions();\n        }\n        return this._actions;\n    }\n    set actions(actions) {\n        this._actions = actions;\n    }\n    show() {\n        super.show();\n        this.element.classList.add('active');\n        this._contextMenuProvider.showContextMenu({\n            getAnchor: () => this.element,\n            getActions: () => this.actions,\n            getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,\n            getActionViewItem: action => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : undefined,\n            getKeyBinding: action => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : undefined,\n            getMenuClassName: () => this.menuClassName,\n            onHide: () => this.onHide(),\n            actionRunner: this.menuOptions ? this.menuOptions.actionRunner : undefined,\n            anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0 /* LEFT */,\n            domForShadowRoot: this.menuAsChild ? this.element : undefined\n        });\n    }\n    hide() {\n        super.hide();\n    }\n    onHide() {\n        this.hide();\n        this.element.classList.remove('active');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append } from '../../dom.js';\nimport { BaseActionViewItem } from '../actionbar/actionViewItems.js';\nimport { DropdownMenu } from './dropdown.js';\nimport { Emitter } from '../../../common/event.js';\nimport './dropdown.css';\nexport class DropdownMenuActionViewItem extends BaseActionViewItem {\n    constructor(action, menuActionsOrProvider, contextMenuProvider, options = Object.create(null)) {\n        super(null, action, options);\n        this.actionItem = null;\n        this._onDidChangeVisibility = this._register(new Emitter());\n        this.menuActionsOrProvider = menuActionsOrProvider;\n        this.contextMenuProvider = contextMenuProvider;\n        this.options = options;\n        if (this.options.actionRunner) {\n            this.actionRunner = this.options.actionRunner;\n        }\n    }\n    render(container) {\n        this.actionItem = container;\n        const labelRenderer = (el) => {\n            this.element = append(el, $('a.action-label'));\n            let classNames = [];\n            if (typeof this.options.classNames === 'string') {\n                classNames = this.options.classNames.split(/\\s+/g).filter(s => !!s);\n            }\n            else if (this.options.classNames) {\n                classNames = this.options.classNames;\n            }\n            // todo@aeschli: remove codicon, should come through `this.options.classNames`\n            if (!classNames.find(c => c === 'icon')) {\n                classNames.push('codicon');\n            }\n            this.element.classList.add(...classNames);\n            this.element.setAttribute('role', 'button');\n            this.element.setAttribute('aria-haspopup', 'true');\n            this.element.setAttribute('aria-expanded', 'false');\n            this.element.title = this._action.label || '';\n            return null;\n        };\n        const isActionsArray = Array.isArray(this.menuActionsOrProvider);\n        const options = {\n            contextMenuProvider: this.contextMenuProvider,\n            labelRenderer: labelRenderer,\n            menuAsChild: this.options.menuAsChild,\n            actions: isActionsArray ? this.menuActionsOrProvider : undefined,\n            actionProvider: isActionsArray ? undefined : this.menuActionsOrProvider\n        };\n        this.dropdownMenu = this._register(new DropdownMenu(container, options));\n        this._register(this.dropdownMenu.onDidChangeVisibility(visible => {\n            var _a;\n            (_a = this.element) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-expanded', `${visible}`);\n            this._onDidChangeVisibility.fire(visible);\n        }));\n        this.dropdownMenu.menuOptions = {\n            actionViewItemProvider: this.options.actionViewItemProvider,\n            actionRunner: this.actionRunner,\n            getKeyBinding: this.options.keybindingProvider,\n            context: this._context\n        };\n        if (this.options.anchorAlignmentProvider) {\n            const that = this;\n            this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {\n                    return that.options.anchorAlignmentProvider();\n                } });\n        }\n        this.updateEnabled();\n    }\n    setActionContext(newContext) {\n        super.setActionContext(newContext);\n        if (this.dropdownMenu) {\n            if (this.dropdownMenu.menuOptions) {\n                this.dropdownMenu.menuOptions.context = newContext;\n            }\n            else {\n                this.dropdownMenu.menuOptions = { context: newContext };\n            }\n        }\n    }\n    updateEnabled() {\n        var _a, _b;\n        const disabled = !this.getAction().enabled;\n        (_a = this.actionItem) === null || _a === void 0 ? void 0 : _a.classList.toggle('disabled', disabled);\n        (_b = this.element) === null || _b === void 0 ? void 0 : _b.classList.toggle('disabled', disabled);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { $, addDisposableListener, append, asCSSUrl, EventType, ModifierKeyEmitter, prepend } from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { ActionViewItem, BaseActionViewItem } from '../../../base/browser/ui/actionbar/actionViewItems.js';\nimport { DropdownMenuActionViewItem } from '../../../base/browser/ui/dropdown/dropdownActionViewItem.js';\nimport { ActionRunner, Separator, SubmenuAction } from '../../../base/common/actions.js';\nimport { UILabelProvider } from '../../../base/common/keybindingLabels.js';\nimport { DisposableStore, MutableDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { isLinux, isWindows, OS } from '../../../base/common/platform.js';\nimport './menuEntryActionViewItem.css';\nimport { localize } from '../../../nls.js';\nimport { IMenuService, MenuItemAction, SubmenuItemAction } from '../common/actions.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../contextview/browser/contextView.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { ThemeIcon } from '../../theme/common/themeService.js';\nexport function createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {\n    const groups = menu.getActions(options);\n    const isPrimaryAction = typeof primaryGroup === 'string' ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;\n    // Action bars handle alternative actions on their own so the alternative actions should be ignored\n    fillInActions(groups, target, false, isPrimaryAction, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);\n    return asDisposable(groups);\n}\nfunction asDisposable(groups) {\n    const disposables = new DisposableStore();\n    for (const [, actions] of groups) {\n        for (const action of actions) {\n            disposables.add(action);\n        }\n    }\n    return disposables;\n}\nfunction fillInActions(groups, target, useAlternativeActions, isPrimaryAction = actionGroup => actionGroup === 'navigation', primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {\n    let primaryBucket;\n    let secondaryBucket;\n    if (Array.isArray(target)) {\n        primaryBucket = target;\n        secondaryBucket = target;\n    }\n    else {\n        primaryBucket = target.primary;\n        secondaryBucket = target.secondary;\n    }\n    const submenuInfo = new Set();\n    for (const [group, actions] of groups) {\n        let target;\n        if (isPrimaryAction(group)) {\n            target = primaryBucket;\n            if (target.length > 0 && useSeparatorsInPrimaryActions) {\n                target.push(new Separator());\n            }\n        }\n        else {\n            target = secondaryBucket;\n            if (target.length > 0) {\n                target.push(new Separator());\n            }\n        }\n        for (let action of actions) {\n            if (useAlternativeActions) {\n                action = action instanceof MenuItemAction && action.alt ? action.alt : action;\n            }\n            const newLen = target.push(action);\n            // keep submenu info for later inlining\n            if (action instanceof SubmenuAction) {\n                submenuInfo.add({ group, action, index: newLen - 1 });\n            }\n        }\n    }\n    // ask the outside if submenu should be inlined or not. only ask when\n    // there would be enough space\n    for (const { group, action, index } of submenuInfo) {\n        const target = isPrimaryAction(group) ? primaryBucket : secondaryBucket;\n        // inlining submenus with length 0 or 1 is easy,\n        // larger submenus need to be checked with the overall limit\n        const submenuActions = action.actions;\n        if ((submenuActions.length <= 1 || target.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target.length)) {\n            target.splice(index, 1, ...submenuActions);\n        }\n    }\n    // overflow items from the primary group into the secondary bucket\n    if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {\n        const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);\n        secondaryBucket.unshift(...overflow, new Separator());\n    }\n}\nlet MenuEntryActionViewItem = class MenuEntryActionViewItem extends ActionViewItem {\n    constructor(_action, options, _keybindingService, _notificationService, _contextKeyService) {\n        super(undefined, _action, { icon: !!(_action.class || _action.item.icon), label: !_action.class && !_action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable });\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextKeyService = _contextKeyService;\n        this._wantsAltCommand = false;\n        this._itemClassDispose = this._register(new MutableDisposable());\n        this._altKey = ModifierKeyEmitter.getInstance();\n    }\n    get _menuItemAction() {\n        return this._action;\n    }\n    get _commandAction() {\n        return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;\n    }\n    onClick(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            event.preventDefault();\n            event.stopPropagation();\n            try {\n                yield this.actionRunner.run(this._commandAction, this._context);\n            }\n            catch (err) {\n                this._notificationService.error(err);\n            }\n        });\n    }\n    render(container) {\n        super.render(container);\n        container.classList.add('menu-entry');\n        this._updateItemClass(this._menuItemAction.item);\n        let mouseOver = false;\n        let alternativeKeyDown = this._altKey.keyStatus.altKey || ((isWindows || isLinux) && this._altKey.keyStatus.shiftKey);\n        const updateAltState = () => {\n            const wantsAltCommand = mouseOver && alternativeKeyDown;\n            if (wantsAltCommand !== this._wantsAltCommand) {\n                this._wantsAltCommand = wantsAltCommand;\n                this.updateLabel();\n                this.updateTooltip();\n                this.updateClass();\n            }\n        };\n        if (this._menuItemAction.alt) {\n            this._register(this._altKey.event(value => {\n                alternativeKeyDown = value.altKey || ((isWindows || isLinux) && value.shiftKey);\n                updateAltState();\n            }));\n        }\n        this._register(addDisposableListener(container, 'mouseleave', _ => {\n            mouseOver = false;\n            updateAltState();\n        }));\n        this._register(addDisposableListener(container, 'mouseenter', _ => {\n            mouseOver = true;\n            updateAltState();\n        }));\n    }\n    updateLabel() {\n        if (this.options.label && this.label) {\n            this.label.textContent = this._commandAction.label;\n        }\n    }\n    updateTooltip() {\n        if (this.label) {\n            const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);\n            const keybindingLabel = keybinding && keybinding.getLabel();\n            const tooltip = this._commandAction.tooltip || this._commandAction.label;\n            let title = keybindingLabel\n                ? localize('titleAndKb', \"{0} ({1})\", tooltip, keybindingLabel)\n                : tooltip;\n            if (!this._wantsAltCommand && this._menuItemAction.alt) {\n                const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;\n                const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);\n                const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();\n                const altTitleSection = altKeybindingLabel\n                    ? localize('titleAndKb', \"{0} ({1})\", altTooltip, altKeybindingLabel)\n                    : altTooltip;\n                title += `\\n[${UILabelProvider.modifierLabels[OS].altKey}] ${altTitleSection}`;\n            }\n            this.label.title = title;\n        }\n    }\n    updateClass() {\n        if (this.options.icon) {\n            if (this._commandAction !== this._menuItemAction) {\n                if (this._menuItemAction.alt) {\n                    this._updateItemClass(this._menuItemAction.alt.item);\n                }\n            }\n            else if (this._menuItemAction.alt) {\n                this._updateItemClass(this._menuItemAction.item);\n            }\n        }\n    }\n    _updateItemClass(item) {\n        var _a;\n        this._itemClassDispose.value = undefined;\n        const { element, label } = this;\n        if (!element || !label) {\n            return;\n        }\n        const icon = this._commandAction.checked && ((_a = item.toggled) === null || _a === void 0 ? void 0 : _a.icon) ? item.toggled.icon : item.icon;\n        if (!icon) {\n            return;\n        }\n        if (ThemeIcon.isThemeIcon(icon)) {\n            // theme icons\n            const iconClasses = ThemeIcon.asClassNameArray(icon);\n            label.classList.add(...iconClasses);\n            this._itemClassDispose.value = toDisposable(() => {\n                label.classList.remove(...iconClasses);\n            });\n        }\n        else {\n            // icon path/url\n            if (icon.light) {\n                label.style.setProperty('--menu-entry-icon-light', asCSSUrl(icon.light));\n            }\n            if (icon.dark) {\n                label.style.setProperty('--menu-entry-icon-dark', asCSSUrl(icon.dark));\n            }\n            label.classList.add('icon');\n            this._itemClassDispose.value = toDisposable(() => {\n                label.classList.remove('icon');\n                label.style.removeProperty('--menu-entry-icon-light');\n                label.style.removeProperty('--menu-entry-icon-dark');\n            });\n        }\n    }\n};\nMenuEntryActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextKeyService)\n], MenuEntryActionViewItem);\nexport { MenuEntryActionViewItem };\nlet SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem extends DropdownMenuActionViewItem {\n    constructor(action, options, contextMenuService) {\n        var _a, _b;\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : false,\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : (ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : undefined),\n        });\n        super(action, { getActions: () => action.actions }, contextMenuService, dropdownOptions);\n    }\n    render(container) {\n        super.render(container);\n        if (this.element) {\n            container.classList.add('menu-entry');\n            const { icon } = this._action.item;\n            if (icon && !ThemeIcon.isThemeIcon(icon)) {\n                this.element.classList.add('icon');\n                if (icon.light) {\n                    this.element.style.setProperty('--menu-entry-icon-light', asCSSUrl(icon.light));\n                }\n                if (icon.dark) {\n                    this.element.style.setProperty('--menu-entry-icon-dark', asCSSUrl(icon.dark));\n                }\n            }\n        }\n    }\n};\nSubmenuEntryActionViewItem = __decorate([\n    __param(2, IContextMenuService)\n], SubmenuEntryActionViewItem);\nexport { SubmenuEntryActionViewItem };\nlet DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends BaseActionViewItem {\n    constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {\n        var _a, _b, _c;\n        super(null, submenuAction);\n        this._keybindingService = _keybindingService;\n        this._notificationService = _notificationService;\n        this._contextMenuService = _contextMenuService;\n        this._menuService = _menuService;\n        this._instaService = _instaService;\n        this._storageService = _storageService;\n        this._container = null;\n        this._storageKey = `${submenuAction.item.submenu._debugName}_lastActionId`;\n        // determine default action\n        let defaultAction;\n        let defaultActionId = _storageService.get(this._storageKey, 1 /* WORKSPACE */);\n        if (defaultActionId) {\n            defaultAction = submenuAction.actions.find(a => defaultActionId === a.id);\n        }\n        if (!defaultAction) {\n            defaultAction = submenuAction.actions[0];\n        }\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, undefined);\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : true,\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : ['codicon', 'codicon-chevron-down'],\n            actionRunner: (_c = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c !== void 0 ? _c : new ActionRunner()\n        });\n        this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);\n        this._dropdown.actionRunner.onDidRun((e) => {\n            if (e.action instanceof MenuItemAction) {\n                this.update(e.action);\n            }\n        });\n    }\n    update(lastAction) {\n        this._storageService.store(this._storageKey, lastAction.id, 1 /* WORKSPACE */, 0 /* USER */);\n        this._defaultAction.dispose();\n        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, undefined);\n        this._defaultAction.actionRunner = new class extends ActionRunner {\n            runAction(action, context) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    yield action.run(undefined);\n                });\n            }\n        }();\n        if (this._container) {\n            this._defaultAction.render(prepend(this._container, $('.action-container')));\n        }\n    }\n    setActionContext(newContext) {\n        super.setActionContext(newContext);\n        this._defaultAction.setActionContext(newContext);\n        this._dropdown.setActionContext(newContext);\n    }\n    render(container) {\n        this._container = container;\n        super.render(this._container);\n        this._container.classList.add('monaco-dropdown-with-default');\n        const primaryContainer = $('.action-container');\n        this._defaultAction.render(append(this._container, primaryContainer));\n        this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(17 /* RightArrow */)) {\n                this._defaultAction.element.tabIndex = -1;\n                this._dropdown.focus();\n                event.stopPropagation();\n            }\n        }));\n        const dropdownContainer = $('.dropdown-action-container');\n        this._dropdown.render(append(this._container, dropdownContainer));\n        this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {\n            var _a;\n            const event = new StandardKeyboardEvent(e);\n            if (event.equals(15 /* LeftArrow */)) {\n                this._defaultAction.element.tabIndex = 0;\n                this._dropdown.setFocusable(false);\n                (_a = this._defaultAction.element) === null || _a === void 0 ? void 0 : _a.focus();\n                event.stopPropagation();\n            }\n        }));\n    }\n    focus(fromRight) {\n        if (fromRight) {\n            this._dropdown.focus();\n        }\n        else {\n            this._defaultAction.element.tabIndex = 0;\n            this._defaultAction.element.focus();\n        }\n    }\n    blur() {\n        this._defaultAction.element.tabIndex = -1;\n        this._dropdown.blur();\n        this._container.blur();\n    }\n    setFocusable(focusable) {\n        if (focusable) {\n            this._defaultAction.element.tabIndex = 0;\n        }\n        else {\n            this._defaultAction.element.tabIndex = -1;\n            this._dropdown.setFocusable(false);\n        }\n    }\n    dispose() {\n        this._defaultAction.dispose();\n        this._dropdown.dispose();\n        super.dispose();\n    }\n};\nDropdownWithDefaultActionViewItem = __decorate([\n    __param(2, IKeybindingService),\n    __param(3, INotificationService),\n    __param(4, IContextMenuService),\n    __param(5, IMenuService),\n    __param(6, IInstantiationService),\n    __param(7, IStorageService)\n], DropdownWithDefaultActionViewItem);\n/**\n * Creates action view items for menu actions or submenu actions.\n */\nexport function createActionViewItem(instaService, action, options) {\n    if (action instanceof MenuItemAction) {\n        return instaService.createInstance(MenuEntryActionViewItem, action, undefined);\n    }\n    else if (action instanceof SubmenuItemAction) {\n        if (action.item.rememberDefaultAction) {\n            return instaService.createInstance(DropdownWithDefaultActionViewItem, action, options);\n        }\n        else {\n            return instaService.createInstance(SubmenuEntryActionViewItem, action, options);\n        }\n    }\n    else {\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Separator, SubmenuAction } from '../../../base/common/actions.js';\nimport { CSSIcon } from '../../../base/common/codicons.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { ThemeIcon } from '../../theme/common/themeService.js';\nexport function isIMenuItem(item) {\n    return item.command !== undefined;\n}\nexport class MenuId {\n    constructor(debugName) {\n        this.id = MenuId._idPool++;\n        this._debugName = debugName;\n    }\n}\nMenuId._idPool = 0;\nMenuId.CommandPalette = new MenuId('CommandPalette');\nMenuId.DebugBreakpointsContext = new MenuId('DebugBreakpointsContext');\nMenuId.DebugCallStackContext = new MenuId('DebugCallStackContext');\nMenuId.DebugConsoleContext = new MenuId('DebugConsoleContext');\nMenuId.DebugVariablesContext = new MenuId('DebugVariablesContext');\nMenuId.DebugWatchContext = new MenuId('DebugWatchContext');\nMenuId.DebugToolBar = new MenuId('DebugToolBar');\nMenuId.EditorContext = new MenuId('EditorContext');\nMenuId.SimpleEditorContext = new MenuId('SimpleEditorContext');\nMenuId.EditorContextCopy = new MenuId('EditorContextCopy');\nMenuId.EditorContextPeek = new MenuId('EditorContextPeek');\nMenuId.EditorTitle = new MenuId('EditorTitle');\nMenuId.EditorTitleRun = new MenuId('EditorTitleRun');\nMenuId.EditorTitleContext = new MenuId('EditorTitleContext');\nMenuId.EmptyEditorGroup = new MenuId('EmptyEditorGroup');\nMenuId.EmptyEditorGroupContext = new MenuId('EmptyEditorGroupContext');\nMenuId.ExplorerContext = new MenuId('ExplorerContext');\nMenuId.ExtensionContext = new MenuId('ExtensionContext');\nMenuId.GlobalActivity = new MenuId('GlobalActivity');\nMenuId.LayoutControlMenuSubmenu = new MenuId('LayoutControlMenuSubmenu');\nMenuId.LayoutControlMenu = new MenuId('LayoutControlMenu');\nMenuId.MenubarMainMenu = new MenuId('MenubarMainMenu');\nMenuId.MenubarAppearanceMenu = new MenuId('MenubarAppearanceMenu');\nMenuId.MenubarDebugMenu = new MenuId('MenubarDebugMenu');\nMenuId.MenubarEditMenu = new MenuId('MenubarEditMenu');\nMenuId.MenubarCopy = new MenuId('MenubarCopy');\nMenuId.MenubarFileMenu = new MenuId('MenubarFileMenu');\nMenuId.MenubarGoMenu = new MenuId('MenubarGoMenu');\nMenuId.MenubarHelpMenu = new MenuId('MenubarHelpMenu');\nMenuId.MenubarLayoutMenu = new MenuId('MenubarLayoutMenu');\nMenuId.MenubarNewBreakpointMenu = new MenuId('MenubarNewBreakpointMenu');\nMenuId.MenubarPanelAlignmentMenu = new MenuId('MenubarPanelAlignmentMenu');\nMenuId.MenubarPanelPositionMenu = new MenuId('MenubarPanelPositionMenu');\nMenuId.MenubarPreferencesMenu = new MenuId('MenubarPreferencesMenu');\nMenuId.MenubarRecentMenu = new MenuId('MenubarRecentMenu');\nMenuId.MenubarSelectionMenu = new MenuId('MenubarSelectionMenu');\nMenuId.MenubarSwitchEditorMenu = new MenuId('MenubarSwitchEditorMenu');\nMenuId.MenubarSwitchGroupMenu = new MenuId('MenubarSwitchGroupMenu');\nMenuId.MenubarTerminalMenu = new MenuId('MenubarTerminalMenu');\nMenuId.MenubarViewMenu = new MenuId('MenubarViewMenu');\nMenuId.MenubarHomeMenu = new MenuId('MenubarHomeMenu');\nMenuId.OpenEditorsContext = new MenuId('OpenEditorsContext');\nMenuId.ProblemsPanelContext = new MenuId('ProblemsPanelContext');\nMenuId.SCMChangeContext = new MenuId('SCMChangeContext');\nMenuId.SCMResourceContext = new MenuId('SCMResourceContext');\nMenuId.SCMResourceFolderContext = new MenuId('SCMResourceFolderContext');\nMenuId.SCMResourceGroupContext = new MenuId('SCMResourceGroupContext');\nMenuId.SCMSourceControl = new MenuId('SCMSourceControl');\nMenuId.SCMTitle = new MenuId('SCMTitle');\nMenuId.SearchContext = new MenuId('SearchContext');\nMenuId.StatusBarWindowIndicatorMenu = new MenuId('StatusBarWindowIndicatorMenu');\nMenuId.StatusBarRemoteIndicatorMenu = new MenuId('StatusBarRemoteIndicatorMenu');\nMenuId.TestItem = new MenuId('TestItem');\nMenuId.TestItemGutter = new MenuId('TestItemGutter');\nMenuId.TestPeekElement = new MenuId('TestPeekElement');\nMenuId.TestPeekTitle = new MenuId('TestPeekTitle');\nMenuId.TouchBarContext = new MenuId('TouchBarContext');\nMenuId.TitleBarContext = new MenuId('TitleBarContext');\nMenuId.TunnelContext = new MenuId('TunnelContext');\nMenuId.TunnelPrivacy = new MenuId('TunnelPrivacy');\nMenuId.TunnelProtocol = new MenuId('TunnelProtocol');\nMenuId.TunnelPortInline = new MenuId('TunnelInline');\nMenuId.TunnelTitle = new MenuId('TunnelTitle');\nMenuId.TunnelLocalAddressInline = new MenuId('TunnelLocalAddressInline');\nMenuId.TunnelOriginInline = new MenuId('TunnelOriginInline');\nMenuId.ViewItemContext = new MenuId('ViewItemContext');\nMenuId.ViewContainerTitle = new MenuId('ViewContainerTitle');\nMenuId.ViewContainerTitleContext = new MenuId('ViewContainerTitleContext');\nMenuId.ViewTitle = new MenuId('ViewTitle');\nMenuId.ViewTitleContext = new MenuId('ViewTitleContext');\nMenuId.CommentThreadTitle = new MenuId('CommentThreadTitle');\nMenuId.CommentThreadActions = new MenuId('CommentThreadActions');\nMenuId.CommentTitle = new MenuId('CommentTitle');\nMenuId.CommentActions = new MenuId('CommentActions');\nMenuId.InteractiveToolbar = new MenuId('InteractiveToolbar');\nMenuId.InteractiveCellTitle = new MenuId('InteractiveCellTitle');\nMenuId.InteractiveCellExecute = new MenuId('InteractiveCellExecute');\nMenuId.InteractiveInputExecute = new MenuId('InteractiveInputExecute');\nMenuId.NotebookToolbar = new MenuId('NotebookToolbar');\nMenuId.NotebookCellTitle = new MenuId('NotebookCellTitle');\nMenuId.NotebookCellInsert = new MenuId('NotebookCellInsert');\nMenuId.NotebookCellBetween = new MenuId('NotebookCellBetween');\nMenuId.NotebookCellListTop = new MenuId('NotebookCellTop');\nMenuId.NotebookCellExecute = new MenuId('NotebookCellExecute');\nMenuId.NotebookCellExecutePrimary = new MenuId('NotebookCellExecutePrimary');\nMenuId.NotebookDiffCellInputTitle = new MenuId('NotebookDiffCellInputTitle');\nMenuId.NotebookDiffCellMetadataTitle = new MenuId('NotebookDiffCellMetadataTitle');\nMenuId.NotebookDiffCellOutputsTitle = new MenuId('NotebookDiffCellOutputsTitle');\nMenuId.NotebookOutputToolbar = new MenuId('NotebookOutputToolbar');\nMenuId.NotebookEditorLayoutConfigure = new MenuId('NotebookEditorLayoutConfigure');\nMenuId.BulkEditTitle = new MenuId('BulkEditTitle');\nMenuId.BulkEditContext = new MenuId('BulkEditContext');\nMenuId.TimelineItemContext = new MenuId('TimelineItemContext');\nMenuId.TimelineTitle = new MenuId('TimelineTitle');\nMenuId.TimelineTitleContext = new MenuId('TimelineTitleContext');\nMenuId.AccountsContext = new MenuId('AccountsContext');\nMenuId.PanelTitle = new MenuId('PanelTitle');\nMenuId.AuxiliaryBarTitle = new MenuId('AuxiliaryBarTitle');\nMenuId.TerminalInstanceContext = new MenuId('TerminalInstanceContext');\nMenuId.TerminalEditorInstanceContext = new MenuId('TerminalEditorInstanceContext');\nMenuId.TerminalNewDropdownContext = new MenuId('TerminalNewDropdownContext');\nMenuId.TerminalTabContext = new MenuId('TerminalTabContext');\nMenuId.TerminalTabEmptyAreaContext = new MenuId('TerminalTabEmptyAreaContext');\nMenuId.TerminalInlineTabContext = new MenuId('TerminalInlineTabContext');\nMenuId.WebviewContext = new MenuId('WebviewContext');\nMenuId.InlineCompletionsActions = new MenuId('InlineCompletionsActions');\nMenuId.NewFile = new MenuId('NewFile');\nexport const IMenuService = createDecorator('menuService');\nexport const MenuRegistry = new class {\n    constructor() {\n        this._commands = new Map();\n        this._menuItems = new Map();\n        this._onDidChangeMenu = new Emitter();\n        this.onDidChangeMenu = this._onDidChangeMenu.event;\n        this._commandPaletteChangeEvent = {\n            has: id => id === MenuId.CommandPalette\n        };\n    }\n    addCommand(command) {\n        return this.addCommands(Iterable.single(command));\n    }\n    addCommands(commands) {\n        for (const command of commands) {\n            this._commands.set(command.id, command);\n        }\n        this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);\n        return toDisposable(() => {\n            let didChange = false;\n            for (const command of commands) {\n                didChange = this._commands.delete(command.id) || didChange;\n            }\n            if (didChange) {\n                this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);\n            }\n        });\n    }\n    getCommand(id) {\n        return this._commands.get(id);\n    }\n    getCommands() {\n        const map = new Map();\n        this._commands.forEach((value, key) => map.set(key, value));\n        return map;\n    }\n    appendMenuItem(id, item) {\n        return this.appendMenuItems(Iterable.single({ id, item }));\n    }\n    appendMenuItems(items) {\n        const changedIds = new Set();\n        const toRemove = new LinkedList();\n        for (const { id, item } of items) {\n            let list = this._menuItems.get(id);\n            if (!list) {\n                list = new LinkedList();\n                this._menuItems.set(id, list);\n            }\n            toRemove.push(list.push(item));\n            changedIds.add(id);\n        }\n        this._onDidChangeMenu.fire(changedIds);\n        return toDisposable(() => {\n            if (toRemove.size > 0) {\n                for (let fn of toRemove) {\n                    fn();\n                }\n                this._onDidChangeMenu.fire(changedIds);\n                toRemove.clear();\n            }\n        });\n    }\n    getMenuItems(id) {\n        let result;\n        if (this._menuItems.has(id)) {\n            result = [...this._menuItems.get(id)];\n        }\n        else {\n            result = [];\n        }\n        if (id === MenuId.CommandPalette) {\n            // CommandPalette is special because it shows\n            // all commands by default\n            this._appendImplicitItems(result);\n        }\n        return result;\n    }\n    _appendImplicitItems(result) {\n        const set = new Set();\n        for (const item of result) {\n            if (isIMenuItem(item)) {\n                set.add(item.command.id);\n                if (item.alt) {\n                    set.add(item.alt.id);\n                }\n            }\n        }\n        this._commands.forEach((command, id) => {\n            if (!set.has(id)) {\n                result.push({ command });\n            }\n        });\n    }\n};\nexport class SubmenuItemAction extends SubmenuAction {\n    constructor(item, _menuService, _contextKeyService, _options) {\n        super(`submenuitem.${item.submenu.id}`, typeof item.title === 'string' ? item.title : item.title.value, [], 'submenu');\n        this.item = item;\n        this._menuService = _menuService;\n        this._contextKeyService = _contextKeyService;\n        this._options = _options;\n    }\n    get actions() {\n        const result = [];\n        const menu = this._menuService.createMenu(this.item.submenu, this._contextKeyService);\n        const groups = menu.getActions(this._options);\n        menu.dispose();\n        for (const [, actions] of groups) {\n            if (actions.length > 0) {\n                result.push(...actions);\n                result.push(new Separator());\n            }\n        }\n        if (result.length) {\n            result.pop(); // remove last separator\n        }\n        return result;\n    }\n}\n// implements IAction, does NOT extend Action, so that no one\n// subscribes to events of Action or modified properties\nlet MenuItemAction = class MenuItemAction {\n    constructor(item, alt, options, contextKeyService, _commandService) {\n        var _a, _b;\n        this._commandService = _commandService;\n        this.id = item.id;\n        this.label = (options === null || options === void 0 ? void 0 : options.renderShortTitle) && item.shortTitle\n            ? (typeof item.shortTitle === 'string' ? item.shortTitle : item.shortTitle.value)\n            : (typeof item.title === 'string' ? item.title : item.title.value);\n        this.tooltip = (_b = (typeof item.tooltip === 'string' ? item.tooltip : (_a = item.tooltip) === null || _a === void 0 ? void 0 : _a.value)) !== null && _b !== void 0 ? _b : '';\n        this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);\n        this.checked = undefined;\n        if (item.toggled) {\n            const toggled = (item.toggled.condition ? item.toggled : { condition: item.toggled });\n            this.checked = contextKeyService.contextMatchesRules(toggled.condition);\n            if (this.checked && toggled.tooltip) {\n                this.tooltip = typeof toggled.tooltip === 'string' ? toggled.tooltip : toggled.tooltip.value;\n            }\n            if (toggled.title) {\n                this.label = typeof toggled.title === 'string' ? toggled.title : toggled.title.value;\n            }\n        }\n        this.item = item;\n        this.alt = alt ? new MenuItemAction(alt, undefined, options, contextKeyService, _commandService) : undefined;\n        this._options = options;\n        if (ThemeIcon.isThemeIcon(item.icon)) {\n            this.class = CSSIcon.asClassName(item.icon);\n        }\n    }\n    dispose() {\n        // there is NOTHING to dispose and the MenuItemAction should\n        // never have anything to dispose as it is a convenience type\n        // to bridge into the rendering world.\n    }\n    run(...args) {\n        var _a, _b;\n        let runArgs = [];\n        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.arg) {\n            runArgs = [...runArgs, this._options.arg];\n        }\n        if ((_b = this._options) === null || _b === void 0 ? void 0 : _b.shouldForwardArgs) {\n            runArgs = [...runArgs, ...args];\n        }\n        return this._commandService.executeCommand(this.id, ...runArgs);\n    }\n};\nMenuItemAction = __decorate([\n    __param(3, IContextKeyService),\n    __param(4, ICommandService)\n], MenuItemAction);\nexport { MenuItemAction };\n//#endregion\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IClipboardService = createDecorator('clipboardService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { validateConstraints } from '../../../base/common/types.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ICommandService = createDecorator('commandService');\nexport const CommandsRegistry = new class {\n    constructor() {\n        this._commands = new Map();\n        this._onDidRegisterCommand = new Emitter();\n        this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n    }\n    registerCommand(idOrCommand, handler) {\n        if (!idOrCommand) {\n            throw new Error(`invalid command`);\n        }\n        if (typeof idOrCommand === 'string') {\n            if (!handler) {\n                throw new Error(`invalid command`);\n            }\n            return this.registerCommand({ id: idOrCommand, handler });\n        }\n        // add argument validation if rich command metadata is provided\n        if (idOrCommand.description) {\n            const constraints = [];\n            for (let arg of idOrCommand.description.args) {\n                constraints.push(arg.constraint);\n            }\n            const actualHandler = idOrCommand.handler;\n            idOrCommand.handler = function (accessor, ...args) {\n                validateConstraints(args, constraints);\n                return actualHandler(accessor, ...args);\n            };\n        }\n        // find a place to store the command\n        const { id } = idOrCommand;\n        let commands = this._commands.get(id);\n        if (!commands) {\n            commands = new LinkedList();\n            this._commands.set(id, commands);\n        }\n        let removeFn = commands.unshift(idOrCommand);\n        let ret = toDisposable(() => {\n            removeFn();\n            const command = this._commands.get(id);\n            if (command === null || command === void 0 ? void 0 : command.isEmpty()) {\n                this._commands.delete(id);\n            }\n        });\n        // tell the world about this command\n        this._onDidRegisterCommand.fire(id);\n        return ret;\n    }\n    registerCommandAlias(oldId, newId) {\n        return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n    }\n    getCommand(id) {\n        const list = this._commands.get(id);\n        if (!list || list.isEmpty()) {\n            return undefined;\n        }\n        return Iterable.first(list);\n    }\n    getCommands() {\n        const result = new Map();\n        for (const key of this._commands.keys()) {\n            const command = this.getCommand(key);\n            if (command) {\n                result.set(key, command);\n            }\n        }\n        return result;\n    }\n};\nexport const NullCommandService = {\n    _serviceBrand: undefined,\n    onWillExecuteCommand: () => Disposable.None,\n    onDidExecuteCommand: () => Disposable.None,\n    executeCommand() {\n        return Promise.resolve(undefined);\n    }\n};\nCommandsRegistry.registerCommand('noop', () => { });\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IConfigurationService = createDecorator('configurationService');\nexport function toValuesTree(properties, conflictReporter) {\n    const root = Object.create(null);\n    for (let key in properties) {\n        addToValueTree(root, key, properties[key], conflictReporter);\n    }\n    return root;\n}\nexport function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        let s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'undefined':\n                obj = curr[s] = Object.create(null);\n                break;\n            case 'object':\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object' && curr !== null) {\n        try {\n            curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n        }\n        catch (e) {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nexport function removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        // Reached last segment\n        delete valueTree[first];\n        return;\n    }\n    if (Object.keys(valueTree).indexOf(first) !== -1) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (Object.keys(value).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (const component of path) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[component];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../base/common/arrays.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport * as types from '../../../base/common/types.js';\nimport * as nls from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nexport const Extensions = {\n    Configuration: 'base.contributions.configuration'\n};\nexport const allSettings = { properties: {}, patternProperties: {} };\nexport const applicationSettings = { properties: {}, patternProperties: {} };\nexport const machineSettings = { properties: {}, patternProperties: {} };\nexport const machineOverridableSettings = { properties: {}, patternProperties: {} };\nexport const windowSettings = { properties: {}, patternProperties: {} };\nexport const resourceSettings = { properties: {}, patternProperties: {} };\nexport const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';\nconst contributionRegistry = Registry.as(JSONExtensions.JSONContribution);\nclass ConfigurationRegistry {\n    constructor() {\n        this.overrideIdentifiers = new Set();\n        this._onDidSchemaChange = new Emitter();\n        this._onDidUpdateConfiguration = new Emitter();\n        this.configurationDefaultsOverrides = new Map();\n        this.defaultLanguageConfigurationOverridesNode = {\n            id: 'defaultOverrides',\n            title: nls.localize('defaultLanguageConfigurationOverrides.title', \"Default Language Configuration Overrides\"),\n            properties: {}\n        };\n        this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];\n        this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting', allowTrailingCommas: true, allowComments: true };\n        this.configurationProperties = {};\n        this.excludedConfigurationProperties = {};\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this.registerOverridePropertyPatternKey();\n    }\n    registerConfiguration(configuration, validate = true) {\n        this.registerConfigurations([configuration], validate);\n    }\n    registerConfigurations(configurations, validate = true) {\n        const properties = this.doRegisterConfigurations(configurations, validate);\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties });\n    }\n    registerDefaultConfigurations(configurationDefaults) {\n        var _a;\n        const properties = [];\n        const overrideIdentifiers = [];\n        for (const { overrides, source } of configurationDefaults) {\n            for (const key in overrides) {\n                properties.push(key);\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    const defaultValue = Object.assign(Object.assign({}, (((_a = this.configurationDefaultsOverrides.get(key)) === null || _a === void 0 ? void 0 : _a.value) || {})), overrides[key]);\n                    this.configurationDefaultsOverrides.set(key, { source, value: defaultValue });\n                    const property = {\n                        type: 'object',\n                        default: defaultValue,\n                        description: nls.localize('defaultLanguageConfiguration.description', \"Configure settings to be overridden for {0} language.\", key),\n                        $ref: resourceLanguageSettingsSchemaId,\n                        defaultDefaultValue: defaultValue,\n                        source: types.isString(source) ? undefined : source,\n                    };\n                    overrideIdentifiers.push(...overrideIdentifiersFromKey(key));\n                    this.configurationProperties[key] = property;\n                    this.defaultLanguageConfigurationOverridesNode.properties[key] = property;\n                }\n                else {\n                    this.configurationDefaultsOverrides.set(key, { value: overrides[key], source });\n                    const property = this.configurationProperties[key];\n                    if (property) {\n                        this.updatePropertyDefaultValue(key, property);\n                        this.updateSchema(key, property);\n                    }\n                }\n            }\n        }\n        this.registerOverrideIdentifiers(overrideIdentifiers);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });\n    }\n    registerOverrideIdentifiers(overrideIdentifiers) {\n        for (const overrideIdentifier of overrideIdentifiers) {\n            this.overrideIdentifiers.add(overrideIdentifier);\n        }\n        this.updateOverridePropertyPatternKey();\n    }\n    doRegisterConfigurations(configurations, validate) {\n        const properties = [];\n        configurations.forEach(configuration => {\n            properties.push(...this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties)); // fills in defaults\n            this.configurationContributors.push(configuration);\n            this.registerJSONConfiguration(configuration);\n        });\n        return properties;\n    }\n    validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3 /* WINDOW */) {\n        scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;\n        let propertyKeys = [];\n        let properties = configuration.properties;\n        if (properties) {\n            for (let key in properties) {\n                if (validate && validateProperty(key)) {\n                    delete properties[key];\n                    continue;\n                }\n                const property = properties[key];\n                property.source = extensionInfo;\n                // update default value\n                property.defaultDefaultValue = properties[key].default;\n                this.updatePropertyDefaultValue(key, property);\n                // update scope\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    property.scope = undefined; // No scope for overridable properties `[${identifier}]`\n                }\n                else {\n                    property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;\n                    property.restricted = types.isUndefinedOrNull(property.restricted) ? !!(restrictedProperties === null || restrictedProperties === void 0 ? void 0 : restrictedProperties.includes(key)) : property.restricted;\n                }\n                // Add to properties maps\n                // Property is included by default if 'included' is unspecified\n                if (properties[key].hasOwnProperty('included') && !properties[key].included) {\n                    this.excludedConfigurationProperties[key] = properties[key];\n                    delete properties[key];\n                    continue;\n                }\n                else {\n                    this.configurationProperties[key] = properties[key];\n                }\n                if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {\n                    // If not set, default deprecationMessage to the markdown source\n                    properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;\n                }\n                propertyKeys.push(key);\n            }\n        }\n        let subNodes = configuration.allOf;\n        if (subNodes) {\n            for (let node of subNodes) {\n                propertyKeys.push(...this.validateAndRegisterProperties(node, validate, extensionInfo, restrictedProperties, scope));\n            }\n        }\n        return propertyKeys;\n    }\n    getConfigurationProperties() {\n        return this.configurationProperties;\n    }\n    registerJSONConfiguration(configuration) {\n        const register = (configuration) => {\n            let properties = configuration.properties;\n            if (properties) {\n                for (const key in properties) {\n                    this.updateSchema(key, properties[key]);\n                }\n            }\n            let subNodes = configuration.allOf;\n            if (subNodes) {\n                subNodes.forEach(register);\n            }\n        };\n        register(configuration);\n    }\n    updateSchema(key, property) {\n        allSettings.properties[key] = property;\n        switch (property.scope) {\n            case 1 /* APPLICATION */:\n                applicationSettings.properties[key] = property;\n                break;\n            case 2 /* MACHINE */:\n                machineSettings.properties[key] = property;\n                break;\n            case 6 /* MACHINE_OVERRIDABLE */:\n                machineOverridableSettings.properties[key] = property;\n                break;\n            case 3 /* WINDOW */:\n                windowSettings.properties[key] = property;\n                break;\n            case 4 /* RESOURCE */:\n                resourceSettings.properties[key] = property;\n                break;\n            case 5 /* LANGUAGE_OVERRIDABLE */:\n                resourceSettings.properties[key] = property;\n                this.resourceLanguageSettingsSchema.properties[key] = property;\n                break;\n        }\n    }\n    updateOverridePropertyPatternKey() {\n        for (const overrideIdentifier of this.overrideIdentifiers.values()) {\n            const overrideIdentifierProperty = `[${overrideIdentifier}]`;\n            const resourceLanguagePropertiesSchema = {\n                type: 'object',\n                description: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n                errorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n                $ref: resourceLanguageSettingsSchemaId,\n            };\n            this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);\n            allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n        }\n        this._onDidSchemaChange.fire();\n    }\n    registerOverridePropertyPatternKey() {\n        const resourceLanguagePropertiesSchema = {\n            type: 'object',\n            description: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n            errorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n            $ref: resourceLanguageSettingsSchemaId,\n        };\n        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        applicationSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineOverridableSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        windowSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        this._onDidSchemaChange.fire();\n    }\n    updatePropertyDefaultValue(key, property) {\n        const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key);\n        let defaultValue = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.value;\n        let defaultSource = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.source;\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = property.defaultDefaultValue;\n            defaultSource = undefined;\n        }\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = getDefaultValue(property.type);\n        }\n        property.default = defaultValue;\n        property.defaultValueSource = defaultSource;\n    }\n}\nconst OVERRIDE_IDENTIFIER_PATTERN = `\\\\[([^\\\\]]+)\\\\]`;\nconst OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, 'g');\nexport const OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;\nexport const OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);\nexport function overrideIdentifiersFromKey(key) {\n    const identifiers = [];\n    if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n        let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        while (matches === null || matches === void 0 ? void 0 : matches.length) {\n            const identifier = matches[1].trim();\n            if (identifier) {\n                identifiers.push(identifier);\n            }\n            matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        }\n    }\n    return distinct(identifiers);\n}\nexport function getDefaultValue(type) {\n    const t = Array.isArray(type) ? type[0] : type;\n    switch (t) {\n        case 'boolean':\n            return false;\n        case 'integer':\n        case 'number':\n            return 0;\n        case 'string':\n            return '';\n        case 'array':\n            return [];\n        case 'object':\n            return {};\n        default:\n            return null;\n    }\n}\nconst configurationRegistry = new ConfigurationRegistry();\nRegistry.add(Extensions.Configuration, configurationRegistry);\nexport function validateProperty(property) {\n    if (!property.trim()) {\n        return nls.localize('config.property.empty', \"Cannot register an empty property\");\n    }\n    if (OVERRIDE_PROPERTY_REGEX.test(property)) {\n        return nls.localize('config.property.languageDefault', \"Cannot register '{0}'. This matches property pattern '\\\\\\\\[.*\\\\\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.\", property);\n    }\n    if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {\n        return nls.localize('config.property.duplicate', \"Cannot register '{0}'. This property is already registered.\", property);\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static deserialize(serialized, strict = false) {\n        if (!serialized) {\n            return undefined;\n        }\n        return this._deserializeOrExpression(serialized, strict);\n    }\n    static _deserializeOrExpression(serialized, strict) {\n        let pieces = serialized.split('||');\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n    }\n    static _deserializeAndExpression(serialized, strict) {\n        let pieces = serialized.split('&&');\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n    }\n    static _deserializeOne(serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            let pieces = serializedOne.split('!=');\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            let pieces = serializedOne.split('==');\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            let pieces = serializedOne.split('=~');\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf(' in ') >= 0) {\n            let pieces = serializedOne.split(' in ');\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>=');\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>');\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<=');\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<');\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n        }\n        return ContextKeyDefinedExpr.create(serializedOne);\n    }\n    static _deserializeValue(serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        let m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    }\n    static _deserializeRegexValue(serializedValue, strict) {\n        if (isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        let start = serializedValue.indexOf('/');\n        let end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            return null;\n        }\n        let value = serializedValue.slice(start + 1, end);\n        let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            return null;\n        }\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* Defined */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* Equals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* In */;\n        this.negated = null;\n    }\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return (source.indexOf(item) >= 0);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 11 /* NotIn */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotInExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* NotEquals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* Not */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* Greater */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* GreaterEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* Smaller */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* SmallerEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* Regex */;\n        this.negated = null;\n        //\n    }\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        let value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* NotRegex */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* And */;\n    }\n    static create(_expr, negated) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* Or */;\n    }\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate redundant terms\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (implies(expr[i], expr[j])) {\n                        expr.splice(j, 1);\n                        j--;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            let result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null));\n                    }\n                }\n                const isFinished = (result.length === 0);\n                result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n            }\n            this.negated = result[0];\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (q.type === 6 /* And */ && (p.type !== 9 /* Or */ && p.type !== 6 /* And */)) {\n        // covers the case: A implies A && B\n        for (const qTerm of q.expr) {\n            if (p.equals(qTerm)) {\n                return true;\n            }\n        }\n    }\n    const notP = p.negate();\n    const expr = getTerminals(notP).concat(getTerminals(q));\n    expr.sort(cmp);\n    for (let i = 0; i < expr.length; i++) {\n        const a = expr[i];\n        const notA = a.negate();\n        for (let j = i + 1; j < expr.length; j++) {\n            const b = expr[j];\n            if (notA.equals(b)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isIOS, isLinux, isMacintosh, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { localize } from '../../../nls.js';\nimport { RawContextKey } from './contextkey.js';\nexport const IsMacContext = new RawContextKey('isMac', isMacintosh, localize('isMac', \"Whether the operating system is macOS\"));\nexport const IsLinuxContext = new RawContextKey('isLinux', isLinux, localize('isLinux', \"Whether the operating system is Linux\"));\nexport const IsWindowsContext = new RawContextKey('isWindows', isWindows, localize('isWindows', \"Whether the operating system is Windows\"));\nexport const IsWebContext = new RawContextKey('isWeb', isWeb, localize('isWeb', \"Whether the platform is a web browser\"));\nexport const IsMacNativeContext = new RawContextKey('isMacNative', isMacintosh && !isWeb, localize('isMacNative', \"Whether the operating system is macOS on a non-browser platform\"));\nexport const IsIOSContext = new RawContextKey('isIOS', isIOS, localize('isIOS', \"Whether the operating system is iOS\"));\nexport const IsDevelopmentContext = new RawContextKey('isDevelopment', false, true);\nexport const InputFocusedContextKey = 'inputFocus';\nexport const InputFocusedContext = new RawContextKey(InputFocusedContextKey, false, localize('inputFocus', \"Whether keyboard focus is inside an input box\"));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IContextViewService = createDecorator('contextViewService');\nexport const IContextMenuService = createDecorator('contextMenuService');\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IDialogService = createDecorator('dialogService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { CaseSensitiveCheckbox, RegexCheckbox, WholeWordsCheckbox } from './findInputCheckboxes.js';\nimport { HistoryInputBox } from '../inputbox/inputBox.js';\nimport { Widget } from '../widget.js';\nimport { Emitter } from '../../../common/event.js';\nimport './findInput.css';\nimport * as nls from '../../../../nls.js';\nconst NLS_DEFAULT_LABEL = nls.localize('defaultLabel', \"input\");\nexport class FindInput extends Widget {\n    constructor(parent, contextViewProvider, _showOptionButtons, options) {\n        super();\n        this._showOptionButtons = _showOptionButtons;\n        this.fixFocusOnOptionClickEnabled = true;\n        this.imeSessionInProgress = false;\n        this._onDidOptionChange = this._register(new Emitter());\n        this.onDidOptionChange = this._onDidOptionChange.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onMouseDown = this._register(new Emitter());\n        this.onMouseDown = this._onMouseDown.event;\n        this._onInput = this._register(new Emitter());\n        this._onKeyUp = this._register(new Emitter());\n        this._onCaseSensitiveKeyDown = this._register(new Emitter());\n        this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;\n        this._onRegexKeyDown = this._register(new Emitter());\n        this.onRegexKeyDown = this._onRegexKeyDown.event;\n        this._lastHighlightFindOptions = 0;\n        this.contextViewProvider = contextViewProvider;\n        this.placeholder = options.placeholder || '';\n        this.validation = options.validation;\n        this.label = options.label || NLS_DEFAULT_LABEL;\n        this.inputActiveOptionBorder = options.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = options.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = options.inputActiveOptionBackground;\n        this.inputBackground = options.inputBackground;\n        this.inputForeground = options.inputForeground;\n        this.inputBorder = options.inputBorder;\n        this.inputValidationInfoBorder = options.inputValidationInfoBorder;\n        this.inputValidationInfoBackground = options.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = options.inputValidationInfoForeground;\n        this.inputValidationWarningBorder = options.inputValidationWarningBorder;\n        this.inputValidationWarningBackground = options.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = options.inputValidationWarningForeground;\n        this.inputValidationErrorBorder = options.inputValidationErrorBorder;\n        this.inputValidationErrorBackground = options.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = options.inputValidationErrorForeground;\n        const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || '';\n        const appendWholeWordsLabel = options.appendWholeWordsLabel || '';\n        const appendRegexLabel = options.appendRegexLabel || '';\n        const history = options.history || [];\n        const flexibleHeight = !!options.flexibleHeight;\n        const flexibleWidth = !!options.flexibleWidth;\n        const flexibleMaxHeight = options.flexibleMaxHeight;\n        this.domNode = document.createElement('div');\n        this.domNode.classList.add('monaco-findInput');\n        this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {\n            placeholder: this.placeholder || '',\n            ariaLabel: this.label || '',\n            validationOptions: {\n                validation: this.validation\n            },\n            inputBackground: this.inputBackground,\n            inputForeground: this.inputForeground,\n            inputBorder: this.inputBorder,\n            inputValidationInfoBackground: this.inputValidationInfoBackground,\n            inputValidationInfoForeground: this.inputValidationInfoForeground,\n            inputValidationInfoBorder: this.inputValidationInfoBorder,\n            inputValidationWarningBackground: this.inputValidationWarningBackground,\n            inputValidationWarningForeground: this.inputValidationWarningForeground,\n            inputValidationWarningBorder: this.inputValidationWarningBorder,\n            inputValidationErrorBackground: this.inputValidationErrorBackground,\n            inputValidationErrorForeground: this.inputValidationErrorForeground,\n            inputValidationErrorBorder: this.inputValidationErrorBorder,\n            history,\n            showHistoryHint: options.showHistoryHint,\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight\n        }));\n        this.regex = this._register(new RegexCheckbox({\n            appendTitle: appendRegexLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.regex.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this._register(this.regex.onKeyDown(e => {\n            this._onRegexKeyDown.fire(e);\n        }));\n        this.wholeWords = this._register(new WholeWordsCheckbox({\n            appendTitle: appendWholeWordsLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.wholeWords.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this.caseSensitive = this._register(new CaseSensitiveCheckbox({\n            appendTitle: appendCaseSensitiveLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground\n        }));\n        this._register(this.caseSensitive.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this._register(this.caseSensitive.onKeyDown(e => {\n            this._onCaseSensitiveKeyDown.fire(e);\n        }));\n        if (this._showOptionButtons) {\n            this.inputBox.paddingRight = this.caseSensitive.width() + this.wholeWords.width() + this.regex.width();\n        }\n        // Arrow-Key support to navigate between options\n        let indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];\n        this.onkeydown(this.domNode, (event) => {\n            if (event.equals(15 /* LeftArrow */) || event.equals(17 /* RightArrow */) || event.equals(9 /* Escape */)) {\n                let index = indexes.indexOf(document.activeElement);\n                if (index >= 0) {\n                    let newIndex = -1;\n                    if (event.equals(17 /* RightArrow */)) {\n                        newIndex = (index + 1) % indexes.length;\n                    }\n                    else if (event.equals(15 /* LeftArrow */)) {\n                        if (index === 0) {\n                            newIndex = indexes.length - 1;\n                        }\n                        else {\n                            newIndex = index - 1;\n                        }\n                    }\n                    if (event.equals(9 /* Escape */)) {\n                        indexes[index].blur();\n                        this.inputBox.focus();\n                    }\n                    else if (newIndex >= 0) {\n                        indexes[newIndex].focus();\n                    }\n                    dom.EventHelper.stop(event, true);\n                }\n            }\n        });\n        this.controls = document.createElement('div');\n        this.controls.className = 'controls';\n        this.controls.style.display = this._showOptionButtons ? 'block' : 'none';\n        this.controls.appendChild(this.caseSensitive.domNode);\n        this.controls.appendChild(this.wholeWords.domNode);\n        this.controls.appendChild(this.regex.domNode);\n        this.domNode.appendChild(this.controls);\n        if (parent) {\n            parent.appendChild(this.domNode);\n        }\n        this._register(dom.addDisposableListener(this.inputBox.inputElement, 'compositionstart', (e) => {\n            this.imeSessionInProgress = true;\n        }));\n        this._register(dom.addDisposableListener(this.inputBox.inputElement, 'compositionend', (e) => {\n            this.imeSessionInProgress = false;\n            this._onInput.fire();\n        }));\n        this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));\n        this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));\n        this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());\n        this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));\n    }\n    enable() {\n        this.domNode.classList.remove('disabled');\n        this.inputBox.enable();\n        this.regex.enable();\n        this.wholeWords.enable();\n        this.caseSensitive.enable();\n    }\n    disable() {\n        this.domNode.classList.add('disabled');\n        this.inputBox.disable();\n        this.regex.disable();\n        this.wholeWords.disable();\n        this.caseSensitive.disable();\n    }\n    setFocusInputOnOptionClick(value) {\n        this.fixFocusOnOptionClickEnabled = value;\n    }\n    setEnabled(enabled) {\n        if (enabled) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n    }\n    getValue() {\n        return this.inputBox.value;\n    }\n    setValue(value) {\n        if (this.inputBox.value !== value) {\n            this.inputBox.value = value;\n        }\n    }\n    style(styles) {\n        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = styles.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = styles.inputActiveOptionBackground;\n        this.inputBackground = styles.inputBackground;\n        this.inputForeground = styles.inputForeground;\n        this.inputBorder = styles.inputBorder;\n        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;\n        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;\n        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;\n        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;\n        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;\n        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.domNode) {\n            const checkBoxStyles = {\n                inputActiveOptionBorder: this.inputActiveOptionBorder,\n                inputActiveOptionForeground: this.inputActiveOptionForeground,\n                inputActiveOptionBackground: this.inputActiveOptionBackground,\n            };\n            this.regex.style(checkBoxStyles);\n            this.wholeWords.style(checkBoxStyles);\n            this.caseSensitive.style(checkBoxStyles);\n            const inputBoxStyles = {\n                inputBackground: this.inputBackground,\n                inputForeground: this.inputForeground,\n                inputBorder: this.inputBorder,\n                inputValidationInfoBackground: this.inputValidationInfoBackground,\n                inputValidationInfoForeground: this.inputValidationInfoForeground,\n                inputValidationInfoBorder: this.inputValidationInfoBorder,\n                inputValidationWarningBackground: this.inputValidationWarningBackground,\n                inputValidationWarningForeground: this.inputValidationWarningForeground,\n                inputValidationWarningBorder: this.inputValidationWarningBorder,\n                inputValidationErrorBackground: this.inputValidationErrorBackground,\n                inputValidationErrorForeground: this.inputValidationErrorForeground,\n                inputValidationErrorBorder: this.inputValidationErrorBorder\n            };\n            this.inputBox.style(inputBoxStyles);\n        }\n    }\n    select() {\n        this.inputBox.select();\n    }\n    focus() {\n        this.inputBox.focus();\n    }\n    getCaseSensitive() {\n        return this.caseSensitive.checked;\n    }\n    setCaseSensitive(value) {\n        this.caseSensitive.checked = value;\n    }\n    getWholeWords() {\n        return this.wholeWords.checked;\n    }\n    setWholeWords(value) {\n        this.wholeWords.checked = value;\n    }\n    getRegex() {\n        return this.regex.checked;\n    }\n    setRegex(value) {\n        this.regex.checked = value;\n        this.validate();\n    }\n    focusOnCaseSensitive() {\n        this.caseSensitive.focus();\n    }\n    highlightFindOptions() {\n        this.domNode.classList.remove('highlight-' + (this._lastHighlightFindOptions));\n        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;\n        this.domNode.classList.add('highlight-' + (this._lastHighlightFindOptions));\n    }\n    validate() {\n        this.inputBox.validate();\n    }\n    clearMessage() {\n        this.inputBox.hideMessage();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../dom.js';\nimport { Checkbox } from '../checkbox/checkbox.js';\nimport { HistoryInputBox } from '../inputbox/inputBox.js';\nimport { Widget } from '../widget.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { Emitter } from '../../../common/event.js';\nimport './findInput.css';\nimport * as nls from '../../../../nls.js';\nconst NLS_DEFAULT_LABEL = nls.localize('defaultLabel', \"input\");\nconst NLS_PRESERVE_CASE_LABEL = nls.localize('label.preserveCaseCheckbox', \"Preserve Case\");\nexport class PreserveCaseCheckbox extends Checkbox {\n    constructor(opts) {\n        super({\n            // TODO: does this need its own icon?\n            icon: Codicon.preserveCase,\n            title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,\n            isChecked: opts.isChecked,\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nexport class ReplaceInput extends Widget {\n    constructor(parent, contextViewProvider, _showOptionButtons, options) {\n        super();\n        this._showOptionButtons = _showOptionButtons;\n        this.fixFocusOnOptionClickEnabled = true;\n        this.cachedOptionsWidth = 0;\n        this._onDidOptionChange = this._register(new Emitter());\n        this.onDidOptionChange = this._onDidOptionChange.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onMouseDown = this._register(new Emitter());\n        this._onInput = this._register(new Emitter());\n        this._onKeyUp = this._register(new Emitter());\n        this._onPreserveCaseKeyDown = this._register(new Emitter());\n        this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;\n        this.contextViewProvider = contextViewProvider;\n        this.placeholder = options.placeholder || '';\n        this.validation = options.validation;\n        this.label = options.label || NLS_DEFAULT_LABEL;\n        this.inputActiveOptionBorder = options.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = options.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = options.inputActiveOptionBackground;\n        this.inputBackground = options.inputBackground;\n        this.inputForeground = options.inputForeground;\n        this.inputBorder = options.inputBorder;\n        this.inputValidationInfoBorder = options.inputValidationInfoBorder;\n        this.inputValidationInfoBackground = options.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = options.inputValidationInfoForeground;\n        this.inputValidationWarningBorder = options.inputValidationWarningBorder;\n        this.inputValidationWarningBackground = options.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = options.inputValidationWarningForeground;\n        this.inputValidationErrorBorder = options.inputValidationErrorBorder;\n        this.inputValidationErrorBackground = options.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = options.inputValidationErrorForeground;\n        const appendPreserveCaseLabel = options.appendPreserveCaseLabel || '';\n        const history = options.history || [];\n        const flexibleHeight = !!options.flexibleHeight;\n        const flexibleWidth = !!options.flexibleWidth;\n        const flexibleMaxHeight = options.flexibleMaxHeight;\n        this.domNode = document.createElement('div');\n        this.domNode.classList.add('monaco-findInput');\n        this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {\n            ariaLabel: this.label || '',\n            placeholder: this.placeholder || '',\n            validationOptions: {\n                validation: this.validation\n            },\n            inputBackground: this.inputBackground,\n            inputForeground: this.inputForeground,\n            inputBorder: this.inputBorder,\n            inputValidationInfoBackground: this.inputValidationInfoBackground,\n            inputValidationInfoForeground: this.inputValidationInfoForeground,\n            inputValidationInfoBorder: this.inputValidationInfoBorder,\n            inputValidationWarningBackground: this.inputValidationWarningBackground,\n            inputValidationWarningForeground: this.inputValidationWarningForeground,\n            inputValidationWarningBorder: this.inputValidationWarningBorder,\n            inputValidationErrorBackground: this.inputValidationErrorBackground,\n            inputValidationErrorForeground: this.inputValidationErrorForeground,\n            inputValidationErrorBorder: this.inputValidationErrorBorder,\n            history,\n            showHistoryHint: options.showHistoryHint,\n            flexibleHeight,\n            flexibleWidth,\n            flexibleMaxHeight\n        }));\n        this.preserveCase = this._register(new PreserveCaseCheckbox({\n            appendTitle: appendPreserveCaseLabel,\n            isChecked: false,\n            inputActiveOptionBorder: this.inputActiveOptionBorder,\n            inputActiveOptionForeground: this.inputActiveOptionForeground,\n            inputActiveOptionBackground: this.inputActiveOptionBackground,\n        }));\n        this._register(this.preserveCase.onChange(viaKeyboard => {\n            this._onDidOptionChange.fire(viaKeyboard);\n            if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {\n                this.inputBox.focus();\n            }\n            this.validate();\n        }));\n        this._register(this.preserveCase.onKeyDown(e => {\n            this._onPreserveCaseKeyDown.fire(e);\n        }));\n        if (this._showOptionButtons) {\n            this.cachedOptionsWidth = this.preserveCase.width();\n        }\n        else {\n            this.cachedOptionsWidth = 0;\n        }\n        // Arrow-Key support to navigate between options\n        let indexes = [this.preserveCase.domNode];\n        this.onkeydown(this.domNode, (event) => {\n            if (event.equals(15 /* LeftArrow */) || event.equals(17 /* RightArrow */) || event.equals(9 /* Escape */)) {\n                let index = indexes.indexOf(document.activeElement);\n                if (index >= 0) {\n                    let newIndex = -1;\n                    if (event.equals(17 /* RightArrow */)) {\n                        newIndex = (index + 1) % indexes.length;\n                    }\n                    else if (event.equals(15 /* LeftArrow */)) {\n                        if (index === 0) {\n                            newIndex = indexes.length - 1;\n                        }\n                        else {\n                            newIndex = index - 1;\n                        }\n                    }\n                    if (event.equals(9 /* Escape */)) {\n                        indexes[index].blur();\n                        this.inputBox.focus();\n                    }\n                    else if (newIndex >= 0) {\n                        indexes[newIndex].focus();\n                    }\n                    dom.EventHelper.stop(event, true);\n                }\n            }\n        });\n        let controls = document.createElement('div');\n        controls.className = 'controls';\n        controls.style.display = this._showOptionButtons ? 'block' : 'none';\n        controls.appendChild(this.preserveCase.domNode);\n        this.domNode.appendChild(controls);\n        if (parent) {\n            parent.appendChild(this.domNode);\n        }\n        this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));\n        this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));\n        this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());\n        this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));\n    }\n    enable() {\n        this.domNode.classList.remove('disabled');\n        this.inputBox.enable();\n        this.preserveCase.enable();\n    }\n    disable() {\n        this.domNode.classList.add('disabled');\n        this.inputBox.disable();\n        this.preserveCase.disable();\n    }\n    setEnabled(enabled) {\n        if (enabled) {\n            this.enable();\n        }\n        else {\n            this.disable();\n        }\n    }\n    style(styles) {\n        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;\n        this.inputActiveOptionForeground = styles.inputActiveOptionForeground;\n        this.inputActiveOptionBackground = styles.inputActiveOptionBackground;\n        this.inputBackground = styles.inputBackground;\n        this.inputForeground = styles.inputForeground;\n        this.inputBorder = styles.inputBorder;\n        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;\n        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;\n        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;\n        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;\n        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;\n        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;\n        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;\n        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;\n        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;\n        this.applyStyles();\n    }\n    applyStyles() {\n        if (this.domNode) {\n            const checkBoxStyles = {\n                inputActiveOptionBorder: this.inputActiveOptionBorder,\n                inputActiveOptionForeground: this.inputActiveOptionForeground,\n                inputActiveOptionBackground: this.inputActiveOptionBackground,\n            };\n            this.preserveCase.style(checkBoxStyles);\n            const inputBoxStyles = {\n                inputBackground: this.inputBackground,\n                inputForeground: this.inputForeground,\n                inputBorder: this.inputBorder,\n                inputValidationInfoBackground: this.inputValidationInfoBackground,\n                inputValidationInfoForeground: this.inputValidationInfoForeground,\n                inputValidationInfoBorder: this.inputValidationInfoBorder,\n                inputValidationWarningBackground: this.inputValidationWarningBackground,\n                inputValidationWarningForeground: this.inputValidationWarningForeground,\n                inputValidationWarningBorder: this.inputValidationWarningBorder,\n                inputValidationErrorBackground: this.inputValidationErrorBackground,\n                inputValidationErrorForeground: this.inputValidationErrorForeground,\n                inputValidationErrorBorder: this.inputValidationErrorBorder\n            };\n            this.inputBox.style(inputBoxStyles);\n        }\n    }\n    select() {\n        this.inputBox.select();\n    }\n    focus() {\n        this.inputBox.focus();\n    }\n    getPreserveCase() {\n        return this.preserveCase.checked;\n    }\n    setPreserveCase(value) {\n        this.preserveCase.checked = value;\n    }\n    focusOnPreserve() {\n        this.preserveCase.focus();\n    }\n    validate() {\n        if (this.inputBox) {\n            this.inputBox.validate();\n        }\n    }\n    set width(newWidth) {\n        this.inputBox.paddingRight = this.cachedOptionsWidth;\n        this.inputBox.width = newWidth;\n        this.domNode.style.width = newWidth + 'px';\n    }\n    dispose() {\n        super.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { FindInput } from '../../../base/browser/ui/findinput/findInput.js';\nimport { ReplaceInput } from '../../../base/browser/ui/findinput/replaceInput.js';\nimport { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { KeybindingsRegistry } from '../../keybinding/common/keybindingsRegistry.js';\nimport { localize } from '../../../nls.js';\nexport const historyNavigationVisible = new RawContextKey('suggestWidgetVisible', false, localize('suggestWidgetVisible', \"Whether suggestion are visible\"));\nexport const HistoryNavigationWidgetContext = 'historyNavigationWidget';\nconst HistoryNavigationForwardsEnablementContext = 'historyNavigationForwardsEnabled';\nconst HistoryNavigationBackwardsEnablementContext = 'historyNavigationBackwardsEnabled';\nfunction bindContextScopedWidget(contextKeyService, widget, contextKey) {\n    new RawContextKey(contextKey, widget).bindTo(contextKeyService);\n}\nfunction createWidgetScopedContextKeyService(contextKeyService, widget) {\n    return contextKeyService.createScoped(widget.target);\n}\nfunction getContextScopedWidget(contextKeyService, contextKey) {\n    return contextKeyService.getContext(document.activeElement).getValue(contextKey);\n}\nexport function createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, widget) {\n    const scopedContextKeyService = createWidgetScopedContextKeyService(contextKeyService, widget);\n    bindContextScopedWidget(scopedContextKeyService, widget, HistoryNavigationWidgetContext);\n    const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);\n    const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);\n    return {\n        scopedContextKeyService,\n        historyNavigationForwardsEnablement,\n        historyNavigationBackwardsEnablement,\n    };\n}\nlet ContextScopedFindInput = class ContextScopedFindInput extends FindInput {\n    constructor(container, contextViewProvider, options, contextKeyService, showFindOptions = false) {\n        super(container, contextViewProvider, showFindOptions, options);\n        this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);\n    }\n};\nContextScopedFindInput = __decorate([\n    __param(3, IContextKeyService)\n], ContextScopedFindInput);\nexport { ContextScopedFindInput };\nlet ContextScopedReplaceInput = class ContextScopedReplaceInput extends ReplaceInput {\n    constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {\n        super(container, contextViewProvider, showReplaceOptions, options);\n        this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);\n    }\n};\nContextScopedReplaceInput = __decorate([\n    __param(3, IContextKeyService)\n], ContextScopedReplaceInput);\nexport { ContextScopedReplaceInput };\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    id: 'history.showPrevious',\n    weight: 200 /* WorkbenchContrib */,\n    when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),\n    primary: 16 /* UpArrow */,\n    secondary: [512 /* Alt */ | 16 /* UpArrow */],\n    handler: (accessor) => {\n        const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);\n        if (widget) {\n            const historyInputBox = widget.historyNavigator;\n            historyInputBox.showPreviousValue();\n        }\n    }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    id: 'history.showNext',\n    weight: 200 /* WorkbenchContrib */,\n    when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),\n    primary: 18 /* DownArrow */,\n    secondary: [512 /* Alt */ | 18 /* DownArrow */],\n    handler: (accessor) => {\n        const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);\n        if (widget) {\n            const historyInputBox = widget.historyNavigator;\n            historyInputBox.showNextValue();\n        }\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], supportsDelayedInstantiation);\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// ------ internal util\nexport var _util;\n(function (_util) {\n    _util.serviceIds = new Map();\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {}));\nexport const IInstantiationService = createDecorator('instantiationService');\nfunction storeServiceDependency(id, target, index) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index }];\n        target[_util.DI_TARGET] = target;\n    }\n}\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator(serviceId) {\n    if (_util.serviceIds.has(serviceId)) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(id, target, index);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ServiceCollection {\n    constructor(...entries) {\n        this._entries = new Map();\n        for (let [id, service] of entries) {\n            this.set(id, service);\n        }\n    }\n    set(id, instanceOrDescriptor) {\n        const result = this._entries.get(id);\n        this._entries.set(id, instanceOrDescriptor);\n        return result;\n    }\n    get(id) {\n        return this._entries.get(id);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport * as platform from '../../registry/common/platform.js';\nexport const Extensions = {\n    JSONContribution: 'base.contributions.json'\n};\nfunction normalizeId(id) {\n    if (id.length > 0 && id.charAt(id.length - 1) === '#') {\n        return id.substring(0, id.length - 1);\n    }\n    return id;\n}\nclass JSONContributionRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.schemasById = {};\n    }\n    registerSchema(uri, unresolvedSchemaContent) {\n        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n        this._onDidChangeSchema.fire(uri);\n    }\n    notifySchemaChanged(uri) {\n        this._onDidChangeSchema.fire(uri);\n    }\n}\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IKeybindingService = createDecorator('keybindingService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createKeybinding } from '../../../base/common/keybindings.js';\nimport { OS } from '../../../base/common/platform.js';\nimport { CommandsRegistry } from '../../commands/common/commands.js';\nimport { Registry } from '../../registry/common/platform.js';\nclass KeybindingsRegistryImpl {\n    constructor() {\n        this._coreKeybindings = [];\n        this._extensionKeybindings = [];\n        this._cachedMergedKeybindings = null;\n    }\n    /**\n     * Take current platform into account and reduce to primary & secondary.\n     */\n    static bindToCurrentPlatform(kb) {\n        if (OS === 1 /* Windows */) {\n            if (kb && kb.win) {\n                return kb.win;\n            }\n        }\n        else if (OS === 2 /* Macintosh */) {\n            if (kb && kb.mac) {\n                return kb.mac;\n            }\n        }\n        else {\n            if (kb && kb.linux) {\n                return kb.linux;\n            }\n        }\n        return kb;\n    }\n    registerKeybindingRule(rule) {\n        const actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);\n        if (actualKb && actualKb.primary) {\n            const kk = createKeybinding(actualKb.primary, OS);\n            if (kk) {\n                this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when);\n            }\n        }\n        if (actualKb && Array.isArray(actualKb.secondary)) {\n            for (let i = 0, len = actualKb.secondary.length; i < len; i++) {\n                const k = actualKb.secondary[i];\n                const kk = createKeybinding(k, OS);\n                if (kk) {\n                    this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when);\n                }\n            }\n        }\n    }\n    registerCommandAndKeybindingRule(desc) {\n        this.registerKeybindingRule(desc);\n        CommandsRegistry.registerCommand(desc);\n    }\n    static _mightProduceChar(keyCode) {\n        if (keyCode >= 21 /* Digit0 */ && keyCode <= 30 /* Digit9 */) {\n            return true;\n        }\n        if (keyCode >= 31 /* KeyA */ && keyCode <= 56 /* KeyZ */) {\n            return true;\n        }\n        return (keyCode === 80 /* Semicolon */\n            || keyCode === 81 /* Equal */\n            || keyCode === 82 /* Comma */\n            || keyCode === 83 /* Minus */\n            || keyCode === 84 /* Period */\n            || keyCode === 85 /* Slash */\n            || keyCode === 86 /* Backquote */\n            || keyCode === 110 /* ABNT_C1 */\n            || keyCode === 111 /* ABNT_C2 */\n            || keyCode === 87 /* BracketLeft */\n            || keyCode === 88 /* Backslash */\n            || keyCode === 89 /* BracketRight */\n            || keyCode === 90 /* Quote */\n            || keyCode === 91 /* OEM_8 */\n            || keyCode === 92 /* IntlBackslash */);\n    }\n    _assertNoCtrlAlt(keybinding, commandId) {\n        if (keybinding.ctrlKey && keybinding.altKey && !keybinding.metaKey) {\n            if (KeybindingsRegistryImpl._mightProduceChar(keybinding.keyCode)) {\n                console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);\n            }\n        }\n    }\n    _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {\n        if (OS === 1 /* Windows */) {\n            this._assertNoCtrlAlt(keybinding.parts[0], commandId);\n        }\n        this._coreKeybindings.push({\n            keybinding: keybinding.parts,\n            command: commandId,\n            commandArgs: commandArgs,\n            when: when,\n            weight1: weight1,\n            weight2: weight2,\n            extensionId: null,\n            isBuiltinExtension: false\n        });\n        this._cachedMergedKeybindings = null;\n    }\n    getDefaultKeybindings() {\n        if (!this._cachedMergedKeybindings) {\n            this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings);\n            this._cachedMergedKeybindings.sort(sorter);\n        }\n        return this._cachedMergedKeybindings.slice(0);\n    }\n}\nexport const KeybindingsRegistry = new KeybindingsRegistryImpl();\n// Define extension point ids\nexport const Extensions = {\n    EditorModes: 'platform.keybindingsRegistry'\n};\nRegistry.add(Extensions.EditorModes, KeybindingsRegistry);\nfunction sorter(a, b) {\n    if (a.weight1 !== b.weight1) {\n        return a.weight1 - b.weight1;\n    }\n    if (a.command < b.command) {\n        return -1;\n    }\n    if (a.command > b.command) {\n        return 1;\n    }\n    return a.weight2 - b.weight2;\n}\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ILabelService = createDecorator('labelService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { range } from '../../../common/arrays.js';\nimport { CancellationTokenSource } from '../../../common/cancellation.js';\nimport { Event } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport './list.css';\nimport { List } from './listWidget.js';\nclass PagedRenderer {\n    constructor(renderer, modelProvider) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n    }\n    get templateId() { return this.renderer.templateId; }\n    renderTemplate(container) {\n        const data = this.renderer.renderTemplate(container);\n        return { data, disposable: Disposable.None };\n    }\n    renderElement(index, _, data, height) {\n        if (data.disposable) {\n            data.disposable.dispose();\n        }\n        if (!data.data) {\n            return;\n        }\n        const model = this.modelProvider();\n        if (model.isResolved(index)) {\n            return this.renderer.renderElement(model.get(index), index, data.data, height);\n        }\n        const cts = new CancellationTokenSource();\n        const promise = model.resolve(index, cts.token);\n        data.disposable = { dispose: () => cts.cancel() };\n        this.renderer.renderPlaceholder(index, data.data);\n        promise.then(entry => this.renderer.renderElement(entry, index, data.data, height));\n    }\n    disposeTemplate(data) {\n        if (data.disposable) {\n            data.disposable.dispose();\n            data.disposable = undefined;\n        }\n        if (data.data) {\n            this.renderer.disposeTemplate(data.data);\n            data.data = undefined;\n        }\n    }\n}\nclass PagedAccessibilityProvider {\n    constructor(modelProvider, accessibilityProvider) {\n        this.modelProvider = modelProvider;\n        this.accessibilityProvider = accessibilityProvider;\n    }\n    getWidgetAriaLabel() {\n        return this.accessibilityProvider.getWidgetAriaLabel();\n    }\n    getAriaLabel(index) {\n        const model = this.modelProvider();\n        if (!model.isResolved(index)) {\n            return null;\n        }\n        return this.accessibilityProvider.getAriaLabel(model.get(index));\n    }\n}\nfunction fromPagedListOptions(modelProvider, options) {\n    return Object.assign(Object.assign({}, options), { accessibilityProvider: options.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options.accessibilityProvider) });\n}\nexport class PagedList {\n    constructor(user, container, virtualDelegate, renderers, options = {}) {\n        const modelProvider = () => this.model;\n        const pagedRenderers = renderers.map(r => new PagedRenderer(r, modelProvider));\n        this.list = new List(user, container, virtualDelegate, pagedRenderers, fromPagedListOptions(modelProvider, options));\n    }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    getHTMLElement() {\n        return this.list.getHTMLElement();\n    }\n    get onDidFocus() {\n        return this.list.onDidFocus;\n    }\n    get onDidDispose() {\n        return this.list.onDidDispose;\n    }\n    get onMouseDblClick() {\n        return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));\n    }\n    get onPointer() {\n        return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === undefined ? undefined : this._model.get(element), index, browserEvent }));\n    }\n    get onDidChangeSelection() {\n        return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map(e => this._model.get(e)), indexes, browserEvent }));\n    }\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        this._model = model;\n        this.list.splice(0, this.list.length, range(model.length));\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getSelectedElements() {\n        return this.getSelection().map(i => this.model.get(i));\n    }\n    style(styles) {\n        this.list.style(styles);\n    }\n    dispose() {\n        this.list.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet } from '../../dom.js';\nimport { List } from '../list/listWidget.js';\nimport { SplitView } from '../splitview/splitview.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { DisposableStore } from '../../../common/lifecycle.js';\nimport './table.css';\nclass TableListRenderer {\n    constructor(columns, renderers, getColumnSize) {\n        this.columns = columns;\n        this.getColumnSize = getColumnSize;\n        this.templateId = TableListRenderer.TemplateId;\n        this.renderedTemplates = new Set();\n        const rendererMap = new Map(renderers.map(r => [r.templateId, r]));\n        this.renderers = [];\n        for (const column of columns) {\n            const renderer = rendererMap.get(column.templateId);\n            if (!renderer) {\n                throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);\n            }\n            this.renderers.push(renderer);\n        }\n    }\n    renderTemplate(container) {\n        const rowContainer = append(container, $('.monaco-table-tr'));\n        const cellContainers = [];\n        const cellTemplateData = [];\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            const cellContainer = append(rowContainer, $('.monaco-table-td', { 'data-col-index': i }));\n            cellContainer.style.width = `${this.getColumnSize(i)}px`;\n            cellContainers.push(cellContainer);\n            cellTemplateData.push(renderer.renderTemplate(cellContainer));\n        }\n        const result = { container, cellContainers, cellTemplateData };\n        this.renderedTemplates.add(result);\n        return result;\n    }\n    renderElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const column = this.columns[i];\n            const cell = column.project(element);\n            const renderer = this.renderers[i];\n            renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);\n        }\n    }\n    disposeElement(element, index, templateData, height) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            if (renderer.disposeElement) {\n                const column = this.columns[i];\n                const cell = column.project(element);\n                renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        for (let i = 0; i < this.columns.length; i++) {\n            const renderer = this.renderers[i];\n            renderer.disposeTemplate(templateData.cellTemplateData[i]);\n        }\n        clearNode(templateData.container);\n        this.renderedTemplates.delete(templateData);\n    }\n    layoutColumn(index, size) {\n        for (const { cellContainers } of this.renderedTemplates) {\n            cellContainers[index].style.width = `${size}px`;\n        }\n    }\n}\nTableListRenderer.TemplateId = 'row';\nfunction asListVirtualDelegate(delegate) {\n    return {\n        getHeight(row) { return delegate.getHeight(row); },\n        getTemplateId() { return TableListRenderer.TemplateId; },\n    };\n}\nclass ColumnHeader {\n    constructor(column, index) {\n        this.column = column;\n        this.index = index;\n        this._onDidLayout = new Emitter();\n        this.onDidLayout = this._onDidLayout.event;\n        this.element = $('.monaco-table-th', { 'data-col-index': index, title: column.tooltip }, column.label);\n    }\n    get minimumSize() { var _a; return (_a = this.column.minimumWidth) !== null && _a !== void 0 ? _a : 120; }\n    get maximumSize() { var _a; return (_a = this.column.maximumWidth) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY; }\n    get onDidChange() { var _a; return (_a = this.column.onDidChangeWidthConstraints) !== null && _a !== void 0 ? _a : Event.None; }\n    layout(size) {\n        this._onDidLayout.fire([this.index, size]);\n    }\n}\nexport class Table {\n    constructor(user, container, virtualDelegate, columns, renderers, _options) {\n        this.virtualDelegate = virtualDelegate;\n        this.domId = `table_id_${++Table.InstanceCount}`;\n        this.disposables = new DisposableStore();\n        this.cachedWidth = 0;\n        this.cachedHeight = 0;\n        this.domNode = append(container, $(`.monaco-table.${this.domId}`));\n        const headers = columns.map((c, i) => new ColumnHeader(c, i));\n        const descriptor = {\n            size: headers.reduce((a, b) => a + b.column.weight, 0),\n            views: headers.map(view => ({ size: view.column.weight, view }))\n        };\n        this.splitview = this.disposables.add(new SplitView(this.domNode, {\n            orientation: 1 /* HORIZONTAL */,\n            scrollbarVisibility: 2 /* Hidden */,\n            getSashOrthogonalSize: () => this.cachedHeight,\n            descriptor\n        }));\n        this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;\n        this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;\n        const renderer = new TableListRenderer(columns, renderers, i => this.splitview.getViewSize(i));\n        this.list = this.disposables.add(new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options));\n        Event.any(...headers.map(h => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size), null, this.disposables);\n        this.splitview.onDidSashReset(index => {\n            const totalWeight = columns.reduce((r, c) => r + c.weight, 0);\n            const size = columns[index].weight / totalWeight * this.cachedWidth;\n            this.splitview.resizeView(index, size);\n        }, null, this.disposables);\n        this.styleElement = createStyleSheet(this.domNode);\n        this.style({});\n    }\n    get onDidChangeFocus() { return this.list.onDidChangeFocus; }\n    get onDidChangeSelection() { return this.list.onDidChangeSelection; }\n    get onMouseDblClick() { return this.list.onMouseDblClick; }\n    get onPointer() { return this.list.onPointer; }\n    get onDidFocus() { return this.list.onDidFocus; }\n    get onDidDispose() { return this.list.onDidDispose; }\n    updateOptions(options) {\n        this.list.updateOptions(options);\n    }\n    splice(start, deleteCount, elements = []) {\n        this.list.splice(start, deleteCount, elements);\n    }\n    getHTMLElement() {\n        return this.domNode;\n    }\n    style(styles) {\n        const content = [];\n        content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {\n\t\t\ttop: ${this.virtualDelegate.headerRowHeight + 1}px;\n\t\t\theight: calc(100% - ${this.virtualDelegate.headerRowHeight}px);\n\t\t}`);\n        this.styleElement.textContent = content.join('\\n');\n        this.list.style(styles);\n    }\n    getSelectedElements() {\n        return this.list.getSelectedElements();\n    }\n    getSelection() {\n        return this.list.getSelection();\n    }\n    getFocus() {\n        return this.list.getFocus();\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nTable.InstanceCount = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var TreeMouseEventTarget;\n(function (TreeMouseEventTarget) {\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Unknown\"] = 0] = \"Unknown\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Twistie\"] = 1] = \"Twistie\";\n    TreeMouseEventTarget[TreeMouseEventTarget[\"Element\"] = 2] = \"Element\";\n})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));\nexport class TreeError extends Error {\n    constructor(user, message) {\n        super(`TreeError [${user}] ${message}`);\n    }\n}\nexport class WeakMapper {\n    constructor(fn) {\n        this.fn = fn;\n        this._map = new WeakMap();\n    }\n    map(key) {\n        let result = this._map.get(key);\n        if (!result) {\n            result = this.fn(key);\n            this._map.set(key, result);\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer, MicrotaskDelay } from '../../../common/async.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* Visible */;\n        case false: return 0 /* Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.refilterDelayer = new Delayer(MicrotaskDelay);\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        if (!parentNode.lastDiffIds) {\n            return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n        }\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            parentNode.lastDiffIds = undefined;\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        const lastHadChildren = parentNode.children.length > 0;\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n        if (!diffIdentityProvider) {\n            parentNode.lastDiffIds = undefined;\n        }\n        else if (parentNode.lastDiffIds) {\n            splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n        }\n        else {\n            parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n        }\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        const currentlyHasChildren = parentNode.children.length > 0;\n        if (lastHadChildren !== currentlyHasChildren) {\n            this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n        }\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* Recurse */) {\n                // delayed to avoid excessive refiltering, see #135941\n                this.refilterDelayer.trigger(() => this.refilter());\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n        this.refilterDelayer.cancel();\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\n        const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const child of childNodes) {\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        node.collapsible = node.collapsible || node.children.length > 0;\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        if (onDidCreateNode) {\n            onDidCreateNode(node);\n        }\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\n            node.visibility = visibility;\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n    getFirstElementChild(location) {\n        const node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DragAndDropData, StaticDND } from '../../dnd.js';\nimport { $, addDisposableListener, append, clearNode, createStyleSheet, getDomNodePagePosition, hasParentWithClass } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { DefaultKeyboardNavigationDelegate, isInputElement, isMonacoEditor, List, MouseController } from '../list/listWidget.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { disposableTimeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { SetMap } from '../../../common/collections.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return Object.assign(Object.assign({}, result), { feedback: range(start, start + length) });\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            }, isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined, getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem', getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            }, getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            } }), enableKeyboardNavigation: options.simpleKeyboardNavigation });\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        if (this.delegate.setDynamicHeight) {\n            this.delegate.setDynamicHeight(element.element, height);\n        }\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements);\n    }\n    get elements() {\n        return this._elements;\n    }\n}\nclass TreeRenderer {\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.renderedIndentGuides = new SetMap();\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        if (renderer.onDidChangeTwistieState) {\n            renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);\n        }\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            this.indent = clamp(options.indent, 0, 40);\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        if (typeof height === 'number') {\n            this.renderedNodes.set(node, { templateData, height });\n            this.renderedElements.set(node.element, node);\n        }\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        this.renderTwistie(node, templateData);\n        if (typeof height === 'number') {\n            this.renderIndentGuides(node, templateData);\n        }\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        templateData.indentGuidesDisposable.dispose();\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(node, index, templateData.templateData, height);\n        }\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const data = this.renderedNodes.get(node);\n        if (!data) {\n            return;\n        }\n        this.renderTwistie(node, data.templateData);\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderIndentGuides(node, data.templateData);\n    }\n    renderTwistie(node, templateData) {\n        templateData.twistie.classList.remove(...Codicon.treeItemExpanded.classNamesArray);\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...Codicon.treeItemExpanded.classNamesArray);\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n    }\n    renderIndentGuides(target, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        let node = target;\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch (_a) {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nTreeRenderer.DefaultIndent = 8;\nclass TypeFilter {\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    set pattern(pattern) {\n        this._pattern = pattern;\n        this._lowercasePattern = pattern.toLowerCase();\n    }\n    filter(element, parentVisibility) {\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (this.tree.options.simpleKeyboardNavigation) {\n                return result;\n            }\n            let visibility;\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* Visible */ : 0 /* Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility: true };\n            }\n            const score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility: true } :\n                    { data: { label: labelStr, score: score }, visibility: true };\n            }\n        }\n        if (this.tree.options.filterOnType) {\n            return 2 /* Recurse */;\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility: true };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nclass TypeFilterController {\n    constructor(tree, model, view, filter, keyboardNavigationDelegate) {\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.keyboardNavigationDelegate = keyboardNavigationDelegate;\n        this._enabled = false;\n        this._pattern = '';\n        this._empty = false;\n        this._onDidChangeEmptyState = new Emitter();\n        this.positionClassName = 'ne';\n        this.automaticKeyboardNavigation = true;\n        this.triggered = false;\n        this._onDidChangePattern = new Emitter();\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this.domNode = $(`.monaco-list-type-filter.${this.positionClassName}`);\n        this.domNode.draggable = true;\n        this.disposables.add(addDisposableListener(this.domNode, 'dragstart', () => this.onDragStart()));\n        this.messageDomNode = append(view.getHTMLElement(), $(`.monaco-list-type-filter-message`));\n        this.labelDomNode = append(this.domNode, $('span.label'));\n        const controls = append(this.domNode, $('.controls'));\n        this._filterOnType = !!tree.options.filterOnType;\n        this.filterOnTypeDomNode = append(controls, $('input.filter'));\n        this.filterOnTypeDomNode.type = 'checkbox';\n        this.filterOnTypeDomNode.checked = this._filterOnType;\n        this.filterOnTypeDomNode.tabIndex = -1;\n        this.updateFilterOnTypeTitleAndIcon();\n        this.disposables.add(addDisposableListener(this.filterOnTypeDomNode, 'input', () => this.onDidChangeFilterOnType()));\n        this.clearDomNode = append(controls, $('button.clear' + Codicon.treeFilterClear.cssSelector));\n        this.clearDomNode.tabIndex = -1;\n        this.clearDomNode.title = localize('clear', \"Clear\");\n        this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n        this.updateOptions(tree.options);\n    }\n    get enabled() { return this._enabled; }\n    get pattern() { return this._pattern; }\n    get filterOnType() { return this._filterOnType; }\n    updateOptions(options) {\n        if (options.simpleKeyboardNavigation) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n        if (typeof options.filterOnType !== 'undefined') {\n            this._filterOnType = !!options.filterOnType;\n            this.filterOnTypeDomNode.checked = this._filterOnType;\n            this.updateFilterOnTypeTitleAndIcon();\n        }\n        if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n            this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n        }\n        this.tree.refilter();\n        this.render();\n        if (!this.automaticKeyboardNavigation) {\n            this.onEventOrInput('');\n        }\n    }\n    enable() {\n        if (this._enabled) {\n            return;\n        }\n        const onRawKeyDown = this.enabledDisposables.add(new DomEmitter(this.view.getHTMLElement(), 'keydown'));\n        const onKeyDown = Event.chain(onRawKeyDown.event)\n            .filter(e => !isInputElement(e.target) || e.target === this.filterOnTypeDomNode)\n            .filter(e => e.key !== 'Dead' && !/^Media/.test(e.key))\n            .map(e => new StandardKeyboardEvent(e))\n            .filter(this.keyboardNavigationEventFilter || (() => true))\n            .filter(() => this.automaticKeyboardNavigation || this.triggered)\n            .filter(e => (this.keyboardNavigationDelegate.mightProducePrintableCharacter(e) && !(e.keyCode === 18 /* DownArrow */ || e.keyCode === 16 /* UpArrow */ || e.keyCode === 15 /* LeftArrow */ || e.keyCode === 17 /* RightArrow */)) || ((this.pattern.length > 0 || this.triggered) && ((e.keyCode === 9 /* Escape */ || e.keyCode === 1 /* Backspace */) && !e.altKey && !e.ctrlKey && !e.metaKey) || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? (e.altKey && !e.metaKey) : e.ctrlKey) && !e.shiftKey)))\n            .forEach(e => { e.stopPropagation(); e.preventDefault(); })\n            .event;\n        const onClearClick = this.enabledDisposables.add(new DomEmitter(this.clearDomNode, 'click'));\n        Event.chain(Event.any(onKeyDown, onClearClick.event))\n            .event(this.onEventOrInput, this, this.enabledDisposables);\n        this.filter.pattern = '';\n        this.tree.refilter();\n        this.render();\n        this._enabled = true;\n        this.triggered = false;\n    }\n    disable() {\n        if (!this._enabled) {\n            return;\n        }\n        this.domNode.remove();\n        this.enabledDisposables.clear();\n        this.tree.refilter();\n        this.render();\n        this._enabled = false;\n        this.triggered = false;\n    }\n    onEventOrInput(e) {\n        if (typeof e === 'string') {\n            this.onInput(e);\n        }\n        else if (e instanceof MouseEvent || e.keyCode === 9 /* Escape */ || (e.keyCode === 1 /* Backspace */ && (isMacintosh ? e.altKey : e.ctrlKey))) {\n            this.onInput('');\n        }\n        else if (e.keyCode === 1 /* Backspace */) {\n            this.onInput(this.pattern.length === 0 ? '' : this.pattern.substr(0, this.pattern.length - 1));\n        }\n        else {\n            this.onInput(this.pattern + e.browserEvent.key);\n        }\n    }\n    onInput(pattern) {\n        const container = this.view.getHTMLElement();\n        if (pattern && !this.domNode.parentElement) {\n            container.append(this.domNode);\n        }\n        else if (!pattern && this.domNode.parentElement) {\n            this.domNode.remove();\n            this.tree.domFocus();\n        }\n        this._pattern = pattern;\n        this._onDidChangePattern.fire(pattern);\n        this.filter.pattern = pattern;\n        this.tree.refilter();\n        if (pattern) {\n            this.tree.focusNext(0, true, undefined, node => !FuzzyScore.isDefault(node.filterData));\n        }\n        const focus = this.tree.getFocus();\n        if (focus.length > 0) {\n            const element = focus[0];\n            if (this.tree.getRelativeTop(element) === null) {\n                this.tree.reveal(element, 0.5);\n            }\n        }\n        this.render();\n        if (!pattern) {\n            this.triggered = false;\n        }\n    }\n    onDragStart() {\n        const container = this.view.getHTMLElement();\n        const { left } = getDomNodePagePosition(container);\n        const containerWidth = container.clientWidth;\n        const midContainerWidth = containerWidth / 2;\n        const width = this.domNode.clientWidth;\n        const disposables = new DisposableStore();\n        let positionClassName = this.positionClassName;\n        const updatePosition = () => {\n            switch (positionClassName) {\n                case 'nw':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `4px`;\n                    break;\n                case 'ne':\n                    this.domNode.style.top = `4px`;\n                    this.domNode.style.left = `${containerWidth - width - 6}px`;\n                    break;\n            }\n        };\n        const onDragOver = (event) => {\n            event.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n            const x = event.clientX - left;\n            if (event.dataTransfer) {\n                event.dataTransfer.dropEffect = 'none';\n            }\n            if (x < midContainerWidth) {\n                positionClassName = 'nw';\n            }\n            else {\n                positionClassName = 'ne';\n            }\n            updatePosition();\n        };\n        const onDragEnd = () => {\n            this.positionClassName = positionClassName;\n            this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`;\n            this.domNode.style.top = '';\n            this.domNode.style.left = '';\n            dispose(disposables);\n        };\n        updatePosition();\n        this.domNode.classList.remove(positionClassName);\n        this.domNode.classList.add('dragging');\n        disposables.add(toDisposable(() => this.domNode.classList.remove('dragging')));\n        disposables.add(addDisposableListener(document, 'dragover', e => onDragOver(e)));\n        disposables.add(addDisposableListener(this.domNode, 'dragend', () => onDragEnd()));\n        StaticDND.CurrentDragAndDropData = new DragAndDropData('vscode-ui');\n        disposables.add(toDisposable(() => StaticDND.CurrentDragAndDropData = undefined));\n    }\n    onDidSpliceModel() {\n        if (!this._enabled || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    onDidChangeFilterOnType() {\n        this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked });\n        this.tree.refilter();\n        this.tree.domFocus();\n        this.render();\n        this.updateFilterOnTypeTitleAndIcon();\n    }\n    updateFilterOnTypeTitleAndIcon() {\n        if (this.filterOnType) {\n            this.filterOnTypeDomNode.classList.remove(...Codicon.treeFilterOnTypeOff.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...Codicon.treeFilterOnTypeOn.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('disable filter on type', \"Disable Filter on Type\");\n        }\n        else {\n            this.filterOnTypeDomNode.classList.remove(...Codicon.treeFilterOnTypeOn.classNamesArray);\n            this.filterOnTypeDomNode.classList.add(...Codicon.treeFilterOnTypeOff.classNamesArray);\n            this.filterOnTypeDomNode.title = localize('enable filter on type', \"Enable Filter on Type\");\n        }\n    }\n    render() {\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && this.tree.options.filterOnType && noMatches) {\n            this.messageDomNode.textContent = localize('empty', \"No elements found\");\n            this._empty = true;\n        }\n        else {\n            this.messageDomNode.innerText = '';\n            this._empty = false;\n        }\n        this.domNode.classList.toggle('no-matches', noMatches);\n        this.domNode.title = localize('found', \"Matched {0} out of {1} elements\", this.filter.matchCount, this.filter.totalCount);\n        this.labelDomNode.textContent = this.pattern.length > 16 ? '…' + this.pattern.substr(this.pattern.length - 16) : this.pattern;\n        this._onDidChangeEmptyState.fire(this._empty);\n    }\n    shouldAllowFocus(node) {\n        if (!this.enabled || !this.pattern || this.filterOnType) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    dispose() {\n        if (this._enabled) {\n            this.domNode.remove();\n            this.enabledDisposables.dispose();\n            this._enabled = false;\n            this.triggered = false;\n        }\n        this._onDidChangePattern.dispose();\n        dispose(this.disposables);\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    constructor(getFirstViewElementWithTrait, identityProvider) {\n        this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    set(nodes, browserEvent) {\n        if (!(browserEvent === null || browserEvent === void 0 ? void 0 : browserEvent.__forceEvent) && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        if (this.nodes.length > 0 && nodes.length === 0) {\n            const node = this.getFirstViewElementWithTrait();\n            if (node) {\n                nodes.push(node);\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree) {\n        super(list);\n        this.tree = tree;\n    }\n    onViewPointer(e) {\n        if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        let expandOnlyOnTwistieClick = false;\n        if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n            return super.onViewPointer(e);\n        }\n        if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n            return super.onViewPointer(e);\n        }\n        if (node.collapsible) {\n            const model = this.tree.model; // internal\n            const location = model.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            model.setCollapsed(location, undefined, recursive);\n            if (expandOnlyOnTwistieClick && onTwistie) {\n                return;\n            }\n        }\n        super.onViewPointer(e);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    constructor(_user, container, delegate, renderers, _options = {}) {\n        this._user = _user;\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        const treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = new EventCollection(onDidChangeActiveNodes.event);\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));\n        for (let r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = Object.assign(Object.assign({}, _options), { filter: filter }); // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n        this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n        this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n        this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, asListOptions(() => this.model, _options)), { tree: this }));\n        this.model = this.createModel(_user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        });\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        onDidChangeActiveNodes.input = Event.chain(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange))\n            .debounce(() => null, 0)\n            .map(() => {\n            const set = new Set();\n            for (const node of this.focus.getNodes()) {\n                set.add(node);\n            }\n            for (const node of this.selection.getNodes()) {\n                set.add(node);\n            }\n            return [...set.values()];\n        }).event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown)\n                .filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e));\n            onKeyDown.filter(e => e.keyCode === 15 /* LeftArrow */).on(this.onLeftArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 17 /* RightArrow */).on(this.onRightArrow, this, this.disposables);\n            onKeyDown.filter(e => e.keyCode === 10 /* Space */).on(this.onSpace, this, this.disposables);\n        }\n        if (_options.keyboardNavigationLabelProvider) {\n            const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;\n            this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, delegate);\n            this.focusNavigationFilter = node => this.typeFilterController.shouldAllowFocus(node);\n            this.disposables.add(this.typeFilterController);\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.map(this.view.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    updateOptions(optionsUpdate = {}) {\n        this._options = Object.assign(Object.assign({}, this._options), optionsUpdate);\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions(Object.assign(Object.assign({}, this._options), { enableKeyboardNavigation: this._options.simpleKeyboardNavigation }));\n        if (this.typeFilterController) {\n            this.typeFilterController.updateOptions(this._options);\n        }\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.view.domFocus();\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n    }\n    style(styles) {\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        this.view.style(styles);\n    }\n    // Tree navigation\n    getParentElement(location) {\n        const parentRef = this.model.getParentNodeLocation(location);\n        const parentNode = this.model.getNode(parentRef);\n        return parentNode.element;\n    }\n    getFirstElementChild(location) {\n        return this.model.getFirstElementChild(location);\n    }\n    // Tree\n    getNode(location) {\n        return this.model.getNode(location);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.selection.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setSelection(indexes, browserEvent, true);\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.model.getNode(e));\n        this.focus.set(nodes, browserEvent);\n        const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n        this.view.setFocus(indexes, browserEvent, true);\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {\n        this.view.focusNext(n, loop, browserEvent, filter);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        this.view.reveal(index, relativeTop);\n    }\n    /**\n     * Returns the relative position of an element rendered in the list.\n     * Returns `null` if the element isn't *entirely* in the visible viewport.\n     */\n    getRelativeTop(location) {\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return null;\n        }\n        return this.view.getRelativeTop(index);\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.view.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndexTreeModel } from './indexTreeModel.js';\nimport { TreeError } from './tree.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport class ObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.nodesByIdentity = new Map();\n        this.model = new IndexTreeModel(user, list, null, options);\n        this.onDidSplice = this.model.onDidSplice;\n        this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;\n        this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;\n        if (options.sorter) {\n            this.sorter = {\n                compare(a, b) {\n                    return options.sorter.compare(a.element, b.element);\n                }\n            };\n        }\n        this.identityProvider = options.identityProvider;\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        const location = this.getElementLocation(element);\n        this._setChildren(location, this.preserveCollapseState(children), options);\n    }\n    _setChildren(location, children = Iterable.empty(), options) {\n        const insertedElements = new Set();\n        const insertedElementIds = new Set();\n        const onDidCreateNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            insertedElements.add(tnode.element);\n            this.nodes.set(tnode.element, tnode);\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                insertedElementIds.add(id);\n                this.nodesByIdentity.set(id, tnode);\n            }\n            (_a = options.onDidCreateNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        const onDidDeleteNode = (node) => {\n            var _a;\n            if (node.element === null) {\n                return;\n            }\n            const tnode = node;\n            if (!insertedElements.has(tnode.element)) {\n                this.nodes.delete(tnode.element);\n            }\n            if (this.identityProvider) {\n                const id = this.identityProvider.getId(tnode.element).toString();\n                if (!insertedElementIds.has(id)) {\n                    this.nodesByIdentity.delete(id);\n                }\n            }\n            (_a = options.onDidDeleteNode) === null || _a === void 0 ? void 0 : _a.call(options, tnode);\n        };\n        this.model.splice([...location, 0], Number.MAX_VALUE, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    preserveCollapseState(elements = Iterable.empty()) {\n        if (this.sorter) {\n            elements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return Iterable.map(elements, treeElement => {\n            let node = this.nodes.get(treeElement.element);\n            if (!node && this.identityProvider) {\n                const id = this.identityProvider.getId(treeElement.element).toString();\n                node = this.nodesByIdentity.get(id);\n            }\n            if (!node) {\n                return Object.assign(Object.assign({}, treeElement), { children: this.preserveCollapseState(treeElement.children) });\n            }\n            const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n            const collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n            return Object.assign(Object.assign({}, treeElement), { collapsible,\n                collapsed, children: this.preserveCollapseState(treeElement.children) });\n        });\n    }\n    rerender(element) {\n        const location = this.getElementLocation(element);\n        this.model.rerender(location);\n    }\n    getFirstElementChild(ref = null) {\n        const location = this.getElementLocation(ref);\n        return this.model.getFirstElementChild(location);\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(element) {\n        const location = this.getElementLocation(element);\n        return this.model.getListRenderCount(location);\n    }\n    isCollapsible(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(element, collapsible) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(element) {\n        const location = this.getElementLocation(element);\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(element, collapsed, recursive) {\n        const location = this.getElementLocation(element);\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(element) {\n        const location = this.getElementLocation(element);\n        this.model.expandTo(location);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getNode(element = null) {\n        if (element === null) {\n            return this.model.getNode(this.model.rootRef);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(element) {\n        if (element === null) {\n            throw new TreeError(this.user, `Invalid getParentNodeLocation call`);\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        const location = this.model.getNodeLocation(node);\n        const parentLocation = this.model.getParentNodeLocation(location);\n        const parent = this.model.getNode(parentLocation);\n        return parent.element;\n    }\n    getElementLocation(element) {\n        if (element === null) {\n            return [];\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return this.model.getNodeLocation(node);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nfunction noCompress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.from(element.children), noCompress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function compress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    let childrenIterator;\n    let children;\n    while (true) {\n        [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n        if (children.length !== 1) {\n            break;\n        }\n        if (children[0].incompressible) {\n            break;\n        }\n        element = children[0];\n        elements.push(element.element);\n    }\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\nfunction _decompress(element, index = 0) {\n    let children;\n    if (index < element.element.elements.length - 1) {\n        children = [_decompress(element, index + 1)];\n    }\n    else {\n        children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n    }\n    if (index === 0 && element.element.incompressible) {\n        return {\n            element: element.element.elements[index],\n            children,\n            incompressible: true,\n            collapsible: element.collapsible,\n            collapsed: element.collapsed\n        };\n    }\n    return {\n        element: element.element.elements[index],\n        children,\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function decompress(element) {\n    return _decompress(element, 0);\n}\nfunction splice(treeElement, element, children) {\n    if (treeElement.element === element) {\n        return Object.assign(Object.assign({}, treeElement), { children });\n    }\n    return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) });\n}\nconst wrapIdentityProvider = (base) => ({\n    getId(node) {\n        return node.elements.map(e => base.getId(e).toString()).join('\\0');\n    }\n});\n// Exported only for test reasons, do not use directly\nexport class CompressedObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.model = new ObjectTreeModel(user, list, options);\n        this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n        this.identityProvider = options.identityProvider;\n    }\n    get onDidSplice() { return this.model.onDidSplice; }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }\n    setChildren(element, children = Iterable.empty(), options) {\n        // Diffs must be deem, since the compression can affect nested elements.\n        // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n        const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n        if (element === null) {\n            const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n            this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });\n            return;\n        }\n        const compressedNode = this.nodes.get(element);\n        if (!compressedNode) {\n            throw new Error('Unknown compressed tree node');\n        }\n        const node = this.model.getNode(compressedNode);\n        const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n        const parent = this.model.getNode(compressedParentNode);\n        const decompressedElement = decompress(node);\n        const splicedElement = splice(decompressedElement, element, children);\n        const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n        const parentChildren = parent.children\n            .map(child => child === node ? recompressedElement : child);\n        this._setChildren(parent.element, parentChildren, {\n            diffIdentityProvider,\n            diffDepth: node.depth - parent.depth,\n        });\n    }\n    setCompressionEnabled(enabled) {\n        if (enabled === this.enabled) {\n            return;\n        }\n        this.enabled = enabled;\n        const root = this.model.getNode();\n        const rootChildren = root.children;\n        const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n        const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\n        // it should be safe to always use deep diff mode here if an identity\n        // provider is available, since we know the raw nodes are unchanged.\n        this._setChildren(null, recompressedRootChildren, {\n            diffIdentityProvider: this.identityProvider,\n            diffDepth: Infinity,\n        });\n    }\n    _setChildren(node, children, options) {\n        const insertedElements = new Set();\n        const onDidCreateNode = (node) => {\n            for (const element of node.element.elements) {\n                insertedElements.add(element);\n                this.nodes.set(element, node.element);\n            }\n        };\n        const onDidDeleteNode = (node) => {\n            for (const element of node.element.elements) {\n                if (!insertedElements.has(element)) {\n                    this.nodes.delete(element);\n                }\n            }\n        };\n        this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListIndex(node);\n    }\n    getListRenderCount(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListRenderCount(node);\n    }\n    getNode(location) {\n        if (typeof location === 'undefined') {\n            return this.model.getNode();\n        }\n        const node = this.getCompressedNode(location);\n        return this.model.getNode(node);\n    }\n    // TODO: review this\n    getNodeLocation(node) {\n        const compressedNode = this.model.getNodeLocation(node);\n        if (compressedNode === null) {\n            return null;\n        }\n        return compressedNode.elements[compressedNode.elements.length - 1];\n    }\n    // TODO: review this\n    getParentNodeLocation(location) {\n        const compressedNode = this.getCompressedNode(location);\n        const parentNode = this.model.getParentNodeLocation(compressedNode);\n        if (parentNode === null) {\n            return null;\n        }\n        return parentNode.elements[parentNode.elements.length - 1];\n    }\n    getFirstElementChild(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.getFirstElementChild(compressedNode);\n    }\n    isCollapsible(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsible(compressedNode);\n    }\n    setCollapsible(location, collapsible) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsible(compressedNode, collapsible);\n    }\n    isCollapsed(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsed(compressedNode);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsed(compressedNode, collapsed, recursive);\n    }\n    expandTo(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.expandTo(compressedNode);\n    }\n    rerender(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.rerender(compressedNode);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getCompressedNode(element) {\n        if (element === null) {\n            return null;\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\nclass CompressedTreeNodeWrapper {\n    constructor(unwrapper, node) {\n        this.unwrapper = unwrapper;\n        this.node = node;\n    }\n    get element() { return this.node.element === null ? null : this.unwrapper(this.node.element); }\n    get children() { return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nfunction mapList(nodeMapper, list) {\n    return {\n        splice(start, deleteCount, toInsert) {\n            list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n        },\n        updateElementHeight(index, height) {\n            list.updateElementHeight(index, height);\n        }\n    };\n}\nfunction mapOptions(compressedNodeUnwrapper, options) {\n    return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\n            getId(node) {\n                return options.identityProvider.getId(compressedNodeUnwrapper(node));\n            }\n        }, sorter: options.sorter && {\n            compare(node, otherNode) {\n                return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n            }\n        }, filter: options.filter && {\n            filter(node, parentVisibility) {\n                return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n            }\n        } });\n}\nexport class CompressibleObjectTreeModel {\n    constructor(user, list, options = {}) {\n        this.rootRef = null;\n        this.elementMapper = options.elementMapper || DefaultElementMapper;\n        const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n        this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n        this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n    }\n    get onDidSplice() {\n        return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({\n            insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n            deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node)),\n        }));\n    }\n    get onDidChangeCollapseState() {\n        return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({\n            node: this.nodeMapper.map(node),\n            deep\n        }));\n    }\n    get onDidChangeRenderNodeCount() {\n        return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        this.model.setChildren(element, children, options);\n    }\n    setCompressionEnabled(enabled) {\n        this.model.setCompressionEnabled(enabled);\n    }\n    has(location) {\n        return this.model.has(location);\n    }\n    getListIndex(location) {\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(location) {\n        return this.model.getListRenderCount(location);\n    }\n    getNode(location) {\n        return this.nodeMapper.map(this.model.getNode(location));\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(location) {\n        return this.model.getParentNodeLocation(location);\n    }\n    getFirstElementChild(location) {\n        const result = this.model.getFirstElementChild(location);\n        if (result === null || typeof result === 'undefined') {\n            return result;\n        }\n        return this.elementMapper(result.elements);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsed) {\n        return this.model.setCollapsible(location, collapsed);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(location) {\n        return this.model.expandTo(location);\n    }\n    rerender(location) {\n        return this.model.rerender(location);\n    }\n    refilter() {\n        return this.model.refilter();\n    }\n    getCompressedTreeNode(location = null) {\n        return this.model.getNode(location);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { AbstractTree } from './abstractTree.js';\nimport { CompressibleObjectTreeModel } from './compressedObjectTreeModel.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport class ObjectTree extends AbstractTree {\n    constructor(user, container, delegate, renderers, options = {}) {\n        super(user, container, delegate, renderers, options);\n        this.user = user;\n    }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    setChildren(element, children = Iterable.empty(), options) {\n        this.model.setChildren(element, children, options);\n    }\n    rerender(element) {\n        if (element === undefined) {\n            this.view.rerender();\n            return;\n        }\n        this.model.rerender(element);\n    }\n    hasElement(element) {\n        return this.model.has(element);\n    }\n    createModel(user, view, options) {\n        return new ObjectTreeModel(user, view, options);\n    }\n}\nclass CompressibleRenderer {\n    constructor(_compressedTreeNodeProvider, renderer) {\n        this._compressedTreeNodeProvider = _compressedTreeNodeProvider;\n        this.renderer = renderer;\n        this.templateId = renderer.templateId;\n        if (renderer.onDidChangeTwistieState) {\n            this.onDidChangeTwistieState = renderer.onDidChangeTwistieState;\n        }\n    }\n    get compressedTreeNodeProvider() {\n        return this._compressedTreeNodeProvider();\n    }\n    renderTemplate(container) {\n        const data = this.renderer.renderTemplate(container);\n        return { compressedTreeNode: undefined, data };\n    }\n    renderElement(node, index, templateData, height) {\n        const compressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element);\n        if (compressedTreeNode.element.elements.length === 1) {\n            templateData.compressedTreeNode = undefined;\n            this.renderer.renderElement(node, index, templateData.data, height);\n        }\n        else {\n            templateData.compressedTreeNode = compressedTreeNode;\n            this.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (templateData.compressedTreeNode) {\n            if (this.renderer.disposeCompressedElements) {\n                this.renderer.disposeCompressedElements(templateData.compressedTreeNode, index, templateData.data, height);\n            }\n        }\n        else {\n            if (this.renderer.disposeElement) {\n                this.renderer.disposeElement(node, index, templateData.data, height);\n            }\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.data);\n    }\n    renderTwistie(element, twistieElement) {\n        if (this.renderer.renderTwistie) {\n            return this.renderer.renderTwistie(element, twistieElement);\n        }\n        return false;\n    }\n}\n__decorate([\n    memoize\n], CompressibleRenderer.prototype, \"compressedTreeNodeProvider\", null);\nfunction asObjectTreeOptions(compressedTreeNodeProvider, options) {\n    return options && Object.assign(Object.assign({}, options), { keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            getKeyboardNavigationLabel(e) {\n                let compressedTreeNode;\n                try {\n                    compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);\n                }\n                catch (_a) {\n                    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);\n                }\n                if (compressedTreeNode.element.elements.length === 1) {\n                    return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);\n                }\n                else {\n                    return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);\n                }\n            }\n        } });\n}\nexport class CompressibleObjectTree extends ObjectTree {\n    constructor(user, container, delegate, renderers, options = {}) {\n        const compressedTreeNodeProvider = () => this;\n        const compressibleRenderers = renderers.map(r => new CompressibleRenderer(compressedTreeNodeProvider, r));\n        super(user, container, delegate, compressibleRenderers, asObjectTreeOptions(compressedTreeNodeProvider, options));\n    }\n    setChildren(element, children = Iterable.empty(), options) {\n        this.model.setChildren(element, children, options);\n    }\n    createModel(user, view, options) {\n        return new CompressibleObjectTreeModel(user, view, options);\n    }\n    updateOptions(optionsUpdate = {}) {\n        super.updateOptions(optionsUpdate);\n        if (typeof optionsUpdate.compressionEnabled !== 'undefined') {\n            this.model.setCompressionEnabled(optionsUpdate.compressionEnabled);\n        }\n    }\n    getCompressedTreeNode(element = null) {\n        return this.model.getCompressedTreeNode(element);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { isIterable } from '../../../common/types.js';\nfunction createAsyncDataTreeNode(props) {\n    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() { return this.node.element.element; }\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass AsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n    }\n}\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(e => e.element)\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        target: e.target\n    };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new AsyncDataTreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n    constructor(dnd) {\n        this.dnd = dnd;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asObjectTreeOptions(options) {\n    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {\n                return options.accessibilityProvider.getRole(el.element);\n            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {\n                var _a;\n                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n            } : undefined, getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n                return options.accessibilityProvider.getAriaLevel(node.element);\n            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), filter: options.filter && {\n            filter(e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), additionalScrollHeight: options.additionalScrollHeight });\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        this.user = user;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new Emitter();\n        this._onDidChangeNodeSlowState = new Emitter();\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n        this.disposables = new DisposableStore();\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        this.collapseByDefault = options.collapseByDefault;\n        this.tree = this.createTree(user, container, delegate, renderers, options);\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true\n        });\n        if (this.identityProvider) {\n            this.root = Object.assign(Object.assign({}, this.root), { id: null });\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.tree.onDidFocus; }\n    get onDidChangeModel() { return this.tree.onDidChangeModel; }\n    get onDidChangeCollapseState() { return this.tree.onDidChangeCollapseState; }\n    get onDidDispose() { return this.tree.onDidDispose; }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.tree.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.tree.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.tree.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.tree.domFocus();\n    }\n    layout(height, width) {\n        this.tree.layout(height, width);\n    }\n    style(styles) {\n        this.tree.style(styles);\n    }\n    // Model\n    getInput() {\n        return this.root.element;\n    }\n    setInput(input, viewState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.refreshPromises.forEach(promise => promise.cancel());\n            this.refreshPromises.clear();\n            this.root.element = input;\n            const viewStateContext = viewState && { viewState, focus: [], selection: [] };\n            yield this._updateChildren(input, true, false, viewStateContext);\n            if (viewStateContext) {\n                this.tree.setFocus(viewStateContext.focus);\n                this.tree.setSelection(viewStateContext.selection);\n            }\n            if (viewState && typeof viewState.scrollTop === 'number') {\n                this.scrollTop = viewState.scrollTop;\n            }\n        });\n    }\n    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n            if (rerender) {\n                try {\n                    this.tree.rerender(node);\n                }\n                catch (_a) {\n                    // missing nodes are fine, this could've resulted from\n                    // parallel refresh calls, removing `node` altogether\n                }\n            }\n        });\n    }\n    // View\n    rerender(element) {\n        if (element === undefined || element === this.root.element) {\n            this.tree.rerender();\n            return;\n        }\n        const node = this.getDataNode(element);\n        this.tree.rerender(node);\n    }\n    // Tree\n    getNode(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n        return this.nodeMapper.map(node);\n    }\n    collapse(element, recursive = false) {\n        const node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    }\n    expand(element, recursive = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n                return false;\n            }\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n                return false;\n            }\n            const result = this.tree.expand(node === this.root ? null : node, recursive);\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            return result;\n        });\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setSelection(nodes, browserEvent);\n    }\n    getSelection() {\n        const nodes = this.tree.getSelection();\n        return nodes.map(n => n.element);\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setFocus(nodes, browserEvent);\n    }\n    getFocus() {\n        const nodes = this.tree.getFocus();\n        return nodes.map(n => n.element);\n    }\n    reveal(element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    }\n    // Tree navigation\n    getParentElement(element) {\n        const node = this.tree.getParentElement(this.getDataNode(element));\n        return (node && node.element);\n    }\n    getFirstElementChild(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n        return (node && node.element);\n    }\n    // Implementation\n    getDataNode(element) {\n        const node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\n        }\n        return node;\n    }\n    refreshAndRenderNode(node, recursive, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.refreshNode(node, recursive, viewStateContext);\n            this.render(node, viewStateContext, options);\n        });\n    }\n    refreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n                if (!result && intersects(refreshNode, node)) {\n                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n                }\n            });\n            if (result) {\n                return result;\n            }\n            return this.doRefreshSubTree(node, recursive, viewStateContext);\n        });\n    }\n    doRefreshSubTree(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let done;\n            node.refreshPromise = new Promise(c => done = c);\n            this.subTreeRefreshPromises.set(node, node.refreshPromise);\n            node.refreshPromise.finally(() => {\n                node.refreshPromise = undefined;\n                this.subTreeRefreshPromises.delete(node);\n            });\n            try {\n                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n                node.stale = false;\n                yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n            }\n            finally {\n                done();\n            }\n        });\n    }\n    doRefreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\n            let childrenPromise;\n            if (!node.hasChildren) {\n                childrenPromise = Promise.resolve(Iterable.empty());\n            }\n            else {\n                const children = this.doGetChildren(node);\n                if (isIterable(children)) {\n                    childrenPromise = Promise.resolve(children);\n                }\n                else {\n                    const slowTimeout = timeout(800);\n                    slowTimeout.then(() => {\n                        node.slow = true;\n                        this._onDidChangeNodeSlowState.fire(node);\n                    }, _ => null);\n                    childrenPromise = children.finally(() => slowTimeout.cancel());\n                }\n            }\n            try {\n                const children = yield childrenPromise;\n                return this.setChildren(node, children, recursive, viewStateContext);\n            }\n            catch (err) {\n                if (node !== this.root && this.tree.hasElement(node)) {\n                    this.tree.collapse(node);\n                }\n                if (isCancellationError(err)) {\n                    return [];\n                }\n                throw err;\n            }\n            finally {\n                if (node.slow) {\n                    node.slow = false;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }\n            }\n        });\n    }\n    doGetChildren(node) {\n        let result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        const children = this.dataSource.getChildren(node.element);\n        if (isIterable(children)) {\n            return this.processChildren(children);\n        }\n        else {\n            result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () { return this.processChildren(yield children); }));\n            this.refreshPromises.set(node, result);\n            return result.finally(() => { this.refreshPromises.delete(node); });\n        }\n    }\n    _onDidChangeCollapseState({ node, deep }) {\n        if (node.element === null) {\n            return;\n        }\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false)\n                    .catch(onUnexpectedError);\n            }\n        }\n    }\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n        const childrenElements = [...childrenElementsIterable];\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        const nodesToForget = new Map();\n        const childrenTreeNodesById = new Map();\n        for (const child of node.children) {\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                const collapsed = this.tree.isCollapsed(child);\n                childrenTreeNodesById.set(child.id, { node: child, collapsed });\n            }\n        }\n        const childrenToRefresh = [];\n        const children = childrenElements.map(element => {\n            const hasChildren = !!this.dataSource.hasChildren(element);\n            if (!this.identityProvider) {\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });\n                if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const id = this.identityProvider.getId(element).toString();\n            const result = childrenTreeNodesById.get(id);\n            if (result) {\n                const asyncDataTreeNode = result.node;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                this.nodes.delete(asyncDataTreeNode.element);\n                this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = hasChildren;\n                if (recursive) {\n                    if (result.collapsed) {\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n                        asyncDataTreeNode.stale = true;\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                childAsyncDataTreeNode.collapsedByDefault = false;\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (const node of nodesToForget.values()) {\n            dfs(node, node => this.nodes.delete(node.element));\n        }\n        for (const child of children) {\n            this.nodes.set(child.element, child);\n        }\n        node.children.splice(0, node.children.length, ...children);\n        // TODO@joao this doesn't take filter into account\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n            children[0].collapsedByDefault = false;\n            childrenToRefresh.push(children[0]);\n        }\n        return childrenToRefresh;\n    }\n    render(node, viewStateContext, options) {\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {\n                getId(node) {\n                    return options.diffIdentityProvider.getId(node.element);\n                }\n            } });\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n        if (node !== this.root) {\n            this.tree.setCollapsible(node, node.hasChildren);\n        }\n        this._onDidRender.fire();\n    }\n    asTreeElement(node, viewStateContext) {\n        if (node.stale) {\n            return {\n                element: node,\n                collapsible: node.hasChildren,\n                collapsed: true\n            };\n        }\n        let collapsed;\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n            collapsed = false;\n        }\n        else {\n            collapsed = node.collapsedByDefault;\n        }\n        node.collapsedByDefault = undefined;\n        return {\n            element: node,\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n            collapsible: node.hasChildren,\n            collapsed\n        };\n    }\n    processChildren(children) {\n        if (this.sorter) {\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return children;\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() {\n        return {\n            elements: this.node.element.elements.map(e => e.element),\n            incompressible: this.node.element.incompressible\n        };\n    }\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass CompressibleAsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderCompressedElements(node, index, templateData, height) {\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeCompressedElements(node, index, templateData, height) {\n        if (this.renderer.disposeCompressedElements) {\n            this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.disposables = dispose(this.disposables);\n    }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n    const objectTreeOptions = options && asObjectTreeOptions(options);\n    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n            } }) });\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n        super(user, container, virtualDelegate, renderers, dataSource, options);\n        this.compressionDelegate = compressionDelegate;\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n        this.filter = options.filter;\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    asTreeElement(node, viewStateContext) {\n        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    render(node, viewStateContext) {\n        if (!this.identityProvider) {\n            return super.render(node, viewStateContext);\n        }\n        // Preserve traits across compressions. Hacky but does the trick.\n        // This is hard to fix properly since it requires rewriting the traits\n        // across trees and lists. Let's just keep it this way for now.\n        const getId = (element) => this.identityProvider.getId(element).toString();\n        const getUncompressedIds = (nodes) => {\n            const result = new Set();\n            for (const node of nodes) {\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n                if (!compressedNode.element) {\n                    continue;\n                }\n                for (const node of compressedNode.element.elements) {\n                    result.add(getId(node.element));\n                }\n            }\n            return result;\n        };\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\n        super.render(node, viewStateContext);\n        const selection = this.getSelection();\n        let didChangeSelection = false;\n        const focus = this.getFocus();\n        let didChangeFocus = false;\n        const visit = (node) => {\n            const compressedNode = node.element;\n            if (compressedNode) {\n                for (let i = 0; i < compressedNode.elements.length; i++) {\n                    const id = getId(compressedNode.elements[i].element);\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n                    // github.com/microsoft/vscode/issues/85938\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n                        selection.push(element);\n                        didChangeSelection = true;\n                    }\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n                        focus.push(element);\n                        didChangeFocus = true;\n                    }\n                }\n            }\n            node.children.forEach(visit);\n        };\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n        if (didChangeSelection) {\n            this.setSelection(selection);\n        }\n        if (didChangeFocus) {\n            this.setFocus(focus);\n        }\n    }\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n    // and we have to filter everything beforehand\n    // Related to #85193 and #85835\n    processChildren(children) {\n        if (this.filter) {\n            children = Iterable.filter(children, e => {\n                const result = this.filter.filter(e, 1 /* Visible */);\n                const visibility = getVisibility(result);\n                if (visibility === 2 /* Recurse */) {\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\n                }\n                return visibility === 1 /* Visible */;\n            });\n        }\n        return super.processChildren(children);\n    }\n}\nfunction getVisibility(filterResult) {\n    if (typeof filterResult === 'boolean') {\n        return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\n    }\n    else if (isFilterResult(filterResult)) {\n        return getVisibleState(filterResult.visibility);\n    }\n    else {\n        return getVisibleState(filterResult);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { AbstractTree } from './abstractTree.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\nexport class DataTree extends AbstractTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        super(user, container, delegate, renderers, options);\n        this.user = user;\n        this.dataSource = dataSource;\n        this.identityProvider = options.identityProvider;\n    }\n    createModel(user, view, options) {\n        return new ObjectTreeModel(user, view, options);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { createStyleSheet } from '../../../base/browser/dom.js';\nimport { PagedList } from '../../../base/browser/ui/list/listPaging.js';\nimport { DefaultStyleController, isSelectionRangeChangeEvent, isSelectionSingleChangeEvent, List } from '../../../base/browser/ui/list/listWidget.js';\nimport { Table } from '../../../base/browser/ui/table/tableWidget.js';\nimport { AsyncDataTree, CompressibleAsyncDataTree } from '../../../base/browser/ui/tree/asyncDataTree.js';\nimport { DataTree } from '../../../base/browser/ui/tree/dataTree.js';\nimport { CompressibleObjectTree, ObjectTree } from '../../../base/browser/ui/tree/objectTree.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable, DisposableStore, dispose, toDisposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nimport { IAccessibilityService } from '../../accessibility/common/accessibility.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { Extensions as ConfigurationExtensions } from '../../configuration/common/configurationRegistry.js';\nimport { ContextKeyExpr, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { InputFocusedContextKey } from '../../contextkey/common/contextkeys.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { Registry } from '../../registry/common/platform.js';\nimport { attachListStyler, computeStyles, defaultListStyles } from '../../theme/common/styler.js';\nimport { IThemeService } from '../../theme/common/themeService.js';\nexport const IListService = createDecorator('listService');\nlet ListService = class ListService {\n    constructor(_themeService) {\n        this._themeService = _themeService;\n        this.disposables = new DisposableStore();\n        this.lists = [];\n        this._lastFocusedWidget = undefined;\n        this._hasCreatedStyleController = false;\n    }\n    get lastFocusedList() {\n        return this._lastFocusedWidget;\n    }\n    setLastFocusedList(widget) {\n        var _a, _b;\n        if (widget === this._lastFocusedWidget) {\n            return;\n        }\n        (_a = this._lastFocusedWidget) === null || _a === void 0 ? void 0 : _a.getHTMLElement().classList.remove('last-focused');\n        this._lastFocusedWidget = widget;\n        (_b = this._lastFocusedWidget) === null || _b === void 0 ? void 0 : _b.getHTMLElement().classList.add('last-focused');\n    }\n    register(widget, extraContextKeys) {\n        if (!this._hasCreatedStyleController) {\n            this._hasCreatedStyleController = true;\n            // create a shared default tree style sheet for performance reasons\n            const styleController = new DefaultStyleController(createStyleSheet(), '');\n            this.disposables.add(attachListStyler(styleController, this._themeService));\n        }\n        if (this.lists.some(l => l.widget === widget)) {\n            throw new Error('Cannot register the same widget multiple times');\n        }\n        // Keep in our lists list\n        const registeredList = { widget, extraContextKeys };\n        this.lists.push(registeredList);\n        // Check for currently being focused\n        if (widget.getHTMLElement() === document.activeElement) {\n            this.setLastFocusedList(widget);\n        }\n        return combinedDisposable(widget.onDidFocus(() => this.setLastFocusedList(widget)), toDisposable(() => this.lists.splice(this.lists.indexOf(registeredList), 1)), widget.onDidDispose(() => {\n            this.lists = this.lists.filter(l => l !== registeredList);\n            if (this._lastFocusedWidget === widget) {\n                this.setLastFocusedList(undefined);\n            }\n        }));\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n};\nListService = __decorate([\n    __param(0, IThemeService)\n], ListService);\nexport { ListService };\nconst RawWorkbenchListFocusContextKey = new RawContextKey('listFocus', true);\nexport const WorkbenchListSupportsMultiSelectContextKey = new RawContextKey('listSupportsMultiselect', true);\nexport const WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey));\nexport const WorkbenchListHasSelectionOrFocus = new RawContextKey('listHasSelectionOrFocus', false);\nexport const WorkbenchListDoubleSelection = new RawContextKey('listDoubleSelection', false);\nexport const WorkbenchListMultiSelection = new RawContextKey('listMultiSelection', false);\nexport const WorkbenchListSelectionNavigation = new RawContextKey('listSelectionNavigation', false);\nexport const WorkbenchTreeElementCanCollapse = new RawContextKey('treeElementCanCollapse', false);\nexport const WorkbenchTreeElementHasParent = new RawContextKey('treeElementHasParent', false);\nexport const WorkbenchTreeElementCanExpand = new RawContextKey('treeElementCanExpand', false);\nexport const WorkbenchTreeElementHasChild = new RawContextKey('treeElementHasChild', false);\nexport const WorkbenchListAutomaticKeyboardNavigationKey = 'listAutomaticKeyboardNavigation';\nfunction createScopedContextKeyService(contextKeyService, widget) {\n    const result = contextKeyService.createScoped(widget.getHTMLElement());\n    RawWorkbenchListFocusContextKey.bindTo(result);\n    return result;\n}\nconst multiSelectModifierSettingKey = 'workbench.list.multiSelectModifier';\nconst openModeSettingKey = 'workbench.list.openMode';\nconst horizontalScrollingKey = 'workbench.list.horizontalScrolling';\nconst keyboardNavigationSettingKey = 'workbench.list.keyboardNavigation';\nconst automaticKeyboardNavigationSettingKey = 'workbench.list.automaticKeyboardNavigation';\nconst treeIndentKey = 'workbench.tree.indent';\nconst treeRenderIndentGuidesKey = 'workbench.tree.renderIndentGuides';\nconst listSmoothScrolling = 'workbench.list.smoothScrolling';\nconst mouseWheelScrollSensitivityKey = 'workbench.list.mouseWheelScrollSensitivity';\nconst fastScrollSensitivityKey = 'workbench.list.fastScrollSensitivity';\nconst treeExpandMode = 'workbench.tree.expandMode';\nfunction useAltAsMultipleSelectionModifier(configurationService) {\n    return configurationService.getValue(multiSelectModifierSettingKey) === 'alt';\n}\nclass MultipleSelectionController extends Disposable {\n    constructor(configurationService) {\n        super();\n        this.configurationService = configurationService;\n        this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(this.configurationService);\n            }\n        }));\n    }\n    isSelectionSingleChangeEvent(event) {\n        if (this.useAltAsMultipleSelectionModifier) {\n            return event.browserEvent.altKey;\n        }\n        return isSelectionSingleChangeEvent(event);\n    }\n    isSelectionRangeChangeEvent(event) {\n        return isSelectionRangeChangeEvent(event);\n    }\n}\nfunction toWorkbenchListOptions(options, configurationService, keybindingService) {\n    var _a;\n    const disposables = new DisposableStore();\n    const result = Object.assign(Object.assign({}, options), { keyboardNavigationDelegate: { mightProducePrintableCharacter(e) { return keybindingService.mightProducePrintableCharacter(e); } }, smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), mouseWheelScrollSensitivity: configurationService.getValue(mouseWheelScrollSensitivityKey), fastScrollSensitivity: configurationService.getValue(fastScrollSensitivityKey), multipleSelectionController: (_a = options.multipleSelectionController) !== null && _a !== void 0 ? _a : disposables.add(new MultipleSelectionController(configurationService)) });\n    return [result, disposables];\n}\nlet WorkbenchList = class WorkbenchList extends List {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this.horizontalScrolling = options.horizontalScrolling;\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        this.disposables.add(this.onDidChangeSelection(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.listMultiSelection.set(selection.length > 1);\n                this.listDoubleSelection.set(selection.length === 2);\n            });\n        }));\n        this.disposables.add(this.onDidChangeFocus(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n        }));\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {\n                const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });\n            }\n            if (e.affectsConfiguration(fastScrollSensitivityKey)) {\n                const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        if (options.multipleSelectionSupport !== undefined) {\n            this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        super.dispose();\n    }\n};\nWorkbenchList = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService)\n], WorkbenchList);\nexport { WorkbenchList };\nlet WorkbenchPagedList = class WorkbenchPagedList extends PagedList {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables = new DisposableStore();\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        this.horizontalScrolling = options.horizontalScrolling;\n        this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        if (options.overrideStyles) {\n            this.disposables.add(attachListStyler(this, themeService, options.overrideStyles));\n        }\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {\n                const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });\n            }\n            if (e.affectsConfiguration(fastScrollSensitivityKey)) {\n                const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new ListResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        if (options.multipleSelectionSupport !== undefined) {\n            this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.disposables.dispose();\n        super.dispose();\n    }\n};\nWorkbenchPagedList = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService)\n], WorkbenchPagedList);\nexport { WorkbenchPagedList };\nlet WorkbenchTable = class WorkbenchTable extends Table {\n    constructor(user, container, delegate, columns, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService) {\n        const horizontalScrolling = typeof options.horizontalScrolling !== 'undefined' ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));\n        const [workbenchListOptions, workbenchListOptionsDisposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n        super(user, container, delegate, columns, renderers, Object.assign(Object.assign(Object.assign({ keyboardSupport: false }, computeStyles(themeService.getColorTheme(), defaultListStyles)), workbenchListOptions), { horizontalScrolling }));\n        this.disposables.add(workbenchListOptionsDisposable);\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, this);\n        this.themeService = themeService;\n        this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this.horizontalScrolling = options.horizontalScrolling;\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        this.disposables.add(this.contextKeyService);\n        this.disposables.add(listService.register(this));\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        this.disposables.add(this.onDidChangeSelection(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.listMultiSelection.set(selection.length > 1);\n                this.listDoubleSelection.set(selection.length === 2);\n            });\n        }));\n        this.disposables.add(this.onDidChangeFocus(() => {\n            const selection = this.getSelection();\n            const focus = this.getFocus();\n            this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n        }));\n        this.disposables.add(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            let options = {};\n            if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === undefined) {\n                const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));\n                options = Object.assign(Object.assign({}, options), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));\n                options = Object.assign(Object.assign({}, options), { smoothScrolling });\n            }\n            if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {\n                const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { mouseWheelScrollSensitivity });\n            }\n            if (e.affectsConfiguration(fastScrollSensitivityKey)) {\n                const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);\n                options = Object.assign(Object.assign({}, options), { fastScrollSensitivity });\n            }\n            if (Object.keys(options).length > 0) {\n                this.updateOptions(options);\n            }\n        }));\n        this.navigator = new TableResourceNavigator(this, Object.assign({ configurationService }, options));\n        this.disposables.add(this.navigator);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.updateStyles(options.overrideStyles);\n        }\n        if (options.multipleSelectionSupport !== undefined) {\n            this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);\n        }\n    }\n    updateStyles(styles) {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._styler = attachListStyler(this, this.themeService, styles);\n    }\n    dispose() {\n        var _a;\n        (_a = this._styler) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.disposables.dispose();\n        super.dispose();\n    }\n};\nWorkbenchTable = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService)\n], WorkbenchTable);\nexport { WorkbenchTable };\nclass ResourceNavigator extends Disposable {\n    constructor(widget, options) {\n        var _a;\n        super();\n        this.widget = widget;\n        this._onDidOpen = this._register(new Emitter());\n        this.onDidOpen = this._onDidOpen.event;\n        this._register(Event.filter(this.widget.onDidChangeSelection, e => e.browserEvent instanceof KeyboardEvent)(e => this.onSelectionFromKeyboard(e)));\n        this._register(this.widget.onPointer((e) => this.onPointer(e.element, e.browserEvent)));\n        this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.element, e.browserEvent)));\n        if (typeof (options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== 'boolean' && (options === null || options === void 0 ? void 0 : options.configurationService)) {\n            this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';\n            this._register(options === null || options === void 0 ? void 0 : options.configurationService.onDidChangeConfiguration(() => {\n                this.openOnSingleClick = (options === null || options === void 0 ? void 0 : options.configurationService.getValue(openModeSettingKey)) !== 'doubleClick';\n            }));\n        }\n        else {\n            this.openOnSingleClick = (_a = options === null || options === void 0 ? void 0 : options.openOnSingleClick) !== null && _a !== void 0 ? _a : true;\n        }\n    }\n    onSelectionFromKeyboard(event) {\n        if (event.elements.length !== 1) {\n            return;\n        }\n        const selectionKeyboardEvent = event.browserEvent;\n        const preserveFocus = typeof selectionKeyboardEvent.preserveFocus === 'boolean' ? selectionKeyboardEvent.preserveFocus : true;\n        const pinned = typeof selectionKeyboardEvent.pinned === 'boolean' ? selectionKeyboardEvent.pinned : !preserveFocus;\n        const sideBySide = false;\n        this._open(this.getSelectedElement(), preserveFocus, pinned, sideBySide, event.browserEvent);\n    }\n    onPointer(element, browserEvent) {\n        if (!this.openOnSingleClick) {\n            return;\n        }\n        const isDoubleClick = browserEvent.detail === 2;\n        if (isDoubleClick) {\n            return;\n        }\n        const isMiddleClick = browserEvent.button === 1;\n        const preserveFocus = true;\n        const pinned = isMiddleClick;\n        const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;\n        this._open(element, preserveFocus, pinned, sideBySide, browserEvent);\n    }\n    onMouseDblClick(element, browserEvent) {\n        if (!browserEvent) {\n            return;\n        }\n        // copied from AbstractTree\n        const target = browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && browserEvent.offsetX < 16);\n        if (onTwistie) {\n            return;\n        }\n        const preserveFocus = false;\n        const pinned = true;\n        const sideBySide = (browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey);\n        this._open(element, preserveFocus, pinned, sideBySide, browserEvent);\n    }\n    _open(element, preserveFocus, pinned, sideBySide, browserEvent) {\n        if (!element) {\n            return;\n        }\n        this._onDidOpen.fire({\n            editorOptions: {\n                preserveFocus,\n                pinned,\n                revealIfVisible: true\n            },\n            sideBySide,\n            element,\n            browserEvent\n        });\n    }\n}\nclass ListResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n        this.widget = widget;\n    }\n    getSelectedElement() {\n        return this.widget.getSelectedElements()[0];\n    }\n}\nclass TableResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n    }\n    getSelectedElement() {\n        return this.widget.getSelectedElements()[0];\n    }\n}\nclass TreeResourceNavigator extends ResourceNavigator {\n    constructor(widget, options) {\n        super(widget, options);\n    }\n    getSelectedElement() {\n        var _a;\n        return (_a = this.widget.getSelection()[0]) !== null && _a !== void 0 ? _a : undefined;\n    }\n}\nfunction createKeyboardNavigationEventFilter(container, keybindingService) {\n    let inChord = false;\n    return event => {\n        if (event.toKeybinding().isModifierKey()) {\n            return false;\n        }\n        if (inChord) {\n            inChord = false;\n            return false;\n        }\n        const result = keybindingService.softDispatch(event, container);\n        if (result && result.enterChord) {\n            inChord = true;\n            return false;\n        }\n        inChord = false;\n        return true;\n    };\n}\nlet WorkbenchObjectTree = class WorkbenchObjectTree extends ObjectTree {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        this.internals.updateOptions(options);\n    }\n};\nWorkbenchObjectTree = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService),\n    __param(10, IAccessibilityService)\n], WorkbenchObjectTree);\nexport { WorkbenchObjectTree };\nlet WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree extends CompressibleObjectTree {\n    constructor(user, container, delegate, renderers, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n        this.internals.updateOptions(options);\n    }\n};\nWorkbenchCompressibleObjectTree = __decorate([\n    __param(5, IContextKeyService),\n    __param(6, IListService),\n    __param(7, IThemeService),\n    __param(8, IConfigurationService),\n    __param(9, IKeybindingService),\n    __param(10, IAccessibilityService)\n], WorkbenchCompressibleObjectTree);\nexport { WorkbenchCompressibleObjectTree };\nlet WorkbenchDataTree = class WorkbenchDataTree extends DataTree {\n    constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n        this.internals.updateOptions(options);\n    }\n};\nWorkbenchDataTree = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService),\n    __param(11, IAccessibilityService)\n], WorkbenchDataTree);\nexport { WorkbenchDataTree };\nlet WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, delegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    get onDidOpen() { return this.internals.onDidOpen; }\n    updateOptions(options = {}) {\n        super.updateOptions(options);\n        if (options.overrideStyles) {\n            this.internals.updateStyleOverrides(options.overrideStyles);\n        }\n        this.internals.updateOptions(options);\n    }\n};\nWorkbenchAsyncDataTree = __decorate([\n    __param(6, IContextKeyService),\n    __param(7, IListService),\n    __param(8, IThemeService),\n    __param(9, IConfigurationService),\n    __param(10, IKeybindingService),\n    __param(11, IAccessibilityService)\n], WorkbenchAsyncDataTree);\nexport { WorkbenchAsyncDataTree };\nlet WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree extends CompressibleAsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options, contextKeyService, listService, themeService, configurationService, keybindingService, accessibilityService) {\n        const { options: treeOptions, getAutomaticKeyboardNavigation, disposable } = workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService);\n        super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);\n        this.disposables.add(disposable);\n        this.internals = new WorkbenchTreeInternals(this, options, getAutomaticKeyboardNavigation, options.overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService);\n        this.disposables.add(this.internals);\n    }\n    updateOptions(options) {\n        super.updateOptions(options);\n        this.internals.updateOptions(options);\n    }\n};\nWorkbenchCompressibleAsyncDataTree = __decorate([\n    __param(7, IContextKeyService),\n    __param(8, IListService),\n    __param(9, IThemeService),\n    __param(10, IConfigurationService),\n    __param(11, IKeybindingService),\n    __param(12, IAccessibilityService)\n], WorkbenchCompressibleAsyncDataTree);\nexport { WorkbenchCompressibleAsyncDataTree };\nfunction workbenchTreeDataPreamble(container, options, contextKeyService, configurationService, keybindingService, accessibilityService) {\n    var _a;\n    const getAutomaticKeyboardNavigation = () => {\n        // give priority to the context key value to disable this completely\n        let automaticKeyboardNavigation = Boolean(contextKeyService.getContextKeyValue(WorkbenchListAutomaticKeyboardNavigationKey));\n        if (automaticKeyboardNavigation) {\n            automaticKeyboardNavigation = Boolean(configurationService.getValue(automaticKeyboardNavigationSettingKey));\n        }\n        return automaticKeyboardNavigation;\n    };\n    const accessibilityOn = accessibilityService.isScreenReaderOptimized();\n    const keyboardNavigation = options.simpleKeyboardNavigation || accessibilityOn ? 'simple' : configurationService.getValue(keyboardNavigationSettingKey);\n    const horizontalScrolling = options.horizontalScrolling !== undefined ? options.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));\n    const [workbenchListOptions, disposable] = toWorkbenchListOptions(options, configurationService, keybindingService);\n    const additionalScrollHeight = options.additionalScrollHeight;\n    return {\n        getAutomaticKeyboardNavigation,\n        disposable,\n        options: Object.assign(Object.assign({ \n            // ...options, // TODO@Joao why is this not splatted here?\n            keyboardSupport: false }, workbenchListOptions), { indent: typeof configurationService.getValue(treeIndentKey) === 'number' ? configurationService.getValue(treeIndentKey) : undefined, renderIndentGuides: configurationService.getValue(treeRenderIndentGuidesKey), smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)), automaticKeyboardNavigation: getAutomaticKeyboardNavigation(), simpleKeyboardNavigation: keyboardNavigation === 'simple', filterOnType: keyboardNavigation === 'filter', horizontalScrolling, keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(container, keybindingService), additionalScrollHeight, hideTwistiesOfChildlessElements: options.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (_a = options.expandOnlyOnTwistieClick) !== null && _a !== void 0 ? _a : (configurationService.getValue(treeExpandMode) === 'doubleClick') })\n    };\n}\nlet WorkbenchTreeInternals = class WorkbenchTreeInternals {\n    constructor(tree, options, getAutomaticKeyboardNavigation, overrideStyles, contextKeyService, listService, themeService, configurationService, accessibilityService) {\n        this.tree = tree;\n        this.themeService = themeService;\n        this.disposables = [];\n        this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);\n        this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);\n        this.listSupportsMultiSelect.set(options.multipleSelectionSupport !== false);\n        const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);\n        listSelectionNavigation.set(Boolean(options.selectionNavigation));\n        this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);\n        this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);\n        this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);\n        this.treeElementCanCollapse = WorkbenchTreeElementCanCollapse.bindTo(this.contextKeyService);\n        this.treeElementHasParent = WorkbenchTreeElementHasParent.bindTo(this.contextKeyService);\n        this.treeElementCanExpand = WorkbenchTreeElementCanExpand.bindTo(this.contextKeyService);\n        this.treeElementHasChild = WorkbenchTreeElementHasChild.bindTo(this.contextKeyService);\n        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n        const interestingContextKeys = new Set();\n        interestingContextKeys.add(WorkbenchListAutomaticKeyboardNavigationKey);\n        const updateKeyboardNavigation = () => {\n            const accessibilityOn = accessibilityService.isScreenReaderOptimized();\n            const keyboardNavigation = accessibilityOn ? 'simple' : configurationService.getValue(keyboardNavigationSettingKey);\n            tree.updateOptions({\n                simpleKeyboardNavigation: keyboardNavigation === 'simple',\n                filterOnType: keyboardNavigation === 'filter'\n            });\n        };\n        this.updateStyleOverrides(overrideStyles);\n        const updateCollapseContextKeys = () => {\n            const focus = tree.getFocus()[0];\n            if (!focus) {\n                return;\n            }\n            const node = tree.getNode(focus);\n            this.treeElementCanCollapse.set(node.collapsible && !node.collapsed);\n            this.treeElementHasParent.set(!!tree.getParentElement(focus));\n            this.treeElementCanExpand.set(node.collapsible && node.collapsed);\n            this.treeElementHasChild.set(!!tree.getFirstElementChild(focus));\n        };\n        this.disposables.push(this.contextKeyService, listService.register(tree), tree.onDidChangeSelection(() => {\n            const selection = tree.getSelection();\n            const focus = tree.getFocus();\n            this.contextKeyService.bufferChangeEvents(() => {\n                this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n                this.hasMultiSelection.set(selection.length > 1);\n                this.hasDoubleSelection.set(selection.length === 2);\n            });\n        }), tree.onDidChangeFocus(() => {\n            const selection = tree.getSelection();\n            const focus = tree.getFocus();\n            this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);\n            updateCollapseContextKeys();\n        }), tree.onDidChangeCollapseState(updateCollapseContextKeys), tree.onDidChangeModel(updateCollapseContextKeys), configurationService.onDidChangeConfiguration(e => {\n            let newOptions = {};\n            if (e.affectsConfiguration(multiSelectModifierSettingKey)) {\n                this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);\n            }\n            if (e.affectsConfiguration(treeIndentKey)) {\n                const indent = configurationService.getValue(treeIndentKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { indent });\n            }\n            if (e.affectsConfiguration(treeRenderIndentGuidesKey)) {\n                const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { renderIndentGuides });\n            }\n            if (e.affectsConfiguration(listSmoothScrolling)) {\n                const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));\n                newOptions = Object.assign(Object.assign({}, newOptions), { smoothScrolling });\n            }\n            if (e.affectsConfiguration(keyboardNavigationSettingKey)) {\n                updateKeyboardNavigation();\n            }\n            if (e.affectsConfiguration(automaticKeyboardNavigationSettingKey)) {\n                newOptions = Object.assign(Object.assign({}, newOptions), { automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });\n            }\n            if (e.affectsConfiguration(horizontalScrollingKey) && options.horizontalScrolling === undefined) {\n                const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));\n                newOptions = Object.assign(Object.assign({}, newOptions), { horizontalScrolling });\n            }\n            if (e.affectsConfiguration(treeExpandMode) && options.expandOnlyOnTwistieClick === undefined) {\n                newOptions = Object.assign(Object.assign({}, newOptions), { expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === 'doubleClick' });\n            }\n            if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {\n                const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { mouseWheelScrollSensitivity });\n            }\n            if (e.affectsConfiguration(fastScrollSensitivityKey)) {\n                const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);\n                newOptions = Object.assign(Object.assign({}, newOptions), { fastScrollSensitivity });\n            }\n            if (Object.keys(newOptions).length > 0) {\n                tree.updateOptions(newOptions);\n            }\n        }), this.contextKeyService.onDidChangeContext(e => {\n            if (e.affectsSome(interestingContextKeys)) {\n                tree.updateOptions({ automaticKeyboardNavigation: getAutomaticKeyboardNavigation() });\n            }\n        }), accessibilityService.onDidChangeScreenReaderOptimized(() => updateKeyboardNavigation()));\n        this.navigator = new TreeResourceNavigator(tree, Object.assign({ configurationService }, options));\n        this.disposables.push(this.navigator);\n    }\n    get onDidOpen() { return this.navigator.onDidOpen; }\n    updateOptions(options) {\n        if (options.multipleSelectionSupport !== undefined) {\n            this.listSupportsMultiSelect.set(!!options.multipleSelectionSupport);\n        }\n    }\n    updateStyleOverrides(overrideStyles) {\n        dispose(this.styler);\n        this.styler = overrideStyles ? attachListStyler(this.tree, this.themeService, overrideStyles) : Disposable.None;\n    }\n    dispose() {\n        this.disposables = dispose(this.disposables);\n        dispose(this.styler);\n        this.styler = undefined;\n    }\n};\nWorkbenchTreeInternals = __decorate([\n    __param(4, IContextKeyService),\n    __param(5, IListService),\n    __param(6, IThemeService),\n    __param(7, IConfigurationService),\n    __param(8, IAccessibilityService)\n], WorkbenchTreeInternals);\nconst configurationRegistry = Registry.as(ConfigurationExtensions.Configuration);\nconfigurationRegistry.registerConfiguration({\n    id: 'workbench',\n    order: 7,\n    title: localize('workbenchConfigurationTitle', \"Workbench\"),\n    type: 'object',\n    properties: {\n        [multiSelectModifierSettingKey]: {\n            type: 'string',\n            enum: ['ctrlCmd', 'alt'],\n            enumDescriptions: [\n                localize('multiSelectModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n                localize('multiSelectModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n            ],\n            default: 'ctrlCmd',\n            description: localize({\n                key: 'multiSelectModifier',\n                comment: [\n                    '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                    '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n                ]\n            }, \"The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.\")\n        },\n        [openModeSettingKey]: {\n            type: 'string',\n            enum: ['singleClick', 'doubleClick'],\n            default: 'singleClick',\n            description: localize({\n                key: 'openModeModifier',\n                comment: ['`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized.']\n            }, \"Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.\")\n        },\n        [horizontalScrollingKey]: {\n            type: 'boolean',\n            default: false,\n            description: localize('horizontalScrolling setting', \"Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.\")\n        },\n        [treeIndentKey]: {\n            type: 'number',\n            default: 8,\n            minimum: 4,\n            maximum: 40,\n            description: localize('tree indent setting', \"Controls tree indentation in pixels.\")\n        },\n        [treeRenderIndentGuidesKey]: {\n            type: 'string',\n            enum: ['none', 'onHover', 'always'],\n            default: 'onHover',\n            description: localize('render tree indent guides', \"Controls whether the tree should render indent guides.\")\n        },\n        [listSmoothScrolling]: {\n            type: 'boolean',\n            default: false,\n            description: localize('list smoothScrolling setting', \"Controls whether lists and trees have smooth scrolling.\"),\n        },\n        [mouseWheelScrollSensitivityKey]: {\n            type: 'number',\n            default: 1,\n            description: localize('Mouse Wheel Scroll Sensitivity', \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\")\n        },\n        [fastScrollSensitivityKey]: {\n            type: 'number',\n            default: 5,\n            description: localize('Fast Scroll Sensitivity', \"Scrolling speed multiplier when pressing `Alt`.\")\n        },\n        [keyboardNavigationSettingKey]: {\n            type: 'string',\n            enum: ['simple', 'highlight', 'filter'],\n            enumDescriptions: [\n                localize('keyboardNavigationSettingKey.simple', \"Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes.\"),\n                localize('keyboardNavigationSettingKey.highlight', \"Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements.\"),\n                localize('keyboardNavigationSettingKey.filter', \"Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.\")\n            ],\n            default: 'highlight',\n            description: localize('keyboardNavigationSettingKey', \"Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.\")\n        },\n        [automaticKeyboardNavigationSettingKey]: {\n            type: 'boolean',\n            default: true,\n            markdownDescription: localize('automatic keyboard navigation setting', \"Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.\")\n        },\n        [treeExpandMode]: {\n            type: 'string',\n            enum: ['singleClick', 'doubleClick'],\n            default: 'singleClick',\n            description: localize('expand mode', \"Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.\"),\n        }\n    }\n});\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ILogService = createDecorator('logService');\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\nexport const DEFAULT_LOG_LEVEL = LogLevel.Info;\nexport class AbstractLogger extends Disposable {\n    constructor() {\n        super(...arguments);\n        this.level = DEFAULT_LOG_LEVEL;\n        this._onDidChangeLogLevel = this._register(new Emitter());\n    }\n    setLevel(level) {\n        if (this.level !== level) {\n            this.level = level;\n            this._onDidChangeLogLevel.fire(this.level);\n        }\n    }\n    getLevel() {\n        return this.level;\n    }\n}\nexport class ConsoleLogger extends AbstractLogger {\n    constructor(logLevel = DEFAULT_LOG_LEVEL) {\n        super();\n        this.setLevel(logLevel);\n    }\n    trace(message, ...args) {\n        if (this.getLevel() <= LogLevel.Trace) {\n            console.log('%cTRACE', 'color: #888', message, ...args);\n        }\n    }\n    debug(message, ...args) {\n        if (this.getLevel() <= LogLevel.Debug) {\n            console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n        }\n    }\n    info(message, ...args) {\n        if (this.getLevel() <= LogLevel.Info) {\n            console.log('%c INFO', 'color: #33f', message, ...args);\n        }\n    }\n    error(message, ...args) {\n        if (this.getLevel() <= LogLevel.Error) {\n            console.log('%c  ERR', 'color: #f33', message, ...args);\n        }\n    }\n    dispose() {\n        // noop\n    }\n}\nexport class LogService extends Disposable {\n    constructor(logger) {\n        super();\n        this.logger = logger;\n        this._register(logger);\n    }\n    getLevel() {\n        return this.logger.getLevel();\n    }\n    trace(message, ...args) {\n        this.logger.trace(message, ...args);\n    }\n    debug(message, ...args) {\n        this.logger.debug(message, ...args);\n    }\n    info(message, ...args) {\n        this.logger.info(message, ...args);\n    }\n    error(message, ...args) {\n        this.logger.error(message, ...args);\n    }\n}\n","import BaseSeverity from '../../../base/common/severity.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport var Severity = BaseSeverity;\nexport const INotificationService = createDecorator('notificationService');\nexport class NoOpNotification {\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IOpenerService = createDecorator('openerService');\nexport const NullOpenerService = Object.freeze({\n    _serviceBrand: undefined,\n    registerOpener() { return Disposable.None; },\n    registerValidator() { return Disposable.None; },\n    registerExternalUriResolver() { return Disposable.None; },\n    setDefaultExternalOpener() { },\n    registerExternalOpener() { return Disposable.None; },\n    open() {\n        return __awaiter(this, void 0, void 0, function* () { return false; });\n    },\n    resolveExternalUri(uri) {\n        return __awaiter(this, void 0, void 0, function* () { return { resolved: uri, dispose() { } }; });\n    },\n});\nexport function matchesScheme(target, scheme) {\n    if (URI.isUri(target)) {\n        return equalsIgnoreCase(target.scheme, scheme);\n    }\n    else {\n        return startsWithIgnoreCase(target, scheme + ':');\n    }\n}\nexport function matchesSomeScheme(target, ...schemes) {\n    return schemes.some(scheme => matchesScheme(target, scheme));\n}\n/**\n * file:///some/file.js#73\n * file:///some/file.js#L73\n * file:///some/file.js#73,84\n * file:///some/file.js#L73,84\n * file:///some/file.js#73-83\n * file:///some/file.js#L73-L83\n * file:///some/file.js#73,84-83,52\n * file:///some/file.js#L73,84-L83,52\n */\nexport function extractSelection(uri) {\n    let selection = undefined;\n    const match = /^L?(\\d+)(?:,(\\d+))?(-L?(\\d+)(?:,(\\d+))?)?/.exec(uri.fragment);\n    if (match) {\n        selection = {\n            startLineNumber: parseInt(match[1]),\n            startColumn: match[2] ? parseInt(match[2]) : 1,\n            endLineNumber: match[4] ? parseInt(match[4]) : undefined,\n            endColumn: match[4] ? (match[5] ? parseInt(match[5]) : 1) : undefined\n        };\n        uri = uri.with({ fragment: '' });\n    }\n    return { selection, uri };\n}\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const emptyProgressRunner = Object.freeze({\n    total() { },\n    worked() { },\n    done() { }\n});\nexport class Progress {\n    constructor(callback) {\n        this.callback = callback;\n    }\n    report(item) {\n        this._value = item;\n        this.callback(this._value);\n    }\n}\nProgress.None = Object.freeze({ report() { } });\nexport const IEditorProgressService = createDecorator('editorProgressService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { Registry } from '../../registry/common/platform.js';\nexport var DefaultQuickAccessFilterValue;\n(function (DefaultQuickAccessFilterValue) {\n    /**\n     * Keep the value as it is given to quick access.\n     */\n    DefaultQuickAccessFilterValue[DefaultQuickAccessFilterValue[\"PRESERVE\"] = 0] = \"PRESERVE\";\n    /**\n     * Use the value that was used last time something was accepted from the picker.\n     */\n    DefaultQuickAccessFilterValue[DefaultQuickAccessFilterValue[\"LAST\"] = 1] = \"LAST\";\n})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));\nexport const Extensions = {\n    Quickaccess: 'workbench.contributions.quickaccess'\n};\nexport class QuickAccessRegistry {\n    constructor() {\n        this.providers = [];\n        this.defaultProvider = undefined;\n    }\n    registerQuickAccessProvider(provider) {\n        // Extract the default provider when no prefix is present\n        if (provider.prefix.length === 0) {\n            this.defaultProvider = provider;\n        }\n        else {\n            this.providers.push(provider);\n        }\n        // sort the providers by decreasing prefix length, such that longer\n        // prefixes take priority: 'ext' vs 'ext install' - the latter should win\n        this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);\n        return toDisposable(() => {\n            this.providers.splice(this.providers.indexOf(provider), 1);\n            if (this.defaultProvider === provider) {\n                this.defaultProvider = undefined;\n            }\n        });\n    }\n    getQuickAccessProviders() {\n        return coalesce([this.defaultProvider, ...this.providers]);\n    }\n    getQuickAccessProvider(prefix) {\n        const result = prefix ? (this.providers.find(provider => prefix.startsWith(provider.prefix)) || undefined) : undefined;\n        return result || this.defaultProvider;\n    }\n}\nRegistry.add(Extensions.Quickaccess, new QuickAccessRegistry());\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport * from '../../../base/parts/quickinput/common/quickInput.js';\nexport const IQuickInputService = createDecorator('quickInputService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Assert from '../../../base/common/assert.js';\nimport * as Types from '../../../base/common/types.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = new Map();\n    }\n    add(id, data) {\n        Assert.ok(Types.isString(id));\n        Assert.ok(Types.isObject(data));\n        Assert.ok(!this.data.has(id), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nexport const Registry = new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { isUndefinedOrNull } from '../../../common/types.js';\nvar StorageState;\n(function (StorageState) {\n    StorageState[StorageState[\"None\"] = 0] = \"None\";\n    StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n    StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n    constructor(database, options = Object.create(null)) {\n        super();\n        this.database = database;\n        this.options = options;\n        this._onDidChangeStorage = this._register(new Emitter());\n        this.onDidChangeStorage = this._onDidChangeStorage.event;\n        this.state = StorageState.None;\n        this.cache = new Map();\n        this.flushDelayer = new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY);\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        this.whenFlushedCallbacks = [];\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n    }\n    onDidChangeItemsExternal(e) {\n        var _a, _b;\n        // items that change external require us to update our\n        // caches with the values. we just accept the value and\n        // emit an event if there is a change.\n        (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.accept(key, value));\n        (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.accept(key, undefined));\n    }\n    accept(key, value) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        let changed = false;\n        // Item got removed, check for deletion\n        if (isUndefinedOrNull(value)) {\n            changed = this.cache.delete(key);\n        }\n        // Item got updated, check for change\n        else {\n            const currentValue = this.cache.get(key);\n            if (currentValue !== value) {\n                this.cache.set(key, value);\n                changed = true;\n            }\n        }\n        // Signal to outside listeners\n        if (changed) {\n            this._onDidChangeStorage.fire(key);\n        }\n    }\n    get(key, fallbackValue) {\n        const value = this.cache.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    }\n    getBoolean(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    }\n    getNumber(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    }\n    set(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // We remove the key for undefined/null values\n            if (isUndefinedOrNull(value)) {\n                return this.delete(key);\n            }\n            // Otherwise, convert to String and store\n            const valueStr = String(value);\n            // Return early if value already set\n            const currentValue = this.cache.get(key);\n            if (currentValue === valueStr) {\n                return;\n            }\n            // Update in cache and pending\n            this.cache.set(key, valueStr);\n            this.pendingInserts.set(key, valueStr);\n            this.pendingDeletes.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.doFlush();\n        });\n    }\n    delete(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // Remove from cache and add to pending\n            const wasDeleted = this.cache.delete(key);\n            if (!wasDeleted) {\n                return; // Return early if value already deleted\n            }\n            if (!this.pendingDeletes.has(key)) {\n                this.pendingDeletes.add(key);\n            }\n            this.pendingInserts.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.doFlush();\n        });\n    }\n    get hasPending() {\n        return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n    }\n    flushPending() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hasPending) {\n                return; // return early if nothing to do\n            }\n            // Get pending data\n            const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n            // Reset pending data for next run\n            this.pendingDeletes = new Set();\n            this.pendingInserts = new Map();\n            // Update in storage and release any\n            // waiters we have once done\n            return this.database.updateItems(updateRequest).finally(() => {\n                var _a;\n                if (!this.hasPending) {\n                    while (this.whenFlushedCallbacks.length) {\n                        (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n                    }\n                }\n            });\n        });\n    }\n    doFlush(delay) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.flushDelayer.trigger(() => this.flushPending(), delay);\n        });\n    }\n    dispose() {\n        this.flushDelayer.dispose();\n        super.dispose();\n    }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n    constructor() {\n        this.onDidChangeItemsExternal = Event.None;\n        this.items = new Map();\n    }\n    updateItems(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (request.insert) {\n                request.insert.forEach((value, key) => this.items.set(key, value));\n            }\n            if (request.delete) {\n                request.delete.forEach(key => this.items.delete(key));\n            }\n        });\n    }\n}\n","import { Emitter, PauseableEmitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { isUndefinedOrNull } from '../../../base/common/types.js';\nimport { InMemoryStorageDatabase, Storage } from '../../../base/parts/storage/common/storage.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst TARGET_KEY = '__$__targetStorageMarker';\nexport const IStorageService = createDecorator('storageService');\nexport var WillSaveStateReason;\n(function (WillSaveStateReason) {\n    /**\n     * No specific reason to save state.\n     */\n    WillSaveStateReason[WillSaveStateReason[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * A hint that the workbench is about to shutdown.\n     */\n    WillSaveStateReason[WillSaveStateReason[\"SHUTDOWN\"] = 1] = \"SHUTDOWN\";\n})(WillSaveStateReason || (WillSaveStateReason = {}));\nexport class AbstractStorageService extends Disposable {\n    constructor(options = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n        super();\n        this.options = options;\n        this._onDidChangeValue = this._register(new PauseableEmitter());\n        this._onDidChangeTarget = this._register(new PauseableEmitter());\n        this._onWillSaveState = this._register(new Emitter());\n        this.onWillSaveState = this._onWillSaveState.event;\n        this._workspaceKeyTargets = undefined;\n        this._globalKeyTargets = undefined;\n    }\n    emitDidChangeValue(scope, key) {\n        // Specially handle `TARGET_KEY`\n        if (key === TARGET_KEY) {\n            // Clear our cached version which is now out of date\n            if (scope === 0 /* GLOBAL */) {\n                this._globalKeyTargets = undefined;\n            }\n            else if (scope === 1 /* WORKSPACE */) {\n                this._workspaceKeyTargets = undefined;\n            }\n            // Emit as `didChangeTarget` event\n            this._onDidChangeTarget.fire({ scope });\n        }\n        // Emit any other key to outside\n        else {\n            this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });\n        }\n    }\n    get(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.get(key, fallbackValue);\n    }\n    getBoolean(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getBoolean(key, fallbackValue);\n    }\n    getNumber(key, scope, fallbackValue) {\n        var _a;\n        return (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.getNumber(key, fallbackValue);\n    }\n    store(key, value, scope, target) {\n        // We remove the key for undefined/null values\n        if (isUndefinedOrNull(value)) {\n            this.remove(key, scope);\n            return;\n        }\n        // Update our datastructures but send events only after\n        this.withPausedEmitters(() => {\n            var _a;\n            // Update key-target map\n            this.updateKeyTarget(key, scope, target);\n            // Store actual value\n            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(key, value);\n        });\n    }\n    remove(key, scope) {\n        // Update our datastructures but send events only after\n        this.withPausedEmitters(() => {\n            var _a;\n            // Update key-target map\n            this.updateKeyTarget(key, scope, undefined);\n            // Remove actual key\n            (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.delete(key);\n        });\n    }\n    withPausedEmitters(fn) {\n        // Pause emitters\n        this._onDidChangeValue.pause();\n        this._onDidChangeTarget.pause();\n        try {\n            fn();\n        }\n        finally {\n            // Resume emitters\n            this._onDidChangeValue.resume();\n            this._onDidChangeTarget.resume();\n        }\n    }\n    updateKeyTarget(key, scope, target) {\n        var _a, _b;\n        // Add\n        const keyTargets = this.getKeyTargets(scope);\n        if (typeof target === 'number') {\n            if (keyTargets[key] !== target) {\n                keyTargets[key] = target;\n                (_a = this.getStorage(scope)) === null || _a === void 0 ? void 0 : _a.set(TARGET_KEY, JSON.stringify(keyTargets));\n            }\n        }\n        // Remove\n        else {\n            if (typeof keyTargets[key] === 'number') {\n                delete keyTargets[key];\n                (_b = this.getStorage(scope)) === null || _b === void 0 ? void 0 : _b.set(TARGET_KEY, JSON.stringify(keyTargets));\n            }\n        }\n    }\n    get workspaceKeyTargets() {\n        if (!this._workspaceKeyTargets) {\n            this._workspaceKeyTargets = this.loadKeyTargets(1 /* WORKSPACE */);\n        }\n        return this._workspaceKeyTargets;\n    }\n    get globalKeyTargets() {\n        if (!this._globalKeyTargets) {\n            this._globalKeyTargets = this.loadKeyTargets(0 /* GLOBAL */);\n        }\n        return this._globalKeyTargets;\n    }\n    getKeyTargets(scope) {\n        return scope === 0 /* GLOBAL */ ? this.globalKeyTargets : this.workspaceKeyTargets;\n    }\n    loadKeyTargets(scope) {\n        const keysRaw = this.get(TARGET_KEY, scope);\n        if (keysRaw) {\n            try {\n                return JSON.parse(keysRaw);\n            }\n            catch (error) {\n                // Fail gracefully\n            }\n        }\n        return Object.create(null);\n    }\n}\nAbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\nexport class InMemoryStorageService extends AbstractStorageService {\n    constructor() {\n        super();\n        this.globalStorage = this._register(new Storage(new InMemoryStorageDatabase()));\n        this.workspaceStorage = this._register(new Storage(new InMemoryStorageDatabase()));\n        this._register(this.workspaceStorage.onDidChangeStorage(key => this.emitDidChangeValue(1 /* WORKSPACE */, key)));\n        this._register(this.globalStorage.onDidChangeStorage(key => this.emitDidChangeValue(0 /* GLOBAL */, key)));\n    }\n    getStorage(scope) {\n        return scope === 0 /* GLOBAL */ ? this.globalStorage : this.workspaceStorage;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ITelemetryService = createDecorator('telemetryService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { assertNever } from '../../../base/common/types.js';\nimport * as nls from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\n/**\n * Returns the css variable name for the given color identifier. Dots (`.`) are replaced with hyphens (`-`) and\n * everything is prefixed with `--vscode-`.\n *\n * @sample `editorSuggestWidget.background` is `--vscode-editorSuggestWidget-background`.\n */\nexport function asCssVariableName(colorIdent) {\n    return `--vscode-${colorIdent.replace(/\\./g, '-')}`;\n}\n// color registry\nexport const Extensions = {\n    ColorContribution: 'base.contributions.colors'\n};\nclass ColorRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.colorSchema = { type: 'object', properties: {} };\n        this.colorReferenceSchema = { type: 'string', enum: [], enumDescriptions: [] };\n        this.colorsById = {};\n    }\n    registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {\n        let colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };\n        this.colorsById[id] = colorContribution;\n        let propertySchema = { type: 'string', description, format: 'color-hex', defaultSnippets: [{ body: '${1:#ff0000}' }] };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        this.colorSchema.properties[id] = propertySchema;\n        this.colorReferenceSchema.enum.push(id);\n        this.colorReferenceSchema.enumDescriptions.push(description);\n        this._onDidChangeSchema.fire();\n        return id;\n    }\n    getColors() {\n        return Object.keys(this.colorsById).map(id => this.colorsById[id]);\n    }\n    resolveDefaultColor(id, theme) {\n        const colorDesc = this.colorsById[id];\n        if (colorDesc && colorDesc.defaults) {\n            const colorValue = colorDesc.defaults[theme.type];\n            return resolveColorValue(colorValue, theme);\n        }\n        return undefined;\n    }\n    getColorSchema() {\n        return this.colorSchema;\n    }\n    toString() {\n        let sorter = (a, b) => {\n            let cat1 = a.indexOf('.') === -1 ? 0 : 1;\n            let cat2 = b.indexOf('.') === -1 ? 0 : 1;\n            if (cat1 !== cat2) {\n                return cat1 - cat2;\n            }\n            return a.localeCompare(b);\n        };\n        return Object.keys(this.colorsById).sort(sorter).map(k => `- \\`${k}\\`: ${this.colorsById[k].description}`).join('\\n');\n    }\n}\nconst colorRegistry = new ColorRegistry();\nplatform.Registry.add(Extensions.ColorContribution, colorRegistry);\nexport function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {\n    return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);\n}\n// ----- base colors\nexport const foreground = registerColor('foreground', { dark: '#CCCCCC', light: '#616161', hc: '#FFFFFF' }, nls.localize('foreground', \"Overall foreground color. This color is only used if not overridden by a component.\"));\nexport const errorForeground = registerColor('errorForeground', { dark: '#F48771', light: '#A1260D', hc: '#F48771' }, nls.localize('errorForeground', \"Overall foreground color for error messages. This color is only used if not overridden by a component.\"));\nexport const descriptionForeground = registerColor('descriptionForeground', { light: '#717171', dark: transparent(foreground, 0.7), hc: transparent(foreground, 0.7) }, nls.localize('descriptionForeground', \"Foreground color for description text providing additional information, for example for a label.\"));\nexport const iconForeground = registerColor('icon.foreground', { dark: '#C5C5C5', light: '#424242', hc: '#FFFFFF' }, nls.localize('iconForeground', \"The default color for icons in the workbench.\"));\nexport const focusBorder = registerColor('focusBorder', { dark: '#007FD4', light: '#0090F1', hc: '#F38518' }, nls.localize('focusBorder', \"Overall border color for focused elements. This color is only used if not overridden by a component.\"));\nexport const contrastBorder = registerColor('contrastBorder', { light: null, dark: null, hc: '#6FC3DF' }, nls.localize('contrastBorder', \"An extra border around elements to separate them from others for greater contrast.\"));\nexport const activeContrastBorder = registerColor('contrastActiveBorder', { light: null, dark: null, hc: focusBorder }, nls.localize('activeContrastBorder', \"An extra border around active elements to separate them from others for greater contrast.\"));\nexport const selectionBackground = registerColor('selection.background', { light: null, dark: null, hc: null }, nls.localize('selectionBackground', \"The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor.\"));\n// ------ text colors\nexport const textSeparatorForeground = registerColor('textSeparator.foreground', { light: '#0000002e', dark: '#ffffff2e', hc: Color.black }, nls.localize('textSeparatorForeground', \"Color for text separators.\"));\nexport const textLinkForeground = registerColor('textLink.foreground', { light: '#006AB1', dark: '#3794FF', hc: '#3794FF' }, nls.localize('textLinkForeground', \"Foreground color for links in text.\"));\nexport const textLinkActiveForeground = registerColor('textLink.activeForeground', { light: '#006AB1', dark: '#3794FF', hc: '#3794FF' }, nls.localize('textLinkActiveForeground', \"Foreground color for links in text when clicked on and on mouse hover.\"));\nexport const textPreformatForeground = registerColor('textPreformat.foreground', { light: '#A31515', dark: '#D7BA7D', hc: '#D7BA7D' }, nls.localize('textPreformatForeground', \"Foreground color for preformatted text segments.\"));\nexport const textBlockQuoteBackground = registerColor('textBlockQuote.background', { light: '#7f7f7f1a', dark: '#7f7f7f1a', hc: null }, nls.localize('textBlockQuoteBackground', \"Background color for block quotes in text.\"));\nexport const textBlockQuoteBorder = registerColor('textBlockQuote.border', { light: '#007acc80', dark: '#007acc80', hc: Color.white }, nls.localize('textBlockQuoteBorder', \"Border color for block quotes in text.\"));\nexport const textCodeBlockBackground = registerColor('textCodeBlock.background', { light: '#dcdcdc66', dark: '#0a0a0a66', hc: Color.black }, nls.localize('textCodeBlockBackground', \"Background color for code blocks in text.\"));\n// ----- widgets\nexport const widgetShadow = registerColor('widget.shadow', { dark: transparent(Color.black, .36), light: transparent(Color.black, .16), hc: null }, nls.localize('widgetShadow', 'Shadow color of widgets such as find/replace inside the editor.'));\nexport const inputBackground = registerColor('input.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, nls.localize('inputBoxBackground', \"Input box background.\"));\nexport const inputForeground = registerColor('input.foreground', { dark: foreground, light: foreground, hc: foreground }, nls.localize('inputBoxForeground', \"Input box foreground.\"));\nexport const inputBorder = registerColor('input.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('inputBoxBorder', \"Input box border.\"));\nexport const inputActiveOptionBorder = registerColor('inputOption.activeBorder', { dark: '#007ACC00', light: '#007ACC00', hc: contrastBorder }, nls.localize('inputBoxActiveOptionBorder', \"Border color of activated options in input fields.\"));\nexport const inputActiveOptionHoverBackground = registerColor('inputOption.hoverBackground', { dark: '#5a5d5e80', light: '#b8b8b850', hc: null }, nls.localize('inputOption.hoverBackground', \"Background color of activated options in input fields.\"));\nexport const inputActiveOptionBackground = registerColor('inputOption.activeBackground', { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hc: Color.transparent }, nls.localize('inputOption.activeBackground', \"Background hover color of options in input fields.\"));\nexport const inputActiveOptionForeground = registerColor('inputOption.activeForeground', { dark: Color.white, light: Color.black, hc: null }, nls.localize('inputOption.activeForeground', \"Foreground color of activated options in input fields.\"));\nexport const inputPlaceholderForeground = registerColor('input.placeholderForeground', { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hc: transparent(foreground, 0.7) }, nls.localize('inputPlaceholderForeground', \"Input box foreground color for placeholder text.\"));\nexport const inputValidationInfoBackground = registerColor('inputValidation.infoBackground', { dark: '#063B49', light: '#D6ECF2', hc: Color.black }, nls.localize('inputValidationInfoBackground', \"Input validation background color for information severity.\"));\nexport const inputValidationInfoForeground = registerColor('inputValidation.infoForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationInfoForeground', \"Input validation foreground color for information severity.\"));\nexport const inputValidationInfoBorder = registerColor('inputValidation.infoBorder', { dark: '#007acc', light: '#007acc', hc: contrastBorder }, nls.localize('inputValidationInfoBorder', \"Input validation border color for information severity.\"));\nexport const inputValidationWarningBackground = registerColor('inputValidation.warningBackground', { dark: '#352A05', light: '#F6F5D2', hc: Color.black }, nls.localize('inputValidationWarningBackground', \"Input validation background color for warning severity.\"));\nexport const inputValidationWarningForeground = registerColor('inputValidation.warningForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationWarningForeground', \"Input validation foreground color for warning severity.\"));\nexport const inputValidationWarningBorder = registerColor('inputValidation.warningBorder', { dark: '#B89500', light: '#B89500', hc: contrastBorder }, nls.localize('inputValidationWarningBorder', \"Input validation border color for warning severity.\"));\nexport const inputValidationErrorBackground = registerColor('inputValidation.errorBackground', { dark: '#5A1D1D', light: '#F2DEDE', hc: Color.black }, nls.localize('inputValidationErrorBackground', \"Input validation background color for error severity.\"));\nexport const inputValidationErrorForeground = registerColor('inputValidation.errorForeground', { dark: null, light: null, hc: null }, nls.localize('inputValidationErrorForeground', \"Input validation foreground color for error severity.\"));\nexport const inputValidationErrorBorder = registerColor('inputValidation.errorBorder', { dark: '#BE1100', light: '#BE1100', hc: contrastBorder }, nls.localize('inputValidationErrorBorder', \"Input validation border color for error severity.\"));\nexport const selectBackground = registerColor('dropdown.background', { dark: '#3C3C3C', light: Color.white, hc: Color.black }, nls.localize('dropdownBackground', \"Dropdown background.\"));\nexport const selectListBackground = registerColor('dropdown.listBackground', { dark: null, light: null, hc: Color.black }, nls.localize('dropdownListBackground', \"Dropdown list background.\"));\nexport const selectForeground = registerColor('dropdown.foreground', { dark: '#F0F0F0', light: null, hc: Color.white }, nls.localize('dropdownForeground', \"Dropdown foreground.\"));\nexport const selectBorder = registerColor('dropdown.border', { dark: selectBackground, light: '#CECECE', hc: contrastBorder }, nls.localize('dropdownBorder', \"Dropdown border.\"));\nexport const simpleCheckboxBackground = registerColor('checkbox.background', { dark: selectBackground, light: selectBackground, hc: selectBackground }, nls.localize('checkbox.background', \"Background color of checkbox widget.\"));\nexport const simpleCheckboxForeground = registerColor('checkbox.foreground', { dark: selectForeground, light: selectForeground, hc: selectForeground }, nls.localize('checkbox.foreground', \"Foreground color of checkbox widget.\"));\nexport const simpleCheckboxBorder = registerColor('checkbox.border', { dark: selectBorder, light: selectBorder, hc: selectBorder }, nls.localize('checkbox.border', \"Border color of checkbox widget.\"));\nexport const buttonForeground = registerColor('button.foreground', { dark: Color.white, light: Color.white, hc: Color.white }, nls.localize('buttonForeground', \"Button foreground color.\"));\nexport const buttonBackground = registerColor('button.background', { dark: '#0E639C', light: '#007ACC', hc: null }, nls.localize('buttonBackground', \"Button background color.\"));\nexport const buttonHoverBackground = registerColor('button.hoverBackground', { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hc: null }, nls.localize('buttonHoverBackground', \"Button background color when hovering.\"));\nexport const buttonBorder = registerColor('button.border', { dark: contrastBorder, light: contrastBorder, hc: contrastBorder }, nls.localize('buttonBorder', \"Button border color.\"));\nexport const buttonSecondaryForeground = registerColor('button.secondaryForeground', { dark: Color.white, light: Color.white, hc: Color.white }, nls.localize('buttonSecondaryForeground', \"Secondary button foreground color.\"));\nexport const buttonSecondaryBackground = registerColor('button.secondaryBackground', { dark: '#3A3D41', light: '#5F6A79', hc: null }, nls.localize('buttonSecondaryBackground', \"Secondary button background color.\"));\nexport const buttonSecondaryHoverBackground = registerColor('button.secondaryHoverBackground', { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hc: null }, nls.localize('buttonSecondaryHoverBackground', \"Secondary button background color when hovering.\"));\nexport const badgeBackground = registerColor('badge.background', { dark: '#4D4D4D', light: '#C4C4C4', hc: Color.black }, nls.localize('badgeBackground', \"Badge background color. Badges are small information labels, e.g. for search results count.\"));\nexport const badgeForeground = registerColor('badge.foreground', { dark: Color.white, light: '#333', hc: Color.white }, nls.localize('badgeForeground', \"Badge foreground color. Badges are small information labels, e.g. for search results count.\"));\nexport const scrollbarShadow = registerColor('scrollbar.shadow', { dark: '#000000', light: '#DDDDDD', hc: null }, nls.localize('scrollbarShadow', \"Scrollbar shadow to indicate that the view is scrolled.\"));\nexport const scrollbarSliderBackground = registerColor('scrollbarSlider.background', { dark: Color.fromHex('#797979').transparent(0.4), light: Color.fromHex('#646464').transparent(0.4), hc: transparent(contrastBorder, 0.6) }, nls.localize('scrollbarSliderBackground', \"Scrollbar slider background color.\"));\nexport const scrollbarSliderHoverBackground = registerColor('scrollbarSlider.hoverBackground', { dark: Color.fromHex('#646464').transparent(0.7), light: Color.fromHex('#646464').transparent(0.7), hc: transparent(contrastBorder, 0.8) }, nls.localize('scrollbarSliderHoverBackground', \"Scrollbar slider background color when hovering.\"));\nexport const scrollbarSliderActiveBackground = registerColor('scrollbarSlider.activeBackground', { dark: Color.fromHex('#BFBFBF').transparent(0.4), light: Color.fromHex('#000000').transparent(0.6), hc: contrastBorder }, nls.localize('scrollbarSliderActiveBackground', \"Scrollbar slider background color when clicked on.\"));\nexport const progressBarBackground = registerColor('progressBar.background', { dark: Color.fromHex('#0E70C0'), light: Color.fromHex('#0E70C0'), hc: contrastBorder }, nls.localize('progressBarBackground', \"Background color of the progress bar that can show for long running operations.\"));\nexport const editorErrorBackground = registerColor('editorError.background', { dark: null, light: null, hc: null }, nls.localize('editorError.background', 'Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorErrorForeground = registerColor('editorError.foreground', { dark: '#F14C4C', light: '#E51400', hc: null }, nls.localize('editorError.foreground', 'Foreground color of error squigglies in the editor.'));\nexport const editorErrorBorder = registerColor('editorError.border', { dark: null, light: null, hc: Color.fromHex('#E47777').transparent(0.8) }, nls.localize('errorBorder', 'Border color of error boxes in the editor.'));\nexport const editorWarningBackground = registerColor('editorWarning.background', { dark: null, light: null, hc: null }, nls.localize('editorWarning.background', 'Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorWarningForeground = registerColor('editorWarning.foreground', { dark: '#CCA700', light: '#BF8803', hc: null }, nls.localize('editorWarning.foreground', 'Foreground color of warning squigglies in the editor.'));\nexport const editorWarningBorder = registerColor('editorWarning.border', { dark: null, light: null, hc: Color.fromHex('#FFCC00').transparent(0.8) }, nls.localize('warningBorder', 'Border color of warning boxes in the editor.'));\nexport const editorInfoBackground = registerColor('editorInfo.background', { dark: null, light: null, hc: null }, nls.localize('editorInfo.background', 'Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorInfoForeground = registerColor('editorInfo.foreground', { dark: '#3794FF', light: '#1a85ff', hc: '#3794FF' }, nls.localize('editorInfo.foreground', 'Foreground color of info squigglies in the editor.'));\nexport const editorInfoBorder = registerColor('editorInfo.border', { dark: null, light: null, hc: Color.fromHex('#3794FF').transparent(0.8) }, nls.localize('infoBorder', 'Border color of info boxes in the editor.'));\nexport const editorHintForeground = registerColor('editorHint.foreground', { dark: Color.fromHex('#eeeeee').transparent(0.7), light: '#6c6c6c', hc: null }, nls.localize('editorHint.foreground', 'Foreground color of hint squigglies in the editor.'));\nexport const editorHintBorder = registerColor('editorHint.border', { dark: null, light: null, hc: Color.fromHex('#eeeeee').transparent(0.8) }, nls.localize('hintBorder', 'Border color of hint boxes in the editor.'));\nexport const sashHoverBorder = registerColor('sash.hoverBorder', { dark: focusBorder, light: focusBorder, hc: focusBorder }, nls.localize('sashActiveBorder', \"Border color of active sashes.\"));\n/**\n * Editor background color.\n * Because of bug https://monacotools.visualstudio.com/DefaultCollection/Monaco/_workitems/edit/13254\n * we are *not* using the color white (or #ffffff, rgba(255,255,255)) but something very close to white.\n */\nexport const editorBackground = registerColor('editor.background', { light: '#fffffe', dark: '#1E1E1E', hc: Color.black }, nls.localize('editorBackground', \"Editor background color.\"));\n/**\n * Editor foreground color.\n */\nexport const editorForeground = registerColor('editor.foreground', { light: '#333333', dark: '#BBBBBB', hc: Color.white }, nls.localize('editorForeground', \"Editor default foreground color.\"));\n/**\n * Editor widgets\n */\nexport const editorWidgetBackground = registerColor('editorWidget.background', { dark: '#252526', light: '#F3F3F3', hc: '#0C141F' }, nls.localize('editorWidgetBackground', 'Background color of editor widgets, such as find/replace.'));\nexport const editorWidgetForeground = registerColor('editorWidget.foreground', { dark: foreground, light: foreground, hc: foreground }, nls.localize('editorWidgetForeground', 'Foreground color of editor widgets, such as find/replace.'));\nexport const editorWidgetBorder = registerColor('editorWidget.border', { dark: '#454545', light: '#C8C8C8', hc: contrastBorder }, nls.localize('editorWidgetBorder', 'Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.'));\nexport const editorWidgetResizeBorder = registerColor('editorWidget.resizeBorder', { light: null, dark: null, hc: null }, nls.localize('editorWidgetResizeBorder', \"Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.\"));\n/**\n * Quick pick widget\n */\nexport const quickInputBackground = registerColor('quickInput.background', { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, nls.localize('pickerBackground', \"Quick picker background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputForeground = registerColor('quickInput.foreground', { dark: editorWidgetForeground, light: editorWidgetForeground, hc: editorWidgetForeground }, nls.localize('pickerForeground', \"Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const quickInputTitleBackground = registerColor('quickInputTitle.background', { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hc: '#000000' }, nls.localize('pickerTitleBackground', \"Quick picker title background color. The quick picker widget is the container for pickers like the command palette.\"));\nexport const pickerGroupForeground = registerColor('pickerGroup.foreground', { dark: '#3794FF', light: '#0066BF', hc: Color.white }, nls.localize('pickerGroupForeground', \"Quick picker color for grouping labels.\"));\nexport const pickerGroupBorder = registerColor('pickerGroup.border', { dark: '#3F3F46', light: '#CCCEDB', hc: Color.white }, nls.localize('pickerGroupBorder', \"Quick picker color for grouping borders.\"));\n/**\n * Keybinding label\n */\nexport const keybindingLabelBackground = registerColor('keybindingLabel.background', { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hc: Color.transparent }, nls.localize('keybindingLabelBackground', \"Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelForeground = registerColor('keybindingLabel.foreground', { dark: Color.fromHex('#CCCCCC'), light: Color.fromHex('#555555'), hc: Color.white }, nls.localize('keybindingLabelForeground', \"Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBorder = registerColor('keybindingLabel.border', { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, nls.localize('keybindingLabelBorder', \"Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.\"));\nexport const keybindingLabelBottomBorder = registerColor('keybindingLabel.bottomBorder', { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, nls.localize('keybindingLabelBottomBorder', \"Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.\"));\n/**\n * Editor selection colors.\n */\nexport const editorSelectionBackground = registerColor('editor.selectionBackground', { light: '#ADD6FF', dark: '#264F78', hc: '#f3f518' }, nls.localize('editorSelectionBackground', \"Color of the editor selection.\"));\nexport const editorSelectionForeground = registerColor('editor.selectionForeground', { light: null, dark: null, hc: '#000000' }, nls.localize('editorSelectionForeground', \"Color of the selected text for high contrast.\"));\nexport const editorInactiveSelection = registerColor('editor.inactiveSelectionBackground', { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hc: transparent(editorSelectionBackground, 0.5) }, nls.localize('editorInactiveSelection', \"Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorSelectionHighlight = registerColor('editor.selectionHighlightBackground', { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hc: null }, nls.localize('editorSelectionHighlight', 'Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSelectionHighlightBorder = registerColor('editor.selectionHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('editorSelectionHighlightBorder', \"Border color for regions with the same content as the selection.\"));\n/**\n * Editor find match colors.\n */\nexport const editorFindMatch = registerColor('editor.findMatchBackground', { light: '#A8AC94', dark: '#515C6A', hc: null }, nls.localize('editorFindMatch', \"Color of the current search match.\"));\nexport const editorFindMatchHighlight = registerColor('editor.findMatchHighlightBackground', { light: '#EA5C0055', dark: '#EA5C0055', hc: null }, nls.localize('findMatchHighlight', \"Color of the other search matches. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindRangeHighlight = registerColor('editor.findRangeHighlightBackground', { dark: '#3a3d4166', light: '#b4b4b44d', hc: null }, nls.localize('findRangeHighlight', \"Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFindMatchBorder = registerColor('editor.findMatchBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('editorFindMatchBorder', \"Border color of the current search match.\"));\nexport const editorFindMatchHighlightBorder = registerColor('editor.findMatchHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('findMatchHighlightBorder', \"Border color of the other search matches.\"));\nexport const editorFindRangeHighlightBorder = registerColor('editor.findRangeHighlightBorder', { dark: null, light: null, hc: transparent(activeContrastBorder, 0.4) }, nls.localize('findRangeHighlightBorder', \"Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations.\"), true);\n/**\n * Search Editor query match colors.\n *\n * Distinct from normal editor find match to allow for better differentiation\n */\nexport const searchEditorFindMatch = registerColor('searchEditor.findMatchBackground', { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hc: editorFindMatchHighlight }, nls.localize('searchEditor.queryMatch', \"Color of the Search Editor query matches.\"));\nexport const searchEditorFindMatchBorder = registerColor('searchEditor.findMatchBorder', { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hc: editorFindMatchHighlightBorder }, nls.localize('searchEditor.editorFindMatchBorder', \"Border color of the Search Editor query matches.\"));\n/**\n * Editor hover\n */\nexport const editorHoverHighlight = registerColor('editor.hoverHighlightBackground', { light: '#ADD6FF26', dark: '#264f7840', hc: '#ADD6FF26' }, nls.localize('hoverHighlight', 'Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorHoverBackground = registerColor('editorHoverWidget.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, nls.localize('hoverBackground', 'Background color of the editor hover.'));\nexport const editorHoverForeground = registerColor('editorHoverWidget.foreground', { light: editorWidgetForeground, dark: editorWidgetForeground, hc: editorWidgetForeground }, nls.localize('hoverForeground', 'Foreground color of the editor hover.'));\nexport const editorHoverBorder = registerColor('editorHoverWidget.border', { light: editorWidgetBorder, dark: editorWidgetBorder, hc: editorWidgetBorder }, nls.localize('hoverBorder', 'Border color of the editor hover.'));\nexport const editorHoverStatusBarBackground = registerColor('editorHoverWidget.statusBarBackground', { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hc: editorWidgetBackground }, nls.localize('statusBarBackground', \"Background color of the editor hover status bar.\"));\n/**\n * Editor link colors\n */\nexport const editorActiveLinkForeground = registerColor('editorLink.activeForeground', { dark: '#4E94CE', light: Color.blue, hc: Color.cyan }, nls.localize('activeLinkForeground', 'Color of active links.'));\n/**\n * Inline hints\n */\nexport const editorInlayHintForeground = registerColor('editorInlayHint.foreground', { dark: transparent(badgeForeground, .8), light: transparent(badgeForeground, .8), hc: badgeForeground }, nls.localize('editorInlayHintForeground', 'Foreground color of inline hints'));\nexport const editorInlayHintBackground = registerColor('editorInlayHint.background', { dark: transparent(badgeBackground, .6), light: transparent(badgeBackground, .3), hc: badgeBackground }, nls.localize('editorInlayHintBackground', 'Background color of inline hints'));\nexport const editorInlayHintTypeForeground = registerColor('editorInlayHint.typeForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hc: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundTypes', 'Foreground color of inline hints for types'));\nexport const editorInlayHintTypeBackground = registerColor('editorInlayHint.typeBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hc: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundTypes', 'Background color of inline hints for types'));\nexport const editorInlayHintParameterForeground = registerColor('editorInlayHint.parameterForeground', { dark: editorInlayHintForeground, light: editorInlayHintForeground, hc: editorInlayHintForeground }, nls.localize('editorInlayHintForegroundParameter', 'Foreground color of inline hints for parameters'));\nexport const editorInlayHintParameterBackground = registerColor('editorInlayHint.parameterBackground', { dark: editorInlayHintBackground, light: editorInlayHintBackground, hc: editorInlayHintBackground }, nls.localize('editorInlayHintBackgroundParameter', 'Background color of inline hints for parameters'));\n/**\n * Editor lighbulb icon colors\n */\nexport const editorLightBulbForeground = registerColor('editorLightBulb.foreground', { dark: '#FFCC00', light: '#DDB100', hc: '#FFCC00' }, nls.localize('editorLightBulbForeground', \"The color used for the lightbulb actions icon.\"));\nexport const editorLightBulbAutoFixForeground = registerColor('editorLightBulbAutoFix.foreground', { dark: '#75BEFF', light: '#007ACC', hc: '#75BEFF' }, nls.localize('editorLightBulbAutoFixForeground', \"The color used for the lightbulb auto fix actions icon.\"));\n/**\n * Diff Editor Colors\n */\nexport const defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));\nexport const defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));\nexport const diffInserted = registerColor('diffEditor.insertedTextBackground', { dark: defaultInsertColor, light: defaultInsertColor, hc: null }, nls.localize('diffEditorInserted', 'Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffRemoved = registerColor('diffEditor.removedTextBackground', { dark: defaultRemoveColor, light: defaultRemoveColor, hc: null }, nls.localize('diffEditorRemoved', 'Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffInsertedLine = registerColor('diffEditor.insertedLineBackground', { dark: null, light: null, hc: null }, nls.localize('diffEditorInsertedLines', 'Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffRemovedLine = registerColor('diffEditor.removedLineBackground', { dark: null, light: null, hc: null }, nls.localize('diffEditorRemovedLines', 'Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const diffInsertedLineGutter = registerColor('diffEditorGutter.insertedLineBackground', { dark: null, light: null, hc: null }, nls.localize('diffEditorInsertedLineGutter', 'Background color for the margin where lines got inserted.'));\nexport const diffRemovedLineGutter = registerColor('diffEditorGutter.removedLineBackground', { dark: null, light: null, hc: null }, nls.localize('diffEditorRemovedLineGutter', 'Background color for the margin where lines got removed.'));\nexport const diffOverviewRulerInserted = registerColor('diffEditorOverview.insertedForeground', { dark: null, light: null, hc: null }, nls.localize('diffEditorOverviewInserted', 'Diff overview ruler foreground for inserted content.'));\nexport const diffOverviewRulerRemoved = registerColor('diffEditorOverview.removedForeground', { dark: null, light: null, hc: null }, nls.localize('diffEditorOverviewRemoved', 'Diff overview ruler foreground for removed content.'));\nexport const diffInsertedOutline = registerColor('diffEditor.insertedTextBorder', { dark: null, light: null, hc: '#33ff2eff' }, nls.localize('diffEditorInsertedOutline', 'Outline color for the text that got inserted.'));\nexport const diffRemovedOutline = registerColor('diffEditor.removedTextBorder', { dark: null, light: null, hc: '#FF008F' }, nls.localize('diffEditorRemovedOutline', 'Outline color for text that got removed.'));\nexport const diffBorder = registerColor('diffEditor.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('diffEditorBorder', 'Border color between the two text editors.'));\nexport const diffDiagonalFill = registerColor('diffEditor.diagonalFill', { dark: '#cccccc33', light: '#22222233', hc: null }, nls.localize('diffDiagonalFill', \"Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.\"));\n/**\n * List and tree colors\n */\nexport const listFocusBackground = registerColor('list.focusBackground', { dark: null, light: null, hc: null }, nls.localize('listFocusBackground', \"List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusForeground = registerColor('list.focusForeground', { dark: null, light: null, hc: null }, nls.localize('listFocusForeground', \"List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listFocusOutline = registerColor('list.focusOutline', { dark: focusBorder, light: focusBorder, hc: activeContrastBorder }, nls.localize('listFocusOutline', \"List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionBackground = registerColor('list.activeSelectionBackground', { dark: '#094771', light: '#0060C0', hc: null }, nls.localize('listActiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionForeground = registerColor('list.activeSelectionForeground', { dark: Color.white, light: Color.white, hc: null }, nls.localize('listActiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listActiveSelectionIconForeground = registerColor('list.activeSelectionIconForeground', { dark: null, light: null, hc: null }, nls.localize('listActiveSelectionIconForeground', \"List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionBackground = registerColor('list.inactiveSelectionBackground', { dark: '#37373D', light: '#E4E6F1', hc: null }, nls.localize('listInactiveSelectionBackground', \"List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionForeground = registerColor('list.inactiveSelectionForeground', { dark: null, light: null, hc: null }, nls.localize('listInactiveSelectionForeground', \"List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveSelectionIconForeground = registerColor('list.inactiveSelectionIconForeground', { dark: null, light: null, hc: null }, nls.localize('listInactiveSelectionIconForeground', \"List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusBackground = registerColor('list.inactiveFocusBackground', { dark: null, light: null, hc: null }, nls.localize('listInactiveFocusBackground', \"List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listInactiveFocusOutline = registerColor('list.inactiveFocusOutline', { dark: null, light: null, hc: null }, nls.localize('listInactiveFocusOutline', \"List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.\"));\nexport const listHoverBackground = registerColor('list.hoverBackground', { dark: '#2A2D2E', light: '#F0F0F0', hc: null }, nls.localize('listHoverBackground', \"List/Tree background when hovering over items using the mouse.\"));\nexport const listHoverForeground = registerColor('list.hoverForeground', { dark: null, light: null, hc: null }, nls.localize('listHoverForeground', \"List/Tree foreground when hovering over items using the mouse.\"));\nexport const listDropBackground = registerColor('list.dropBackground', { dark: '#062F4A', light: '#D6EBFF', hc: null }, nls.localize('listDropBackground', \"List/Tree drag and drop background when moving items around using the mouse.\"));\nexport const listHighlightForeground = registerColor('list.highlightForeground', { dark: '#18A3FF', light: '#0066BF', hc: focusBorder }, nls.localize('highlight', 'List/Tree foreground color of the match highlights when searching inside the list/tree.'));\nexport const listFocusHighlightForeground = registerColor('list.focusHighlightForeground', { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, '#9DDDFF'), hc: listHighlightForeground }, nls.localize('listFocusHighlightForeground', 'List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.'));\nexport const listInvalidItemForeground = registerColor('list.invalidItemForeground', { dark: '#B89500', light: '#B89500', hc: '#B89500' }, nls.localize('invalidItemForeground', 'List/Tree foreground color for invalid items, for example an unresolved root in explorer.'));\nexport const listErrorForeground = registerColor('list.errorForeground', { dark: '#F88070', light: '#B01011', hc: null }, nls.localize('listErrorForeground', 'Foreground color of list items containing errors.'));\nexport const listWarningForeground = registerColor('list.warningForeground', { dark: '#CCA700', light: '#855F00', hc: null }, nls.localize('listWarningForeground', 'Foreground color of list items containing warnings.'));\nexport const listFilterWidgetBackground = registerColor('listFilterWidget.background', { light: '#efc1ad', dark: '#653723', hc: Color.black }, nls.localize('listFilterWidgetBackground', 'Background color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetOutline = registerColor('listFilterWidget.outline', { dark: Color.transparent, light: Color.transparent, hc: '#f38518' }, nls.localize('listFilterWidgetOutline', 'Outline color of the type filter widget in lists and trees.'));\nexport const listFilterWidgetNoMatchesOutline = registerColor('listFilterWidget.noMatchesOutline', { dark: '#BE1100', light: '#BE1100', hc: contrastBorder }, nls.localize('listFilterWidgetNoMatchesOutline', 'Outline color of the type filter widget in lists and trees, when there are no matches.'));\nexport const listFilterMatchHighlight = registerColor('list.filterMatchBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null }, nls.localize('listFilterMatchHighlight', 'Background color of the filtered match.'));\nexport const listFilterMatchHighlightBorder = registerColor('list.filterMatchBorder', { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hc: contrastBorder }, nls.localize('listFilterMatchHighlightBorder', 'Border color of the filtered match.'));\nexport const treeIndentGuidesStroke = registerColor('tree.indentGuidesStroke', { dark: '#585858', light: '#a9a9a9', hc: '#a9a9a9' }, nls.localize('treeIndentGuidesStroke', \"Tree stroke color for the indentation guides.\"));\nexport const tableColumnsBorder = registerColor('tree.tableColumnsBorder', { dark: '#CCCCCC20', light: '#61616120', hc: null }, nls.localize('tableColumnsBorder', \"Table border color between columns.\"));\nexport const tableOddRowsBackgroundColor = registerColor('tree.tableOddRowsBackground', { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hc: null }, nls.localize('tableOddRowsBackgroundColor', \"Background color for odd table rows.\"));\nexport const listDeemphasizedForeground = registerColor('list.deemphasizedForeground', { dark: '#8C8C8C', light: '#8E8E90', hc: '#A7A8A9' }, nls.localize('listDeemphasizedForeground', \"List/Tree foreground color for items that are deemphasized. \"));\n/**\n * Quick pick widget (dependent on List and tree colors)\n */\nexport const _deprecatedQuickInputListFocusBackground = registerColor('quickInput.list.focusBackground', { dark: null, light: null, hc: null }, '', undefined, nls.localize('quickInput.list.focusBackground deprecation', \"Please use quickInputList.focusBackground instead\"));\nexport const quickInputListFocusForeground = registerColor('quickInputList.focusForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground }, nls.localize('quickInput.listFocusForeground', \"Quick picker foreground color for the focused item.\"));\nexport const quickInputListFocusIconForeground = registerColor('quickInputList.focusIconForeground', { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hc: listActiveSelectionIconForeground }, nls.localize('quickInput.listFocusIconForeground', \"Quick picker icon foreground color for the focused item.\"));\nexport const quickInputListFocusBackground = registerColor('quickInputList.focusBackground', { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hc: null }, nls.localize('quickInput.listFocusBackground', \"Quick picker background color for the focused item.\"));\n/**\n * Menu colors\n */\nexport const menuBorder = registerColor('menu.border', { dark: null, light: null, hc: contrastBorder }, nls.localize('menuBorder', \"Border color of menus.\"));\nexport const menuForeground = registerColor('menu.foreground', { dark: selectForeground, light: foreground, hc: selectForeground }, nls.localize('menuForeground', \"Foreground color of menu items.\"));\nexport const menuBackground = registerColor('menu.background', { dark: selectBackground, light: selectBackground, hc: selectBackground }, nls.localize('menuBackground', \"Background color of menu items.\"));\nexport const menuSelectionForeground = registerColor('menu.selectionForeground', { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground }, nls.localize('menuSelectionForeground', \"Foreground color of the selected menu item in menus.\"));\nexport const menuSelectionBackground = registerColor('menu.selectionBackground', { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hc: listActiveSelectionBackground }, nls.localize('menuSelectionBackground', \"Background color of the selected menu item in menus.\"));\nexport const menuSelectionBorder = registerColor('menu.selectionBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('menuSelectionBorder', \"Border color of the selected menu item in menus.\"));\nexport const menuSeparatorBackground = registerColor('menu.separatorBackground', { dark: '#BBBBBB', light: '#888888', hc: contrastBorder }, nls.localize('menuSeparatorBackground', \"Color of a separator menu item in menus.\"));\n/**\n * Toolbar colors\n */\nexport const toolbarHoverBackground = registerColor('toolbar.hoverBackground', { dark: '#5a5d5e50', light: '#b8b8b850', hc: null }, nls.localize('toolbarHoverBackground', \"Toolbar background when hovering over actions using the mouse\"));\nexport const toolbarHoverOutline = registerColor('toolbar.hoverOutline', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('toolbarHoverOutline', \"Toolbar outline when hovering over actions using the mouse\"));\nexport const toolbarActiveBackground = registerColor('toolbar.activeBackground', { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hc: null }, nls.localize('toolbarActiveBackground', \"Toolbar background when holding the mouse over actions\"));\n/**\n * Snippet placeholder colors\n */\nexport const snippetTabstopHighlightBackground = registerColor('editor.snippetTabstopHighlightBackground', { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hc: new Color(new RGBA(124, 124, 124, 0.3)) }, nls.localize('snippetTabstopHighlightBackground', \"Highlight background color of a snippet tabstop.\"));\nexport const snippetTabstopHighlightBorder = registerColor('editor.snippetTabstopHighlightBorder', { dark: null, light: null, hc: null }, nls.localize('snippetTabstopHighlightBorder', \"Highlight border color of a snippet tabstop.\"));\nexport const snippetFinalTabstopHighlightBackground = registerColor('editor.snippetFinalTabstopHighlightBackground', { dark: null, light: null, hc: null }, nls.localize('snippetFinalTabstopHighlightBackground', \"Highlight background color of the final tabstop of a snippet.\"));\nexport const snippetFinalTabstopHighlightBorder = registerColor('editor.snippetFinalTabstopHighlightBorder', { dark: '#525252', light: new Color(new RGBA(10, 50, 100, 0.5)), hc: '#525252' }, nls.localize('snippetFinalTabstopHighlightBorder', \"Highlight border color of the final tabstop of a snippet.\"));\n/**\n * Breadcrumb colors\n */\nexport const breadcrumbsForeground = registerColor('breadcrumb.foreground', { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hc: transparent(foreground, 0.8) }, nls.localize('breadcrumbsFocusForeground', \"Color of focused breadcrumb items.\"));\nexport const breadcrumbsBackground = registerColor('breadcrumb.background', { light: editorBackground, dark: editorBackground, hc: editorBackground }, nls.localize('breadcrumbsBackground', \"Background color of breadcrumb items.\"));\nexport const breadcrumbsFocusForeground = registerColor('breadcrumb.focusForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hc: lighten(foreground, 0.1) }, nls.localize('breadcrumbsFocusForeground', \"Color of focused breadcrumb items.\"));\nexport const breadcrumbsActiveSelectionForeground = registerColor('breadcrumb.activeSelectionForeground', { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hc: lighten(foreground, 0.1) }, nls.localize('breadcrumbsSelectedForegound', \"Color of selected breadcrumb items.\"));\nexport const breadcrumbsPickerBackground = registerColor('breadcrumbPicker.background', { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, nls.localize('breadcrumbsSelectedBackground', \"Background color of breadcrumb item picker.\"));\n/**\n * Merge-conflict colors\n */\nconst headerTransparency = 0.5;\nconst currentBaseColor = Color.fromHex('#40C8AE').transparent(headerTransparency);\nconst incomingBaseColor = Color.fromHex('#40A6FF').transparent(headerTransparency);\nconst commonBaseColor = Color.fromHex('#606060').transparent(0.4);\nconst contentTransparency = 0.4;\nconst rulerTransparency = 1;\nexport const mergeCurrentHeaderBackground = registerColor('merge.currentHeaderBackground', { dark: currentBaseColor, light: currentBaseColor, hc: null }, nls.localize('mergeCurrentHeaderBackground', 'Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCurrentContentBackground = registerColor('merge.currentContentBackground', { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hc: transparent(mergeCurrentHeaderBackground, contentTransparency) }, nls.localize('mergeCurrentContentBackground', 'Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeIncomingHeaderBackground = registerColor('merge.incomingHeaderBackground', { dark: incomingBaseColor, light: incomingBaseColor, hc: null }, nls.localize('mergeIncomingHeaderBackground', 'Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeIncomingContentBackground = registerColor('merge.incomingContentBackground', { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hc: transparent(mergeIncomingHeaderBackground, contentTransparency) }, nls.localize('mergeIncomingContentBackground', 'Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCommonHeaderBackground = registerColor('merge.commonHeaderBackground', { dark: commonBaseColor, light: commonBaseColor, hc: null }, nls.localize('mergeCommonHeaderBackground', 'Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeCommonContentBackground = registerColor('merge.commonContentBackground', { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hc: transparent(mergeCommonHeaderBackground, contentTransparency) }, nls.localize('mergeCommonContentBackground', 'Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const mergeBorder = registerColor('merge.border', { dark: null, light: null, hc: '#C3DF6F' }, nls.localize('mergeBorder', 'Border color on headers and the splitter in inline merge-conflicts.'));\nexport const overviewRulerCurrentContentForeground = registerColor('editorOverviewRuler.currentContentForeground', { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hc: mergeBorder }, nls.localize('overviewRulerCurrentContentForeground', 'Current overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerIncomingContentForeground = registerColor('editorOverviewRuler.incomingContentForeground', { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hc: mergeBorder }, nls.localize('overviewRulerIncomingContentForeground', 'Incoming overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerCommonContentForeground = registerColor('editorOverviewRuler.commonContentForeground', { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hc: mergeBorder }, nls.localize('overviewRulerCommonContentForeground', 'Common ancestor overview ruler foreground for inline merge-conflicts.'));\nexport const overviewRulerFindMatchForeground = registerColor('editorOverviewRuler.findMatchForeground', { dark: '#d186167e', light: '#d186167e', hc: '#AB5A00' }, nls.localize('overviewRulerFindMatchForeground', 'Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerSelectionHighlightForeground = registerColor('editorOverviewRuler.selectionHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, nls.localize('overviewRulerSelectionHighlightForeground', 'Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const minimapFindMatch = registerColor('minimap.findMatchHighlight', { light: '#d18616', dark: '#d18616', hc: '#AB5A00' }, nls.localize('minimapFindMatchHighlight', 'Minimap marker color for find matches.'), true);\nexport const minimapSelectionOccurrenceHighlight = registerColor('minimap.selectionOccurrenceHighlight', { light: '#c9c9c9', dark: '#676767', hc: '#ffffff' }, nls.localize('minimapSelectionOccurrenceHighlight', 'Minimap marker color for repeating editor selections.'), true);\nexport const minimapSelection = registerColor('minimap.selectionHighlight', { light: '#ADD6FF', dark: '#264F78', hc: '#ffffff' }, nls.localize('minimapSelectionHighlight', 'Minimap marker color for the editor selection.'), true);\nexport const minimapError = registerColor('minimap.errorHighlight', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, nls.localize('minimapError', 'Minimap marker color for errors.'));\nexport const minimapWarning = registerColor('minimap.warningHighlight', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Minimap marker color for warnings.'));\nexport const minimapBackground = registerColor('minimap.background', { dark: null, light: null, hc: null }, nls.localize('minimapBackground', \"Minimap background color.\"));\nexport const minimapForegroundOpacity = registerColor('minimap.foregroundOpacity', { dark: Color.fromHex('#000f'), light: Color.fromHex('#000f'), hc: Color.fromHex('#000f') }, nls.localize('minimapForegroundOpacity', 'Opacity of foreground elements rendered in the minimap. For example, \"#000000c0\" will render the elements with 75% opacity.'));\nexport const minimapSliderBackground = registerColor('minimapSlider.background', { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hc: transparent(scrollbarSliderBackground, 0.5) }, nls.localize('minimapSliderBackground', \"Minimap slider background color.\"));\nexport const minimapSliderHoverBackground = registerColor('minimapSlider.hoverBackground', { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hc: transparent(scrollbarSliderHoverBackground, 0.5) }, nls.localize('minimapSliderHoverBackground', \"Minimap slider background color when hovering.\"));\nexport const minimapSliderActiveBackground = registerColor('minimapSlider.activeBackground', { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hc: transparent(scrollbarSliderActiveBackground, 0.5) }, nls.localize('minimapSliderActiveBackground', \"Minimap slider background color when clicked on.\"));\nexport const problemsErrorIconForeground = registerColor('problemsErrorIcon.foreground', { dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground }, nls.localize('problemsErrorIconForeground', \"The color used for the problems error icon.\"));\nexport const problemsWarningIconForeground = registerColor('problemsWarningIcon.foreground', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground }, nls.localize('problemsWarningIconForeground', \"The color used for the problems warning icon.\"));\nexport const problemsInfoIconForeground = registerColor('problemsInfoIcon.foreground', { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground }, nls.localize('problemsInfoIconForeground', \"The color used for the problems info icon.\"));\n/**\n * Chart colors\n */\nexport const chartsForeground = registerColor('charts.foreground', { dark: foreground, light: foreground, hc: foreground }, nls.localize('chartsForeground', \"The foreground color used in charts.\"));\nexport const chartsLines = registerColor('charts.lines', { dark: transparent(foreground, .5), light: transparent(foreground, .5), hc: transparent(foreground, .5) }, nls.localize('chartsLines', \"The color used for horizontal lines in charts.\"));\nexport const chartsRed = registerColor('charts.red', { dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground }, nls.localize('chartsRed', \"The red color used in chart visualizations.\"));\nexport const chartsBlue = registerColor('charts.blue', { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground }, nls.localize('chartsBlue', \"The blue color used in chart visualizations.\"));\nexport const chartsYellow = registerColor('charts.yellow', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground }, nls.localize('chartsYellow', \"The yellow color used in chart visualizations.\"));\nexport const chartsOrange = registerColor('charts.orange', { dark: minimapFindMatch, light: minimapFindMatch, hc: minimapFindMatch }, nls.localize('chartsOrange', \"The orange color used in chart visualizations.\"));\nexport const chartsGreen = registerColor('charts.green', { dark: '#89D185', light: '#388A34', hc: '#89D185' }, nls.localize('chartsGreen', \"The green color used in chart visualizations.\"));\nexport const chartsPurple = registerColor('charts.purple', { dark: '#B180D7', light: '#652D90', hc: '#B180D7' }, nls.localize('chartsPurple', \"The purple color used in chart visualizations.\"));\n// ----- color functions\nexport function executeTransform(transform, theme) {\n    var _a, _b, _c;\n    switch (transform.op) {\n        case 0 /* Darken */:\n            return (_a = resolveColorValue(transform.value, theme)) === null || _a === void 0 ? void 0 : _a.darken(transform.factor);\n        case 1 /* Lighten */:\n            return (_b = resolveColorValue(transform.value, theme)) === null || _b === void 0 ? void 0 : _b.lighten(transform.factor);\n        case 2 /* Transparent */:\n            return (_c = resolveColorValue(transform.value, theme)) === null || _c === void 0 ? void 0 : _c.transparent(transform.factor);\n        case 3 /* OneOf */:\n            for (const candidate of transform.values) {\n                const color = resolveColorValue(candidate, theme);\n                if (color) {\n                    return color;\n                }\n            }\n            return undefined;\n        case 5 /* IfDefinedThenElse */:\n            return resolveColorValue(theme.defines(transform.if) ? transform.then : transform.else, theme);\n        case 4 /* LessProminent */: {\n            const from = resolveColorValue(transform.value, theme);\n            if (!from) {\n                return undefined;\n            }\n            const backgroundColor = resolveColorValue(transform.background, theme);\n            if (!backgroundColor) {\n                return from.transparent(transform.factor * transform.transparency);\n            }\n            return from.isDarkerThan(backgroundColor)\n                ? Color.getLighterColor(from, backgroundColor, transform.factor).transparent(transform.transparency)\n                : Color.getDarkerColor(from, backgroundColor, transform.factor).transparent(transform.transparency);\n        }\n        default:\n            throw assertNever(transform);\n    }\n}\nexport function darken(colorValue, factor) {\n    return { op: 0 /* Darken */, value: colorValue, factor };\n}\nexport function lighten(colorValue, factor) {\n    return { op: 1 /* Lighten */, value: colorValue, factor };\n}\nexport function transparent(colorValue, factor) {\n    return { op: 2 /* Transparent */, value: colorValue, factor };\n}\nexport function oneOf(...colorValues) {\n    return { op: 3 /* OneOf */, values: colorValues };\n}\nexport function ifDefinedThenElse(ifArg, thenArg, elseArg) {\n    return { op: 5 /* IfDefinedThenElse */, if: ifArg, then: thenArg, else: elseArg };\n}\nfunction lessProminent(colorValue, backgroundColorValue, factor, transparency) {\n    return { op: 4 /* LessProminent */, value: colorValue, background: backgroundColorValue, factor, transparency };\n}\n// ----- implementation\n/**\n * @param colorValue Resolve a color value in the context of a theme\n */\nexport function resolveColorValue(colorValue, theme) {\n    if (colorValue === null) {\n        return undefined;\n    }\n    else if (typeof colorValue === 'string') {\n        if (colorValue[0] === '#') {\n            return Color.fromHex(colorValue);\n        }\n        return theme.getColor(colorValue);\n    }\n    else if (colorValue instanceof Color) {\n        return colorValue;\n    }\n    else if (typeof colorValue === 'object') {\n        return executeTransform(colorValue, theme);\n    }\n    return undefined;\n}\nexport const workbenchColorsSchemaId = 'vscode://schemas/workbench-colors';\nlet schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);\ncolorRegistry.onDidChangeSchema(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n// setTimeout(_ => console.log(colorRegistry.toString()), 5000);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Codicon, CSSIcon } from '../../../base/common/codicons.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport * as platform from '../../registry/common/platform.js';\nimport { ThemeIcon } from './themeService.js';\n// icon registry\nexport const Extensions = {\n    IconContribution: 'base.contributions.icons'\n};\nexport var IconContribution;\n(function (IconContribution) {\n    function getDefinition(contribution, registry) {\n        let definition = contribution.defaults;\n        while (ThemeIcon.isThemeIcon(definition)) {\n            const c = iconRegistry.getIcon(definition.id);\n            if (!c) {\n                return undefined;\n            }\n            definition = c.defaults;\n        }\n        return definition;\n    }\n    IconContribution.getDefinition = getDefinition;\n})(IconContribution || (IconContribution = {}));\nclass IconRegistry {\n    constructor() {\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this.iconSchema = {\n            definitions: {\n                icons: {\n                    type: 'object',\n                    properties: {\n                        fontId: { type: 'string', description: localize('iconDefinition.fontId', 'The id of the font to use. If not set, the font that is defined first is used.') },\n                        fontCharacter: { type: 'string', description: localize('iconDefinition.fontCharacter', 'The font character associated with the icon definition.') }\n                    },\n                    additionalProperties: false,\n                    defaultSnippets: [{ body: { fontCharacter: '\\\\\\\\e030' } }]\n                }\n            },\n            type: 'object',\n            properties: {}\n        };\n        this.iconReferenceSchema = { type: 'string', pattern: `^${CSSIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };\n        this.iconsById = {};\n        this.iconFontsById = {};\n    }\n    registerIcon(id, defaults, description, deprecationMessage) {\n        const existing = this.iconsById[id];\n        if (existing) {\n            if (description && !existing.description) {\n                existing.description = description;\n                this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;\n                const enumIndex = this.iconReferenceSchema.enum.indexOf(id);\n                if (enumIndex !== -1) {\n                    this.iconReferenceSchema.enumDescriptions[enumIndex] = description;\n                }\n                this._onDidChange.fire();\n            }\n            return existing;\n        }\n        let iconContribution = { id, description, defaults, deprecationMessage };\n        this.iconsById[id] = iconContribution;\n        let propertySchema = { $ref: '#/definitions/icons' };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (description) {\n            propertySchema.markdownDescription = `${description}: $(${id})`;\n        }\n        this.iconSchema.properties[id] = propertySchema;\n        this.iconReferenceSchema.enum.push(id);\n        this.iconReferenceSchema.enumDescriptions.push(description || '');\n        this._onDidChange.fire();\n        return { id };\n    }\n    getIcons() {\n        return Object.keys(this.iconsById).map(id => this.iconsById[id]);\n    }\n    getIcon(id) {\n        return this.iconsById[id];\n    }\n    getIconSchema() {\n        return this.iconSchema;\n    }\n    toString() {\n        const sorter = (i1, i2) => {\n            return i1.id.localeCompare(i2.id);\n        };\n        const classNames = (i) => {\n            while (ThemeIcon.isThemeIcon(i.defaults)) {\n                i = this.iconsById[i.defaults.id];\n            }\n            return `codicon codicon-${i ? i.id : ''}`;\n        };\n        let reference = [];\n        reference.push(`| preview     | identifier                        | default codicon ID                | description`);\n        reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);\n        const contributions = Object.keys(this.iconsById).map(key => this.iconsById[key]);\n        for (const i of contributions.filter(i => !!i.description).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);\n        }\n        reference.push(`| preview     | identifier                        `);\n        reference.push(`| ----------- | --------------------------------- |`);\n        for (const i of contributions.filter(i => !ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|`);\n        }\n        return reference.join('\\n');\n    }\n}\nconst iconRegistry = new IconRegistry();\nplatform.Registry.add(Extensions.IconContribution, iconRegistry);\nexport function registerIcon(id, defaults, description, deprecationMessage) {\n    return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);\n}\nexport function getIconRegistry() {\n    return iconRegistry;\n}\nfunction initialize() {\n    for (const icon of Codicon.getAll()) {\n        iconRegistry.registerIcon(icon.id, icon.definition, icon.description);\n    }\n}\ninitialize();\nexport const iconsSchemaId = 'vscode://schemas/icons';\nlet schemaRegistry = platform.Registry.as(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(iconsSchemaId), 200);\niconRegistry.onDidChange(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\n//setTimeout(_ => console.log(iconRegistry.toString()), 5000);\n// common icons\nexport const widgetClose = registerIcon('widget-close', Codicon.close, localize('widgetClose', 'Icon for the close action in widgets.'));\nexport const gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, localize('previousChangeIcon', 'Icon for goto previous editor location.'));\nexport const gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, localize('nextChangeIcon', 'Icon for goto next editor location.'));\nexport const syncing = ThemeIcon.modify(Codicon.sync, 'spin');\nexport const spinningLoading = ThemeIcon.modify(Codicon.loading, 'spin');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { activeContrastBorder, badgeBackground, badgeForeground, contrastBorder, listActiveSelectionBackground, listActiveSelectionForeground, listActiveSelectionIconForeground, listDropBackground, listFilterWidgetBackground, listFilterWidgetNoMatchesOutline, listFilterWidgetOutline, listFocusBackground, listFocusForeground, listFocusOutline, listHoverBackground, listHoverForeground, listInactiveFocusBackground, listInactiveFocusOutline, listInactiveSelectionBackground, listInactiveSelectionForeground, listInactiveSelectionIconForeground, menuBackground, menuBorder, menuForeground, menuSelectionBackground, menuSelectionBorder, menuSelectionForeground, menuSeparatorBackground, resolveColorValue, scrollbarShadow, scrollbarSliderActiveBackground, scrollbarSliderBackground, scrollbarSliderHoverBackground, tableColumnsBorder, tableOddRowsBackgroundColor, treeIndentGuidesStroke, widgetShadow } from './colorRegistry.js';\nexport function computeStyles(theme, styleMap) {\n    const styles = Object.create(null);\n    for (let key in styleMap) {\n        const value = styleMap[key];\n        if (value) {\n            styles[key] = resolveColorValue(value, theme);\n        }\n    }\n    return styles;\n}\nexport function attachStyler(themeService, styleMap, widgetOrCallback) {\n    function applyStyles() {\n        const styles = computeStyles(themeService.getColorTheme(), styleMap);\n        if (typeof widgetOrCallback === 'function') {\n            widgetOrCallback(styles);\n        }\n        else {\n            widgetOrCallback.style(styles);\n        }\n    }\n    applyStyles();\n    return themeService.onDidColorThemeChange(applyStyles);\n}\nexport function attachBadgeStyler(widget, themeService, style) {\n    return attachStyler(themeService, {\n        badgeBackground: (style === null || style === void 0 ? void 0 : style.badgeBackground) || badgeBackground,\n        badgeForeground: (style === null || style === void 0 ? void 0 : style.badgeForeground) || badgeForeground,\n        badgeBorder: contrastBorder\n    }, widget);\n}\nexport function attachListStyler(widget, themeService, overrides) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultListStyles), (overrides || {})), widget);\n}\nexport const defaultListStyles = {\n    listFocusBackground,\n    listFocusForeground,\n    listFocusOutline,\n    listActiveSelectionBackground,\n    listActiveSelectionForeground,\n    listActiveSelectionIconForeground,\n    listFocusAndSelectionBackground: listActiveSelectionBackground,\n    listFocusAndSelectionForeground: listActiveSelectionForeground,\n    listInactiveSelectionBackground,\n    listInactiveSelectionIconForeground,\n    listInactiveSelectionForeground,\n    listInactiveFocusBackground,\n    listInactiveFocusOutline,\n    listHoverBackground,\n    listHoverForeground,\n    listDropBackground,\n    listSelectionOutline: activeContrastBorder,\n    listHoverOutline: activeContrastBorder,\n    listFilterWidgetBackground,\n    listFilterWidgetOutline,\n    listFilterWidgetNoMatchesOutline,\n    listMatchesShadow: widgetShadow,\n    treeIndentGuidesStroke,\n    tableColumnsBorder,\n    tableOddRowsBackgroundColor\n};\nexport const defaultMenuStyles = {\n    shadowColor: widgetShadow,\n    borderColor: menuBorder,\n    foregroundColor: menuForeground,\n    backgroundColor: menuBackground,\n    selectionForegroundColor: menuSelectionForeground,\n    selectionBackgroundColor: menuSelectionBackground,\n    selectionBorderColor: menuSelectionBorder,\n    separatorColor: menuSeparatorBackground,\n    scrollbarShadow: scrollbarShadow,\n    scrollbarSliderBackground: scrollbarSliderBackground,\n    scrollbarSliderHoverBackground: scrollbarSliderHoverBackground,\n    scrollbarSliderActiveBackground: scrollbarSliderActiveBackground\n};\nexport function attachMenuStyler(widget, themeService, style) {\n    return attachStyler(themeService, Object.assign(Object.assign({}, defaultMenuStyles), style), widget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Color scheme used by the OS and by color themes.\n */\nexport var ColorScheme;\n(function (ColorScheme) {\n    ColorScheme[\"DARK\"] = \"dark\";\n    ColorScheme[\"LIGHT\"] = \"light\";\n    ColorScheme[\"HIGH_CONTRAST\"] = \"hc\";\n})(ColorScheme || (ColorScheme = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from '../../../base/common/codicons.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport * as platform from '../../registry/common/platform.js';\nimport { ColorScheme } from './theme.js';\nexport const IThemeService = createDecorator('themeService');\nexport var ThemeColor;\n(function (ThemeColor) {\n    function isThemeColor(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string';\n    }\n    ThemeColor.isThemeColor = isThemeColor;\n})(ThemeColor || (ThemeColor = {}));\nexport function themeColorFromId(id) {\n    return { id };\n}\nexport var ThemeIcon;\n(function (ThemeIcon) {\n    function isThemeIcon(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string' && (typeof obj.color === 'undefined' || ThemeColor.isThemeColor(obj.color));\n    }\n    ThemeIcon.isThemeIcon = isThemeIcon;\n    const _regexFromString = new RegExp(`^\\\\$\\\\((${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?)\\\\)$`);\n    function fromString(str) {\n        const match = _regexFromString.exec(str);\n        if (!match) {\n            return undefined;\n        }\n        let [, name] = match;\n        return { id: name };\n    }\n    ThemeIcon.fromString = fromString;\n    function fromId(id) {\n        return { id };\n    }\n    ThemeIcon.fromId = fromId;\n    function modify(icon, modifier) {\n        let id = icon.id;\n        const tildeIndex = id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            id = id.substring(0, tildeIndex);\n        }\n        if (modifier) {\n            id = `${id}~${modifier}`;\n        }\n        return { id };\n    }\n    ThemeIcon.modify = modify;\n    function getModifier(icon) {\n        const tildeIndex = icon.id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            return icon.id.substring(tildeIndex + 1);\n        }\n        return undefined;\n    }\n    ThemeIcon.getModifier = getModifier;\n    function isEqual(ti1, ti2) {\n        var _a, _b;\n        return ti1.id === ti2.id && ((_a = ti1.color) === null || _a === void 0 ? void 0 : _a.id) === ((_b = ti2.color) === null || _b === void 0 ? void 0 : _b.id);\n    }\n    ThemeIcon.isEqual = isEqual;\n    function asThemeIcon(codicon, color) {\n        return { id: codicon.id, color: color ? themeColorFromId(color) : undefined };\n    }\n    ThemeIcon.asThemeIcon = asThemeIcon;\n    ThemeIcon.asClassNameArray = CSSIcon.asClassNameArray;\n    ThemeIcon.asClassName = CSSIcon.asClassName;\n    ThemeIcon.asCSSSelector = CSSIcon.asCSSSelector;\n})(ThemeIcon || (ThemeIcon = {}));\nexport function getThemeTypeSelector(type) {\n    switch (type) {\n        case ColorScheme.DARK: return 'vs-dark';\n        case ColorScheme.HIGH_CONTRAST: return 'hc-black';\n        default: return 'vs';\n    }\n}\n// static theming participant\nexport const Extensions = {\n    ThemingContribution: 'base.contributions.theming'\n};\nclass ThemingRegistry {\n    constructor() {\n        this.themingParticipants = [];\n        this.themingParticipants = [];\n        this.onThemingParticipantAddedEmitter = new Emitter();\n    }\n    onColorThemeChange(participant) {\n        this.themingParticipants.push(participant);\n        this.onThemingParticipantAddedEmitter.fire(participant);\n        return toDisposable(() => {\n            const idx = this.themingParticipants.indexOf(participant);\n            this.themingParticipants.splice(idx, 1);\n        });\n    }\n    getThemingParticipants() {\n        return this.themingParticipants;\n    }\n}\nlet themingRegistry = new ThemingRegistry();\nplatform.Registry.add(Extensions.ThemingContribution, themingRegistry);\nexport function registerThemingParticipant(participant) {\n    return themingRegistry.onColorThemeChange(participant);\n}\n/**\n * Utility base class for all themable components.\n */\nexport class Themable extends Disposable {\n    constructor(themeService) {\n        super();\n        this.themeService = themeService;\n        this.theme = themeService.getColorTheme();\n        // Hook up to theme changes\n        this._register(this.themeService.onDidColorThemeChange(theme => this.onThemeChange(theme)));\n    }\n    onThemeChange(theme) {\n        this.theme = theme;\n        this.updateStyles();\n    }\n    updateStyles() {\n        // Subclasses to override\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n}\nUndoRedoGroup._ID = 0;\nUndoRedoGroup.None = new UndoRedoGroup();\nexport class UndoRedoSource {\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n}\nUndoRedoSource._ID = 0;\nUndoRedoSource.None = new UndoRedoSource();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { localize } from '../../../nls.js';\nimport { TernarySearchTree } from '../../../base/common/map.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IWorkspaceContextService = createDecorator('contextService');\nexport function isSingleFolderWorkspaceIdentifier(obj) {\n    const singleFolderIdentifier = obj;\n    return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === 'string' && URI.isUri(singleFolderIdentifier.uri);\n}\nexport function toWorkspaceIdentifier(workspace) {\n    // Multi root\n    if (workspace.configuration) {\n        return {\n            id: workspace.id,\n            configPath: workspace.configuration\n        };\n    }\n    // Single folder\n    if (workspace.folders.length === 1) {\n        return {\n            id: workspace.id,\n            uri: workspace.folders[0].uri\n        };\n    }\n    // Empty workspace\n    return undefined;\n}\nexport class Workspace {\n    constructor(_id, folders, _transient, _configuration, _ignorePathCasing) {\n        this._id = _id;\n        this._transient = _transient;\n        this._configuration = _configuration;\n        this._ignorePathCasing = _ignorePathCasing;\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing);\n        this.folders = folders;\n    }\n    get folders() {\n        return this._folders;\n    }\n    set folders(folders) {\n        this._folders = folders;\n        this.updateFoldersMap();\n    }\n    get id() {\n        return this._id;\n    }\n    get transient() {\n        return this._transient;\n    }\n    get configuration() {\n        return this._configuration;\n    }\n    set configuration(configuration) {\n        this._configuration = configuration;\n    }\n    getFolder(resource) {\n        if (!resource) {\n            return null;\n        }\n        return this._foldersMap.findSubstr(resource.with({\n            scheme: resource.scheme,\n            authority: resource.authority,\n            path: resource.path\n        })) || null;\n    }\n    updateFoldersMap() {\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing);\n        for (const folder of this.folders) {\n            this._foldersMap.set(folder.uri, folder);\n        }\n    }\n    toJSON() {\n        return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration };\n    }\n}\nexport class WorkspaceFolder {\n    constructor(data, \n    /**\n     * Provides access to the original metadata for this workspace\n     * folder. This can be different from the metadata provided in\n     * this class:\n     * - raw paths can be relative\n     * - raw paths are not normalized\n     */\n    raw) {\n        this.raw = raw;\n        this.uri = data.uri;\n        this.index = data.index;\n        this.name = data.name;\n    }\n    toJSON() {\n        return { uri: this.uri, name: this.name, index: this.index };\n    }\n}\nexport const WORKSPACE_EXTENSION = 'code-workspace';\nexport const WORKSPACE_FILTER = [{ name: localize('codeWorkspace', \"Code Workspace\"), extensions: [WORKSPACE_EXTENSION] }];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IWorkspaceTrustManagementService = createDecorator('workspaceTrustManagementService');\n","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CAPTURE_METADATA = typeof process === 'undefined' ? false : !!process.env['VSCODE_TEXTMATE_DEBUG'];\nexports.IN_DEBUG_MODE = typeof process === 'undefined' ? false : !!process.env['VSCODE_TEXTMATE_DEBUG'];\n//# sourceMappingURL=debug.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nvar rule_1 = require(\"./rule\");\nvar matcher_1 = require(\"./matcher\");\nvar debug_1 = require(\"./debug\");\nfunction createGrammar(grammar, initialLanguage, embeddedLanguages, tokenTypes, grammarRepository) {\n    return new Grammar(grammar, initialLanguage, embeddedLanguages, tokenTypes, grammarRepository);\n}\nexports.createGrammar = createGrammar;\n/**\n * Fill in `result` all external included scopes in `patterns`\n */\nfunction _extractIncludedScopesInPatterns(result, patterns) {\n    for (var i = 0, len = patterns.length; i < len; i++) {\n        if (Array.isArray(patterns[i].patterns)) {\n            _extractIncludedScopesInPatterns(result, patterns[i].patterns);\n        }\n        var include = patterns[i].include;\n        if (!include) {\n            continue;\n        }\n        if (include === '$base' || include === '$self') {\n            // Special includes that can be resolved locally in this grammar\n            continue;\n        }\n        if (include.charAt(0) === '#') {\n            // Local include from this grammar\n            continue;\n        }\n        var sharpIndex = include.indexOf('#');\n        if (sharpIndex >= 0) {\n            result[include.substring(0, sharpIndex)] = true;\n        }\n        else {\n            result[include] = true;\n        }\n    }\n}\n/**\n * Fill in `result` all external included scopes in `repository`\n */\nfunction _extractIncludedScopesInRepository(result, repository) {\n    for (var name in repository) {\n        var rule = repository[name];\n        if (rule.patterns && Array.isArray(rule.patterns)) {\n            _extractIncludedScopesInPatterns(result, rule.patterns);\n        }\n        if (rule.repository) {\n            _extractIncludedScopesInRepository(result, rule.repository);\n        }\n    }\n}\n/**\n * Collects the list of all external included scopes in `grammar`.\n */\nfunction collectIncludedScopes(result, grammar) {\n    if (grammar.patterns && Array.isArray(grammar.patterns)) {\n        _extractIncludedScopesInPatterns(result, grammar.patterns);\n    }\n    if (grammar.repository) {\n        _extractIncludedScopesInRepository(result, grammar.repository);\n    }\n    // remove references to own scope (avoid recursion)\n    delete result[grammar.scopeName];\n}\nexports.collectIncludedScopes = collectIncludedScopes;\nfunction scopesAreMatching(thisScopeName, scopeName) {\n    if (!thisScopeName) {\n        return false;\n    }\n    if (thisScopeName === scopeName) {\n        return true;\n    }\n    var len = scopeName.length;\n    return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === '.';\n}\nfunction nameMatcher(identifers, scopes) {\n    if (scopes.length < identifers.length) {\n        return false;\n    }\n    var lastIndex = 0;\n    return identifers.every(function (identifier) {\n        for (var i = lastIndex; i < scopes.length; i++) {\n            if (scopesAreMatching(scopes[i], identifier)) {\n                lastIndex = i + 1;\n                return true;\n            }\n        }\n        return false;\n    });\n}\n;\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n    var matchers = matcher_1.createMatchers(selector, nameMatcher);\n    var ruleId = rule_1.RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n    for (var _i = 0, matchers_1 = matchers; _i < matchers_1.length; _i++) {\n        var matcher = matchers_1[_i];\n        result.push({\n            matcher: matcher.matcher,\n            ruleId: ruleId,\n            grammar: grammar,\n            priority: matcher.priority\n        });\n    }\n}\nvar ScopeMetadata = /** @class */ (function () {\n    function ScopeMetadata(scopeName, languageId, tokenType, themeData) {\n        this.scopeName = scopeName;\n        this.languageId = languageId;\n        this.tokenType = tokenType;\n        this.themeData = themeData;\n    }\n    return ScopeMetadata;\n}());\nexports.ScopeMetadata = ScopeMetadata;\nvar ScopeMetadataProvider = /** @class */ (function () {\n    function ScopeMetadataProvider(initialLanguage, themeProvider, embeddedLanguages) {\n        this._initialLanguage = initialLanguage;\n        this._themeProvider = themeProvider;\n        this.onDidChangeTheme();\n        // embeddedLanguages handling\n        this._embeddedLanguages = Object.create(null);\n        if (embeddedLanguages) {\n            // If embeddedLanguages are configured, fill in `this._embeddedLanguages`\n            var scopes = Object.keys(embeddedLanguages);\n            for (var i = 0, len = scopes.length; i < len; i++) {\n                var scope = scopes[i];\n                var language = embeddedLanguages[scope];\n                if (typeof language !== 'number' || language === 0) {\n                    console.warn('Invalid embedded language found at scope ' + scope + ': <<' + language + '>>');\n                    // never hurts to be too careful\n                    continue;\n                }\n                this._embeddedLanguages[scope] = language;\n            }\n        }\n        // create the regex\n        var escapedScopes = Object.keys(this._embeddedLanguages).map(function (scopeName) { return ScopeMetadataProvider._escapeRegExpCharacters(scopeName); });\n        if (escapedScopes.length === 0) {\n            // no scopes registered\n            this._embeddedLanguagesRegex = null;\n        }\n        else {\n            escapedScopes.sort();\n            escapedScopes.reverse();\n            this._embeddedLanguagesRegex = new RegExp(\"^((\" + escapedScopes.join(')|(') + \"))($|\\\\.)\", '');\n        }\n    }\n    ScopeMetadataProvider.prototype.onDidChangeTheme = function () {\n        this._cache = Object.create(null);\n        this._defaultMetaData = new ScopeMetadata('', this._initialLanguage, 0 /* Other */, [this._themeProvider.getDefaults()]);\n    };\n    ScopeMetadataProvider.prototype.getDefaultMetadata = function () {\n        return this._defaultMetaData;\n    };\n    /**\n     * Escapes regular expression characters in a given string\n     */\n    ScopeMetadataProvider._escapeRegExpCharacters = function (value) {\n        return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n    };\n    ScopeMetadataProvider.prototype.getMetadataForScope = function (scopeName) {\n        if (scopeName === null) {\n            return ScopeMetadataProvider._NULL_SCOPE_METADATA;\n        }\n        var value = this._cache[scopeName];\n        if (value) {\n            return value;\n        }\n        value = this._doGetMetadataForScope(scopeName);\n        this._cache[scopeName] = value;\n        return value;\n    };\n    ScopeMetadataProvider.prototype._doGetMetadataForScope = function (scopeName) {\n        var languageId = this._scopeToLanguage(scopeName);\n        var standardTokenType = this._toStandardTokenType(scopeName);\n        var themeData = this._themeProvider.themeMatch(scopeName);\n        return new ScopeMetadata(scopeName, languageId, standardTokenType, themeData);\n    };\n    /**\n     * Given a produced TM scope, return the language that token describes or null if unknown.\n     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n     */\n    ScopeMetadataProvider.prototype._scopeToLanguage = function (scope) {\n        if (!scope) {\n            return 0;\n        }\n        if (!this._embeddedLanguagesRegex) {\n            // no scopes registered\n            return 0;\n        }\n        var m = scope.match(this._embeddedLanguagesRegex);\n        if (!m) {\n            // no scopes matched\n            return 0;\n        }\n        var language = this._embeddedLanguages[m[1]] || 0;\n        if (!language) {\n            return 0;\n        }\n        return language;\n    };\n    ScopeMetadataProvider.prototype._toStandardTokenType = function (tokenType) {\n        var m = tokenType.match(ScopeMetadataProvider.STANDARD_TOKEN_TYPE_REGEXP);\n        if (!m) {\n            return 0 /* Other */;\n        }\n        switch (m[1]) {\n            case 'comment':\n                return 1 /* Comment */;\n            case 'string':\n                return 2 /* String */;\n            case 'regex':\n                return 4 /* RegEx */;\n            case 'meta.embedded':\n                return 8 /* MetaEmbedded */;\n        }\n        throw new Error('Unexpected match for standard token type!');\n    };\n    ScopeMetadataProvider._NULL_SCOPE_METADATA = new ScopeMetadata('', 0, 0, null);\n    ScopeMetadataProvider.STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n    return ScopeMetadataProvider;\n}());\nvar Grammar = /** @class */ (function () {\n    function Grammar(grammar, initialLanguage, embeddedLanguages, tokenTypes, grammarRepository) {\n        this._scopeMetadataProvider = new ScopeMetadataProvider(initialLanguage, grammarRepository, embeddedLanguages);\n        this._rootId = -1;\n        this._lastRuleId = 0;\n        this._ruleId2desc = [];\n        this._includedGrammars = {};\n        this._grammarRepository = grammarRepository;\n        this._grammar = initGrammar(grammar, null);\n        this._tokenTypeMatchers = [];\n        if (tokenTypes) {\n            for (var _i = 0, _a = Object.keys(tokenTypes); _i < _a.length; _i++) {\n                var selector = _a[_i];\n                var matchers = matcher_1.createMatchers(selector, nameMatcher);\n                for (var _b = 0, matchers_2 = matchers; _b < matchers_2.length; _b++) {\n                    var matcher = matchers_2[_b];\n                    this._tokenTypeMatchers.push({\n                        matcher: matcher.matcher,\n                        type: tokenTypes[selector]\n                    });\n                }\n            }\n        }\n    }\n    Grammar.prototype.onDidChangeTheme = function () {\n        this._scopeMetadataProvider.onDidChangeTheme();\n    };\n    Grammar.prototype.getMetadataForScope = function (scope) {\n        return this._scopeMetadataProvider.getMetadataForScope(scope);\n    };\n    Grammar.prototype.getInjections = function () {\n        var _this = this;\n        if (!this._injections) {\n            this._injections = [];\n            // add injections from the current grammar\n            var rawInjections = this._grammar.injections;\n            if (rawInjections) {\n                for (var expression in rawInjections) {\n                    collectInjections(this._injections, expression, rawInjections[expression], this, this._grammar);\n                }\n            }\n            // add injection grammars contributed for the current scope\n            if (this._grammarRepository) {\n                var injectionScopeNames = this._grammarRepository.injections(this._grammar.scopeName);\n                if (injectionScopeNames) {\n                    injectionScopeNames.forEach(function (injectionScopeName) {\n                        var injectionGrammar = _this.getExternalGrammar(injectionScopeName);\n                        if (injectionGrammar) {\n                            var selector = injectionGrammar.injectionSelector;\n                            if (selector) {\n                                collectInjections(_this._injections, selector, injectionGrammar, _this, injectionGrammar);\n                            }\n                        }\n                    });\n                }\n            }\n            this._injections.sort(function (i1, i2) { return i1.priority - i2.priority; }); // sort by priority\n        }\n        if (this._injections.length === 0) {\n            return this._injections;\n        }\n        return this._injections;\n    };\n    Grammar.prototype.registerRule = function (factory) {\n        var id = (++this._lastRuleId);\n        var result = factory(id);\n        this._ruleId2desc[id] = result;\n        return result;\n    };\n    Grammar.prototype.getRule = function (patternId) {\n        return this._ruleId2desc[patternId];\n    };\n    Grammar.prototype.getExternalGrammar = function (scopeName, repository) {\n        if (this._includedGrammars[scopeName]) {\n            return this._includedGrammars[scopeName];\n        }\n        else if (this._grammarRepository) {\n            var rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n            if (rawIncludedGrammar) {\n                // console.log('LOADED GRAMMAR ' + pattern.include);\n                this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);\n                return this._includedGrammars[scopeName];\n            }\n        }\n    };\n    Grammar.prototype.tokenizeLine = function (lineText, prevState) {\n        var r = this._tokenize(lineText, prevState, false);\n        return {\n            tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack\n        };\n    };\n    Grammar.prototype.tokenizeLine2 = function (lineText, prevState) {\n        var r = this._tokenize(lineText, prevState, true);\n        return {\n            tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack\n        };\n    };\n    Grammar.prototype._tokenize = function (lineText, prevState, emitBinaryTokens) {\n        if (this._rootId === -1) {\n            this._rootId = rule_1.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);\n        }\n        var isFirstLine;\n        if (!prevState || prevState === StackElement.NULL) {\n            isFirstLine = true;\n            var rawDefaultMetadata = this._scopeMetadataProvider.getDefaultMetadata();\n            var defaultTheme = rawDefaultMetadata.themeData[0];\n            var defaultMetadata = StackElementMetadata.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, defaultTheme.fontStyle, defaultTheme.foreground, defaultTheme.background);\n            var rootScopeName = this.getRule(this._rootId).getName(null, null);\n            var rawRootMetadata = this._scopeMetadataProvider.getMetadataForScope(rootScopeName);\n            var rootMetadata = ScopeListElement.mergeMetadata(defaultMetadata, null, rawRootMetadata);\n            var scopeList = new ScopeListElement(null, rootScopeName, rootMetadata);\n            prevState = new StackElement(null, this._rootId, -1, null, scopeList, scopeList);\n        }\n        else {\n            isFirstLine = false;\n            prevState.reset();\n        }\n        lineText = lineText + '\\n';\n        var onigLineText = rule_1.createOnigString(lineText);\n        var lineLength = rule_1.getString(onigLineText).length;\n        var lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers);\n        var nextState = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens);\n        return {\n            lineLength: lineLength,\n            lineTokens: lineTokens,\n            ruleStack: nextState\n        };\n    };\n    return Grammar;\n}());\nexports.Grammar = Grammar;\nfunction initGrammar(grammar, base) {\n    grammar = utils_1.clone(grammar);\n    grammar.repository = grammar.repository || {};\n    grammar.repository.$self = {\n        $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n        patterns: grammar.patterns,\n        name: grammar.scopeName\n    };\n    grammar.repository.$base = base || grammar.repository.$self;\n    return grammar;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n    if (captures.length === 0) {\n        return;\n    }\n    var len = Math.min(captures.length, captureIndices.length);\n    var localStack = [];\n    var maxEnd = captureIndices[0].end;\n    for (var i = 0; i < len; i++) {\n        var captureRule = captures[i];\n        if (captureRule === null) {\n            // Not interested\n            continue;\n        }\n        var captureIndex = captureIndices[i];\n        if (captureIndex.length === 0) {\n            // Nothing really captured\n            continue;\n        }\n        if (captureIndex.start > maxEnd) {\n            // Capture going beyond consumed string\n            break;\n        }\n        // pop captures while needed\n        while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n            // pop!\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n            localStack.pop();\n        }\n        if (localStack.length > 0) {\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n        }\n        else {\n            lineTokens.produce(stack, captureIndex.start);\n        }\n        if (captureRule.retokenizeCapturedWithRuleId) {\n            // the capture requires additional matching\n            var scopeName = captureRule.getName(rule_1.getString(lineText), captureIndices);\n            var nameScopesList = stack.contentNameScopesList.push(grammar, scopeName);\n            var contentName = captureRule.getContentName(rule_1.getString(lineText), captureIndices);\n            var contentNameScopesList = nameScopesList.push(grammar, contentName);\n            var stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, null, nameScopesList, contentNameScopesList);\n            _tokenizeString(grammar, rule_1.createOnigString(rule_1.getString(lineText).substring(0, captureIndex.end)), (isFirstLine && captureIndex.start === 0), captureIndex.start, stackClone, lineTokens);\n            continue;\n        }\n        var captureRuleScopeName = captureRule.getName(rule_1.getString(lineText), captureIndices);\n        if (captureRuleScopeName !== null) {\n            // push\n            var base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n            var captureRuleScopesList = base.push(grammar, captureRuleScopeName);\n            localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n        }\n    }\n    while (localStack.length > 0) {\n        // pop!\n        lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n        localStack.pop();\n    }\n}\nfunction debugCompiledRuleToString(ruleScanner) {\n    var r = [];\n    for (var i = 0, len = ruleScanner.rules.length; i < len; i++) {\n        r.push('   - ' + ruleScanner.rules[i] + ': ' + ruleScanner.debugRegExps[i]);\n    }\n    return r.join('\\n');\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // The lower the better\n    var bestMatchRating = Number.MAX_VALUE;\n    var bestMatchCaptureIndices = null;\n    var bestMatchRuleId;\n    var bestMatchResultPriority = 0;\n    var scopes = stack.contentNameScopesList.generateScopes();\n    for (var i = 0, len = injections.length; i < len; i++) {\n        var injection = injections[i];\n        if (!injection.matcher(scopes)) {\n            // injection selector doesn't match stack\n            continue;\n        }\n        var ruleScanner = grammar.getRule(injection.ruleId).compile(grammar, null, isFirstLine, linePos === anchorPosition);\n        var matchResult = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n        if (debug_1.IN_DEBUG_MODE) {\n            console.log('  scanning for injections');\n            console.log(debugCompiledRuleToString(ruleScanner));\n        }\n        if (!matchResult) {\n            continue;\n        }\n        var matchRating = matchResult.captureIndices[0].start;\n        if (matchRating >= bestMatchRating) {\n            // Injections are sorted by priority, so the previous injection had a better or equal priority\n            continue;\n        }\n        bestMatchRating = matchRating;\n        bestMatchCaptureIndices = matchResult.captureIndices;\n        bestMatchRuleId = ruleScanner.rules[matchResult.index];\n        bestMatchResultPriority = injection.priority;\n        if (bestMatchRating === linePos) {\n            // No more need to look at the rest of the injections.\n            break;\n        }\n    }\n    if (bestMatchCaptureIndices) {\n        return {\n            priorityMatch: bestMatchResultPriority === -1,\n            captureIndices: bestMatchCaptureIndices,\n            matchedRuleId: bestMatchRuleId\n        };\n    }\n    return null;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    var rule = stack.getRule(grammar);\n    var ruleScanner = rule.compile(grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n    var r = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n    if (debug_1.IN_DEBUG_MODE) {\n        console.log('  scanning for');\n        console.log(debugCompiledRuleToString(ruleScanner));\n    }\n    if (r) {\n        return {\n            captureIndices: r.captureIndices,\n            matchedRuleId: ruleScanner.rules[r.index]\n        };\n    }\n    return null;\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // Look for normal grammar rule\n    var matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    // Look for injected rules\n    var injections = grammar.getInjections();\n    if (injections.length === 0) {\n        // No injections whatsoever => early return\n        return matchResult;\n    }\n    var injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    if (!injectionResult) {\n        // No injections matched => early return\n        return matchResult;\n    }\n    if (!matchResult) {\n        // Only injections matched => early return\n        return injectionResult;\n    }\n    // Decide if `matchResult` or `injectionResult` should win\n    var matchResultScore = matchResult.captureIndices[0].start;\n    var injectionResultScore = injectionResult.captureIndices[0].start;\n    if (injectionResultScore < matchResultScore || (injectionResult.priorityMatch && injectionResultScore === matchResultScore)) {\n        // injection won!\n        return injectionResult;\n    }\n    return matchResult;\n}\n/**\n * Walk the stack from bottom to top, and check each while condition in this order.\n * If any fails, cut off the entire stack above the failed while condition. While conditions\n * may also advance the linePosition.\n */\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n    var anchorPosition = -1;\n    var whileRules = [];\n    for (var node = stack; node; node = node.pop()) {\n        var nodeRule = node.getRule(grammar);\n        if (nodeRule instanceof rule_1.BeginWhileRule) {\n            whileRules.push({\n                rule: nodeRule,\n                stack: node\n            });\n        }\n    }\n    for (var whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n        var ruleScanner = whileRule.rule.compileWhile(grammar, whileRule.stack.endRule, isFirstLine, anchorPosition === linePos);\n        var r = ruleScanner.scanner.findNextMatchSync(lineText, linePos);\n        if (debug_1.IN_DEBUG_MODE) {\n            console.log('  scanning for while rule');\n            console.log(debugCompiledRuleToString(ruleScanner));\n        }\n        if (r) {\n            var matchedRuleId = ruleScanner.rules[r.index];\n            if (matchedRuleId !== -2) {\n                // we shouldn't end up here\n                stack = whileRule.stack.pop();\n                break;\n            }\n            if (r.captureIndices && r.captureIndices.length) {\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n                handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n                anchorPosition = r.captureIndices[0].end;\n                if (r.captureIndices[0].end > linePos) {\n                    linePos = r.captureIndices[0].end;\n                    isFirstLine = false;\n                }\n            }\n        }\n        else {\n            stack = whileRule.stack.pop();\n            break;\n        }\n    }\n    return { stack: stack, linePos: linePos, anchorPosition: anchorPosition, isFirstLine: isFirstLine };\n}\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n    var lineLength = rule_1.getString(lineText).length;\n    var STOP = false;\n    var whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    var anchorPosition = whileCheckResult.anchorPosition;\n    while (!STOP) {\n        scanNext(); // potentially modifies linePos && anchorPosition\n    }\n    function scanNext() {\n        if (debug_1.IN_DEBUG_MODE) {\n            console.log('');\n            console.log('@@scanNext: |' + rule_1.getString(lineText).replace(/\\n$/, '\\\\n').substr(linePos) + '|');\n        }\n        var r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n        if (!r) {\n            if (debug_1.IN_DEBUG_MODE) {\n                console.log('  no more matches.');\n            }\n            // No match\n            lineTokens.produce(stack, lineLength);\n            STOP = true;\n            return;\n        }\n        var captureIndices = r.captureIndices;\n        var matchedRuleId = r.matchedRuleId;\n        var hasAdvanced = (captureIndices && captureIndices.length > 0) ? (captureIndices[0].end > linePos) : false;\n        if (matchedRuleId === -1) {\n            // We matched the `end` for this rule => pop it\n            var poppedRule = stack.getRule(grammar);\n            if (debug_1.IN_DEBUG_MODE) {\n                console.log('  popping ' + poppedRule.debugName + ' - ' + poppedRule.debugEndRegExp);\n            }\n            lineTokens.produce(stack, captureIndices[0].start);\n            stack = stack.setContentNameScopesList(stack.nameScopesList);\n            handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);\n            lineTokens.produce(stack, captureIndices[0].end);\n            // pop\n            var popped = stack;\n            stack = stack.pop();\n            if (!hasAdvanced && popped.getEnterPos() === linePos) {\n                // Grammar pushed & popped a rule without advancing\n                console.error('[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing');\n                // See https://github.com/Microsoft/vscode-textmate/issues/12\n                // Let's assume this was a mistake by the grammar author and the intent was to continue in this state\n                stack = popped;\n                lineTokens.produce(stack, lineLength);\n                STOP = true;\n                return;\n            }\n        }\n        else {\n            // We matched a rule!\n            var _rule = grammar.getRule(matchedRuleId);\n            lineTokens.produce(stack, captureIndices[0].start);\n            var beforePush = stack;\n            // push it on the stack rule\n            var scopeName = _rule.getName(rule_1.getString(lineText), captureIndices);\n            var nameScopesList = stack.contentNameScopesList.push(grammar, scopeName);\n            stack = stack.push(matchedRuleId, linePos, null, nameScopesList, nameScopesList);\n            if (_rule instanceof rule_1.BeginEndRule) {\n                var pushedRule = _rule;\n                if (debug_1.IN_DEBUG_MODE) {\n                    console.log('  pushing ' + pushedRule.debugName + ' - ' + pushedRule.debugBeginRegExp);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                var contentName = pushedRule.getContentName(rule_1.getString(lineText), captureIndices);\n                var contentNameScopesList = nameScopesList.push(grammar, contentName);\n                stack = stack.setContentNameScopesList(contentNameScopesList);\n                if (pushedRule.endHasBackReferences) {\n                    stack = stack.setEndRule(pushedRule.getEndWithResolvedBackReferences(rule_1.getString(lineText), captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    // Grammar pushed the same rule without advancing\n                    console.error('[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing');\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else if (_rule instanceof rule_1.BeginWhileRule) {\n                var pushedRule = _rule;\n                if (debug_1.IN_DEBUG_MODE) {\n                    console.log('  pushing ' + pushedRule.debugName);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                var contentName = pushedRule.getContentName(rule_1.getString(lineText), captureIndices);\n                var contentNameScopesList = nameScopesList.push(grammar, contentName);\n                stack = stack.setContentNameScopesList(contentNameScopesList);\n                if (pushedRule.whileHasBackReferences) {\n                    stack = stack.setEndRule(pushedRule.getWhileWithResolvedBackReferences(rule_1.getString(lineText), captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    // Grammar pushed the same rule without advancing\n                    console.error('[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing');\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else {\n                var matchingRule = _rule;\n                if (debug_1.IN_DEBUG_MODE) {\n                    console.log('  matched ' + matchingRule.debugName + ' - ' + matchingRule.debugMatchRegExp);\n                }\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                // pop rule immediately since it is a MatchRule\n                stack = stack.pop();\n                if (!hasAdvanced) {\n                    // Grammar is not advancing, nor is it pushing/popping\n                    console.error('[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping');\n                    stack = stack.safePop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n        }\n        if (captureIndices[0].end > linePos) {\n            // Advance stream\n            linePos = captureIndices[0].end;\n            isFirstLine = false;\n        }\n    }\n    return stack;\n}\nvar StackElementMetadata = /** @class */ (function () {\n    function StackElementMetadata() {\n    }\n    StackElementMetadata.toBinaryStr = function (metadata) {\n        var r = metadata.toString(2);\n        while (r.length < 32) {\n            r = '0' + r;\n        }\n        return r;\n    };\n    StackElementMetadata.printMetadata = function (metadata) {\n        var languageId = StackElementMetadata.getLanguageId(metadata);\n        var tokenType = StackElementMetadata.getTokenType(metadata);\n        var fontStyle = StackElementMetadata.getFontStyle(metadata);\n        var foreground = StackElementMetadata.getForeground(metadata);\n        var background = StackElementMetadata.getBackground(metadata);\n        console.log({\n            languageId: languageId,\n            tokenType: tokenType,\n            fontStyle: fontStyle,\n            foreground: foreground,\n            background: background,\n        });\n    };\n    StackElementMetadata.getLanguageId = function (metadata) {\n        return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n    };\n    StackElementMetadata.getTokenType = function (metadata) {\n        return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n    };\n    StackElementMetadata.getFontStyle = function (metadata) {\n        return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n    };\n    StackElementMetadata.getForeground = function (metadata) {\n        return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;\n    };\n    StackElementMetadata.getBackground = function (metadata) {\n        return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;\n    };\n    StackElementMetadata.set = function (metadata, languageId, tokenType, fontStyle, foreground, background) {\n        var _languageId = StackElementMetadata.getLanguageId(metadata);\n        var _tokenType = StackElementMetadata.getTokenType(metadata);\n        var _fontStyle = StackElementMetadata.getFontStyle(metadata);\n        var _foreground = StackElementMetadata.getForeground(metadata);\n        var _background = StackElementMetadata.getBackground(metadata);\n        if (languageId !== 0) {\n            _languageId = languageId;\n        }\n        if (tokenType !== 0 /* Other */) {\n            _tokenType = tokenType === 8 /* MetaEmbedded */ ? 0 /* Other */ : tokenType;\n        }\n        if (fontStyle !== -1 /* NotSet */) {\n            _fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            _foreground = foreground;\n        }\n        if (background !== 0) {\n            _background = background;\n        }\n        return ((_languageId << 0 /* LANGUAGEID_OFFSET */)\n            | (_tokenType << 8 /* TOKEN_TYPE_OFFSET */)\n            | (_fontStyle << 11 /* FONT_STYLE_OFFSET */)\n            | (_foreground << 14 /* FOREGROUND_OFFSET */)\n            | (_background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    };\n    return StackElementMetadata;\n}());\nexports.StackElementMetadata = StackElementMetadata;\nvar ScopeListElement = /** @class */ (function () {\n    function ScopeListElement(parent, scope, metadata) {\n        this.parent = parent;\n        this.scope = scope;\n        this.metadata = metadata;\n    }\n    ScopeListElement._equals = function (a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (a.scope !== b.scope || a.metadata !== b.metadata) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n        } while (true);\n    };\n    ScopeListElement.prototype.equals = function (other) {\n        return ScopeListElement._equals(this, other);\n    };\n    ScopeListElement._matchesScope = function (scope, selector, selectorWithDot) {\n        return (selector === scope || scope.substring(0, selectorWithDot.length) === selectorWithDot);\n    };\n    ScopeListElement._matches = function (target, parentScopes) {\n        if (parentScopes === null) {\n            return true;\n        }\n        var len = parentScopes.length;\n        var index = 0;\n        var selector = parentScopes[index];\n        var selectorWithDot = selector + '.';\n        while (target) {\n            if (this._matchesScope(target.scope, selector, selectorWithDot)) {\n                index++;\n                if (index === len) {\n                    return true;\n                }\n                selector = parentScopes[index];\n                selectorWithDot = selector + '.';\n            }\n            target = target.parent;\n        }\n        return false;\n    };\n    ScopeListElement.mergeMetadata = function (metadata, scopesList, source) {\n        if (source === null) {\n            return metadata;\n        }\n        var fontStyle = -1 /* NotSet */;\n        var foreground = 0;\n        var background = 0;\n        if (source.themeData !== null) {\n            // Find the first themeData that matches\n            for (var i = 0, len = source.themeData.length; i < len; i++) {\n                var themeData = source.themeData[i];\n                if (this._matches(scopesList, themeData.parentScopes)) {\n                    fontStyle = themeData.fontStyle;\n                    foreground = themeData.foreground;\n                    background = themeData.background;\n                    break;\n                }\n            }\n        }\n        return StackElementMetadata.set(metadata, source.languageId, source.tokenType, fontStyle, foreground, background);\n    };\n    ScopeListElement._push = function (target, grammar, scopes) {\n        for (var i = 0, len = scopes.length; i < len; i++) {\n            var scope = scopes[i];\n            var rawMetadata = grammar.getMetadataForScope(scope);\n            var metadata = ScopeListElement.mergeMetadata(target.metadata, target, rawMetadata);\n            target = new ScopeListElement(target, scope, metadata);\n        }\n        return target;\n    };\n    ScopeListElement.prototype.push = function (grammar, scope) {\n        if (scope === null) {\n            return this;\n        }\n        if (scope.indexOf(' ') >= 0) {\n            // there are multiple scopes to push\n            return ScopeListElement._push(this, grammar, scope.split(/ /g));\n        }\n        // there is a single scope to push\n        return ScopeListElement._push(this, grammar, [scope]);\n    };\n    ScopeListElement._generateScopes = function (scopesList) {\n        var result = [], resultLen = 0;\n        while (scopesList) {\n            result[resultLen++] = scopesList.scope;\n            scopesList = scopesList.parent;\n        }\n        result.reverse();\n        return result;\n    };\n    ScopeListElement.prototype.generateScopes = function () {\n        return ScopeListElement._generateScopes(this);\n    };\n    return ScopeListElement;\n}());\nexports.ScopeListElement = ScopeListElement;\n/**\n * Represents a \"pushed\" state on the stack (as a linked list element).\n */\nvar StackElement = /** @class */ (function () {\n    function StackElement(parent, ruleId, enterPos, endRule, nameScopesList, contentNameScopesList) {\n        this.parent = parent;\n        this.depth = (this.parent ? this.parent.depth + 1 : 1);\n        this.ruleId = ruleId;\n        this._enterPos = enterPos;\n        this.endRule = endRule;\n        this.nameScopesList = nameScopesList;\n        this.contentNameScopesList = contentNameScopesList;\n    }\n    /**\n     * A structural equals check. Does not take into account `scopes`.\n     */\n    StackElement._structuralEquals = function (a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n        } while (true);\n    };\n    StackElement._equals = function (a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!this._structuralEquals(a, b)) {\n            return false;\n        }\n        return a.contentNameScopesList.equals(b.contentNameScopesList);\n    };\n    StackElement.prototype.clone = function () {\n        return this;\n    };\n    StackElement.prototype.equals = function (other) {\n        if (other === null) {\n            return false;\n        }\n        return StackElement._equals(this, other);\n    };\n    StackElement._reset = function (el) {\n        while (el) {\n            el._enterPos = -1;\n            el = el.parent;\n        }\n    };\n    StackElement.prototype.reset = function () {\n        StackElement._reset(this);\n    };\n    StackElement.prototype.pop = function () {\n        return this.parent;\n    };\n    StackElement.prototype.safePop = function () {\n        if (this.parent) {\n            return this.parent;\n        }\n        return this;\n    };\n    StackElement.prototype.push = function (ruleId, enterPos, endRule, nameScopesList, contentNameScopesList) {\n        return new StackElement(this, ruleId, enterPos, endRule, nameScopesList, contentNameScopesList);\n    };\n    StackElement.prototype.getEnterPos = function () {\n        return this._enterPos;\n    };\n    StackElement.prototype.getRule = function (grammar) {\n        return grammar.getRule(this.ruleId);\n    };\n    StackElement.prototype._writeString = function (res, outIndex) {\n        if (this.parent) {\n            outIndex = this.parent._writeString(res, outIndex);\n        }\n        res[outIndex++] = \"(\" + this.ruleId + \", TODO-\" + this.nameScopesList + \", TODO-\" + this.contentNameScopesList + \")\";\n        return outIndex;\n    };\n    StackElement.prototype.toString = function () {\n        var r = [];\n        this._writeString(r, 0);\n        return '[' + r.join(',') + ']';\n    };\n    StackElement.prototype.setContentNameScopesList = function (contentNameScopesList) {\n        if (this.contentNameScopesList === contentNameScopesList) {\n            return this;\n        }\n        return this.parent.push(this.ruleId, this._enterPos, this.endRule, this.nameScopesList, contentNameScopesList);\n    };\n    StackElement.prototype.setEndRule = function (endRule) {\n        if (this.endRule === endRule) {\n            return this;\n        }\n        return new StackElement(this.parent, this.ruleId, this._enterPos, endRule, this.nameScopesList, this.contentNameScopesList);\n    };\n    StackElement.prototype.hasSameRuleAs = function (other) {\n        return this.ruleId === other.ruleId;\n    };\n    StackElement.NULL = new StackElement(null, 0, 0, null, null, null);\n    return StackElement;\n}());\nexports.StackElement = StackElement;\nvar LocalStackElement = /** @class */ (function () {\n    function LocalStackElement(scopes, endPos) {\n        this.scopes = scopes;\n        this.endPos = endPos;\n    }\n    return LocalStackElement;\n}());\nexports.LocalStackElement = LocalStackElement;\nvar LineTokens = /** @class */ (function () {\n    function LineTokens(emitBinaryTokens, lineText, tokenTypeOverrides) {\n        this._emitBinaryTokens = emitBinaryTokens;\n        this._tokenTypeOverrides = tokenTypeOverrides;\n        if (debug_1.IN_DEBUG_MODE) {\n            this._lineText = lineText;\n        }\n        if (this._emitBinaryTokens) {\n            this._binaryTokens = [];\n        }\n        else {\n            this._tokens = [];\n        }\n        this._lastTokenEndIndex = 0;\n    }\n    LineTokens.prototype.produce = function (stack, endIndex) {\n        this.produceFromScopes(stack.contentNameScopesList, endIndex);\n    };\n    LineTokens.prototype.produceFromScopes = function (scopesList, endIndex) {\n        if (this._lastTokenEndIndex >= endIndex) {\n            return;\n        }\n        if (this._emitBinaryTokens) {\n            var metadata = scopesList.metadata;\n            for (var _i = 0, _a = this._tokenTypeOverrides; _i < _a.length; _i++) {\n                var tokenType = _a[_i];\n                if (tokenType.matcher(scopesList.generateScopes())) {\n                    metadata = StackElementMetadata.set(metadata, 0, toTemporaryType(tokenType.type), -1 /* NotSet */, 0, 0);\n                }\n            }\n            if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n                // no need to push a token with the same metadata\n                this._lastTokenEndIndex = endIndex;\n                return;\n            }\n            this._binaryTokens.push(this._lastTokenEndIndex);\n            this._binaryTokens.push(metadata);\n            this._lastTokenEndIndex = endIndex;\n            return;\n        }\n        var scopes = scopesList.generateScopes();\n        if (debug_1.IN_DEBUG_MODE) {\n            console.log('  token: |' + this._lineText.substring(this._lastTokenEndIndex, endIndex).replace(/\\n$/, '\\\\n') + '|');\n            for (var k = 0; k < scopes.length; k++) {\n                console.log('      * ' + scopes[k]);\n            }\n        }\n        this._tokens.push({\n            startIndex: this._lastTokenEndIndex,\n            endIndex: endIndex,\n            // value: lineText.substring(lastTokenEndIndex, endIndex),\n            scopes: scopes\n        });\n        this._lastTokenEndIndex = endIndex;\n    };\n    LineTokens.prototype.getResult = function (stack, lineLength) {\n        if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n            // pop produced token for newline\n            this._tokens.pop();\n        }\n        if (this._tokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._tokens[this._tokens.length - 1].startIndex = 0;\n        }\n        return this._tokens;\n    };\n    LineTokens.prototype.getBinaryResult = function (stack, lineLength) {\n        if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n            // pop produced token for newline\n            this._binaryTokens.pop();\n            this._binaryTokens.pop();\n        }\n        if (this._binaryTokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._binaryTokens[this._binaryTokens.length - 2] = 0;\n        }\n        var result = new Uint32Array(this._binaryTokens.length);\n        for (var i = 0, len = this._binaryTokens.length; i < len; i++) {\n            result[i] = this._binaryTokens[i];\n        }\n        return result;\n    };\n    return LineTokens;\n}());\nfunction toTemporaryType(standardType) {\n    switch (standardType) {\n        case 4 /* RegEx */:\n            return 4 /* RegEx */;\n        case 2 /* String */:\n            return 2 /* String */;\n        case 1 /* Comment */:\n            return 1 /* Comment */;\n        case 0 /* Other */:\n        default:\n            // `MetaEmbedded` is the same scope as `Other`\n            // but it overwrites existing token types in the stack.\n            return 8 /* MetaEmbedded */;\n    }\n}\n//# sourceMappingURL=grammar.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar plist = require(\"fast-plist\");\nvar debug_1 = require(\"./debug\");\nvar json_1 = require(\"./json\");\nfunction parseJSONGrammar(contents, filename) {\n    if (debug_1.CAPTURE_METADATA) {\n        return json_1.parse(contents, filename, true);\n    }\n    return JSON.parse(contents);\n}\nexports.parseJSONGrammar = parseJSONGrammar;\nfunction parsePLISTGrammar(contents, filename) {\n    if (debug_1.CAPTURE_METADATA) {\n        return plist.parseWithLocation(contents, filename, '$vscodeTextmateLocation');\n    }\n    return plist.parse(contents);\n}\nexports.parsePLISTGrammar = parsePLISTGrammar;\n//# sourceMappingURL=grammarReader.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction doFail(streamState, msg) {\n    // console.log('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n    throw new Error('Near offset ' + streamState.pos + ': ' + msg + ' ~~~' + streamState.source.substr(streamState.pos, 50) + '~~~');\n}\nfunction parse(source, filename, withMetadata) {\n    var streamState = new JSONStreamState(source);\n    var token = new JSONToken();\n    var state = 0 /* ROOT_STATE */;\n    var cur = null;\n    var stateStack = [];\n    var objStack = [];\n    function pushState() {\n        stateStack.push(state);\n        objStack.push(cur);\n    }\n    function popState() {\n        state = stateStack.pop();\n        cur = objStack.pop();\n    }\n    function fail(msg) {\n        doFail(streamState, msg);\n    }\n    while (nextJSONToken(streamState, token)) {\n        if (state === 0 /* ROOT_STATE */) {\n            if (cur !== null) {\n                fail('too many constructs in root');\n            }\n            if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                cur = {};\n                if (withMetadata) {\n                    cur.$vscodeTextmateLocation = token.toLocation(filename);\n                }\n                pushState();\n                state = 1 /* DICT_STATE */;\n                continue;\n            }\n            if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                cur = [];\n                pushState();\n                state = 4 /* ARR_STATE */;\n                continue;\n            }\n            fail('unexpected token in root');\n        }\n        if (state === 2 /* DICT_STATE_COMMA */) {\n            if (token.type === 5 /* RIGHT_CURLY_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 7 /* COMMA */) {\n                state = 3 /* DICT_STATE_NO_CLOSE */;\n                continue;\n            }\n            fail('expected , or }');\n        }\n        if (state === 1 /* DICT_STATE */ || state === 3 /* DICT_STATE_NO_CLOSE */) {\n            if (state === 1 /* DICT_STATE */ && token.type === 5 /* RIGHT_CURLY_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 1 /* STRING */) {\n                var keyValue = token.value;\n                if (!nextJSONToken(streamState, token) || token.type !== 6 /* COLON */) {\n                    fail('expected colon');\n                }\n                if (!nextJSONToken(streamState, token)) {\n                    fail('expected value');\n                }\n                state = 2 /* DICT_STATE_COMMA */;\n                if (token.type === 1 /* STRING */) {\n                    cur[keyValue] = token.value;\n                    continue;\n                }\n                if (token.type === 8 /* NULL */) {\n                    cur[keyValue] = null;\n                    continue;\n                }\n                if (token.type === 9 /* TRUE */) {\n                    cur[keyValue] = true;\n                    continue;\n                }\n                if (token.type === 10 /* FALSE */) {\n                    cur[keyValue] = false;\n                    continue;\n                }\n                if (token.type === 11 /* NUMBER */) {\n                    cur[keyValue] = parseFloat(token.value);\n                    continue;\n                }\n                if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                    var newArr = [];\n                    cur[keyValue] = newArr;\n                    pushState();\n                    state = 4 /* ARR_STATE */;\n                    cur = newArr;\n                    continue;\n                }\n                if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                    var newDict = {};\n                    if (withMetadata) {\n                        newDict.$vscodeTextmateLocation = token.toLocation(filename);\n                    }\n                    cur[keyValue] = newDict;\n                    pushState();\n                    state = 1 /* DICT_STATE */;\n                    cur = newDict;\n                    continue;\n                }\n            }\n            fail('unexpected token in dict');\n        }\n        if (state === 5 /* ARR_STATE_COMMA */) {\n            if (token.type === 4 /* RIGHT_SQUARE_BRACKET */) {\n                popState();\n                continue;\n            }\n            if (token.type === 7 /* COMMA */) {\n                state = 6 /* ARR_STATE_NO_CLOSE */;\n                continue;\n            }\n            fail('expected , or ]');\n        }\n        if (state === 4 /* ARR_STATE */ || state === 6 /* ARR_STATE_NO_CLOSE */) {\n            if (state === 4 /* ARR_STATE */ && token.type === 4 /* RIGHT_SQUARE_BRACKET */) {\n                popState();\n                continue;\n            }\n            state = 5 /* ARR_STATE_COMMA */;\n            if (token.type === 1 /* STRING */) {\n                cur.push(token.value);\n                continue;\n            }\n            if (token.type === 8 /* NULL */) {\n                cur.push(null);\n                continue;\n            }\n            if (token.type === 9 /* TRUE */) {\n                cur.push(true);\n                continue;\n            }\n            if (token.type === 10 /* FALSE */) {\n                cur.push(false);\n                continue;\n            }\n            if (token.type === 11 /* NUMBER */) {\n                cur.push(parseFloat(token.value));\n                continue;\n            }\n            if (token.type === 2 /* LEFT_SQUARE_BRACKET */) {\n                var newArr = [];\n                cur.push(newArr);\n                pushState();\n                state = 4 /* ARR_STATE */;\n                cur = newArr;\n                continue;\n            }\n            if (token.type === 3 /* LEFT_CURLY_BRACKET */) {\n                var newDict = {};\n                if (withMetadata) {\n                    newDict.$vscodeTextmateLocation = token.toLocation(filename);\n                }\n                cur.push(newDict);\n                pushState();\n                state = 1 /* DICT_STATE */;\n                cur = newDict;\n                continue;\n            }\n            fail('unexpected token in array');\n        }\n        fail('unknown state');\n    }\n    if (objStack.length !== 0) {\n        fail('unclosed constructs');\n    }\n    return cur;\n}\nexports.parse = parse;\nvar JSONStreamState = /** @class */ (function () {\n    function JSONStreamState(source) {\n        this.source = source;\n        this.pos = 0;\n        this.len = source.length;\n        this.line = 1;\n        this.char = 0;\n    }\n    return JSONStreamState;\n}());\nvar JSONToken = /** @class */ (function () {\n    function JSONToken() {\n        this.value = null;\n        this.offset = -1;\n        this.len = -1;\n        this.line = -1;\n        this.char = -1;\n    }\n    JSONToken.prototype.toLocation = function (filename) {\n        return {\n            filename: filename,\n            line: this.line,\n            char: this.char\n        };\n    };\n    return JSONToken;\n}());\n/**\n * precondition: the string is known to be valid JSON (https://www.ietf.org/rfc/rfc4627.txt)\n */\nfunction nextJSONToken(_state, _out) {\n    _out.value = null;\n    _out.type = 0 /* UNKNOWN */;\n    _out.offset = -1;\n    _out.len = -1;\n    _out.line = -1;\n    _out.char = -1;\n    var source = _state.source;\n    var pos = _state.pos;\n    var len = _state.len;\n    var line = _state.line;\n    var char = _state.char;\n    //------------------------ skip whitespace\n    var chCode;\n    do {\n        if (pos >= len) {\n            return false; /*EOS*/\n        }\n        chCode = source.charCodeAt(pos);\n        if (chCode === 32 /* SPACE */ || chCode === 9 /* HORIZONTAL_TAB */ || chCode === 13 /* CARRIAGE_RETURN */) {\n            // regular whitespace\n            pos++;\n            char++;\n            continue;\n        }\n        if (chCode === 10 /* LINE_FEED */) {\n            // newline\n            pos++;\n            line++;\n            char = 0;\n            continue;\n        }\n        // not whitespace\n        break;\n    } while (true);\n    _out.offset = pos;\n    _out.line = line;\n    _out.char = char;\n    if (chCode === 34 /* QUOTATION_MARK */) {\n        //------------------------ strings\n        _out.type = 1 /* STRING */;\n        pos++;\n        char++;\n        do {\n            if (pos >= len) {\n                return false; /*EOS*/\n            }\n            chCode = source.charCodeAt(pos);\n            pos++;\n            char++;\n            if (chCode === 92 /* BACKSLASH */) {\n                // skip next char\n                pos++;\n                char++;\n                continue;\n            }\n            if (chCode === 34 /* QUOTATION_MARK */) {\n                // end of the string\n                break;\n            }\n        } while (true);\n        _out.value = source.substring(_out.offset + 1, pos - 1).replace(/\\\\u([0-9A-Fa-f]{4})/g, function (_, m0) {\n            return String.fromCodePoint(parseInt(m0, 16));\n        }).replace(/\\\\(.)/g, function (_, m0) {\n            switch (m0) {\n                case '\"': return '\"';\n                case '\\\\': return '\\\\';\n                case '/': return '/';\n                case 'b': return '\\b';\n                case 'f': return '\\f';\n                case 'n': return '\\n';\n                case 'r': return '\\r';\n                case 't': return '\\t';\n                default: doFail(_state, 'invalid escape sequence');\n            }\n        });\n    }\n    else if (chCode === 91 /* LEFT_SQUARE_BRACKET */) {\n        _out.type = 2 /* LEFT_SQUARE_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 123 /* LEFT_CURLY_BRACKET */) {\n        _out.type = 3 /* LEFT_CURLY_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 93 /* RIGHT_SQUARE_BRACKET */) {\n        _out.type = 4 /* RIGHT_SQUARE_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 125 /* RIGHT_CURLY_BRACKET */) {\n        _out.type = 5 /* RIGHT_CURLY_BRACKET */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 58 /* COLON */) {\n        _out.type = 6 /* COLON */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 44 /* COMMA */) {\n        _out.type = 7 /* COMMA */;\n        pos++;\n        char++;\n    }\n    else if (chCode === 110 /* n */) {\n        //------------------------ null\n        _out.type = 8 /* NULL */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 117 /* u */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else if (chCode === 116 /* t */) {\n        //------------------------ true\n        _out.type = 9 /* TRUE */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 114 /* r */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 117 /* u */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 101 /* e */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else if (chCode === 102 /* f */) {\n        //------------------------ false\n        _out.type = 10 /* FALSE */;\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 97 /* a */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 108 /* l */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 115 /* s */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n        chCode = source.charCodeAt(pos);\n        if (chCode !== 101 /* e */) {\n            return false; /* INVALID */\n        }\n        pos++;\n        char++;\n    }\n    else {\n        //------------------------ numbers\n        _out.type = 11 /* NUMBER */;\n        do {\n            if (pos >= len) {\n                return false; /*EOS*/\n            }\n            chCode = source.charCodeAt(pos);\n            if (chCode === 46 /* DOT */\n                || (chCode >= 48 /* D0 */ && chCode <= 57 /* D9 */)\n                || (chCode === 101 /* e */ || chCode === 69 /* E */)\n                || (chCode === 45 /* MINUS */ || chCode === 43 /* PLUS */)) {\n                // looks like a piece of a number\n                pos++;\n                char++;\n                continue;\n            }\n            // pos--; char--;\n            break;\n        } while (true);\n    }\n    _out.len = pos - _out.offset;\n    if (_out.value === null) {\n        _out.value = source.substr(_out.offset, _out.len);\n    }\n    _state.pos = pos;\n    _state.line = line;\n    _state.char = char;\n    // console.log('PRODUCING TOKEN: ', _out.value, JSONTokenType[_out.type]);\n    return true;\n}\n//# sourceMappingURL=json.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar registry_1 = require(\"./registry\");\nvar grammarReader_1 = require(\"./grammarReader\");\nvar theme_1 = require(\"./theme\");\nvar grammar_1 = require(\"./grammar\");\nvar DEFAULT_OPTIONS = {\n    getGrammarDefinition: function (scopeName) { return null; },\n    getInjections: function (scopeName) { return null; }\n};\n/**\n * The registry that will hold all grammars.\n */\nvar Registry = /** @class */ (function () {\n    function Registry(locator) {\n        if (locator === void 0) { locator = DEFAULT_OPTIONS; }\n        this._locator = locator;\n        this._syncRegistry = new registry_1.SyncRegistry(theme_1.Theme.createFromRawTheme(locator.theme));\n        this.installationQueue = new Map();\n    }\n    /**\n     * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n     */\n    Registry.prototype.setTheme = function (theme) {\n        this._syncRegistry.setTheme(theme_1.Theme.createFromRawTheme(theme));\n    };\n    /**\n     * Returns a lookup array for color ids.\n     */\n    Registry.prototype.getColorMap = function () {\n        return this._syncRegistry.getColorMap();\n    };\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    Registry.prototype.loadGrammarWithEmbeddedLanguages = function (initialScopeName, initialLanguage, embeddedLanguages) {\n        return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages: embeddedLanguages });\n    };\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    Registry.prototype.loadGrammarWithConfiguration = function (initialScopeName, initialLanguage, configuration) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._loadGrammar(initialScopeName)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.grammarForScopeName(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes)];\n                }\n            });\n        });\n    };\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     */\n    Registry.prototype.loadGrammar = function (initialScopeName) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._loadGrammar(initialScopeName)];\n            });\n        });\n    };\n    Registry.prototype._loadGrammar = function (initialScopeName, dependentScope) {\n        if (dependentScope === void 0) { dependentScope = null; }\n        return __awaiter(this, void 0, void 0, function () {\n            var prom;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // already installed\n                        if (this._syncRegistry.lookup(initialScopeName)) {\n                            return [2 /*return*/, this.grammarForScopeName(initialScopeName)];\n                        }\n                        // installation in progress\n                        if (this.installationQueue.has(initialScopeName)) {\n                            return [2 /*return*/, this.installationQueue.get(initialScopeName)];\n                        }\n                        prom = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\n                            var grammarDefinition, rawGrammar, injections, deps;\n                            var _this = this;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this._locator.getGrammarDefinition(initialScopeName, dependentScope)];\n                                    case 1:\n                                        grammarDefinition = _a.sent();\n                                        if (!grammarDefinition) {\n                                            throw new Error(\"A tmGrammar load was requested but registry host failed to provide grammar definition\");\n                                        }\n                                        if ((grammarDefinition.format !== 'json' && grammarDefinition.format !== 'plist') ||\n                                            (grammarDefinition.format === 'json' && typeof grammarDefinition.content !== 'object' && typeof grammarDefinition.content !== 'string') ||\n                                            (grammarDefinition.format === 'plist' && typeof grammarDefinition.content !== 'string')) {\n                                            throw new TypeError('Grammar definition must be an object, either `{ content: string | object, format: \"json\" }` OR `{ content: string, format: \"plist\" }`)');\n                                        }\n                                        rawGrammar = grammarDefinition.format === 'json'\n                                            ? typeof grammarDefinition.content === 'string'\n                                                ? grammarReader_1.parseJSONGrammar(grammarDefinition.content, 'c://fakepath/grammar.json')\n                                                : grammarDefinition.content\n                                            : grammarReader_1.parsePLISTGrammar(grammarDefinition.content, 'c://fakepath/grammar.plist');\n                                        injections = (typeof this._locator.getInjections === 'function') && this._locator.getInjections(initialScopeName);\n                                        rawGrammar.scopeName = initialScopeName;\n                                        deps = this._syncRegistry.addGrammar(rawGrammar, injections);\n                                        return [4 /*yield*/, Promise.all(deps.map(function (scopeNameD) { return __awaiter(_this, void 0, void 0, function () {\n                                                return __generator(this, function (_a) {\n                                                    try {\n                                                        return [2 /*return*/, this._loadGrammar(scopeNameD, initialScopeName)];\n                                                    }\n                                                    catch (error) {\n                                                        throw new Error(\"While trying to load tmGrammar with scopeId: '\" + initialScopeName + \"', it's dependency (scopeId: \" + scopeNameD + \") loading errored: \" + error.message);\n                                                    }\n                                                    return [2 /*return*/];\n                                                });\n                                            }); }))];\n                                    case 2:\n                                        _a.sent();\n                                        resolve(this.grammarForScopeName(initialScopeName));\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                        this.installationQueue.set(initialScopeName, prom);\n                        return [4 /*yield*/, prom];\n                    case 1:\n                        _a.sent();\n                        this.installationQueue.delete(initialScopeName);\n                        return [2 /*return*/, prom];\n                }\n            });\n        });\n    };\n    /**\n     * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `loadGrammarFromPathSync`.\n     */\n    Registry.prototype.grammarForScopeName = function (scopeName, initialLanguage, embeddedLanguages, tokenTypes) {\n        if (initialLanguage === void 0) { initialLanguage = 0; }\n        if (embeddedLanguages === void 0) { embeddedLanguages = null; }\n        if (tokenTypes === void 0) { tokenTypes = null; }\n        return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes);\n    };\n    return Registry;\n}());\nexports.Registry = Registry;\nexports.INITIAL = grammar_1.StackElement.NULL;\n//# sourceMappingURL=main.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createMatchers(selector, matchesName) {\n    var results = [];\n    var tokenizer = newTokenizer(selector);\n    var token = tokenizer.next();\n    while (token !== null) {\n        var priority = 0;\n        if (token.length === 2 && token.charAt(1) === ':') {\n            switch (token.charAt(0)) {\n                case 'R':\n                    priority = 1;\n                    break;\n                case 'L':\n                    priority = -1;\n                    break;\n                default:\n                    console.log(\"Unknown priority \" + token + \" in scope selector\");\n            }\n            token = tokenizer.next();\n        }\n        var matcher = parseConjunction();\n        if (matcher) {\n            results.push({ matcher: matcher, priority: priority });\n        }\n        if (token !== ',') {\n            break;\n        }\n        token = tokenizer.next();\n    }\n    return results;\n    function parseOperand() {\n        if (token === '-') {\n            token = tokenizer.next();\n            var expressionToNegate = parseOperand();\n            return function (matcherInput) { return expressionToNegate && !expressionToNegate(matcherInput); };\n        }\n        if (token === '(') {\n            token = tokenizer.next();\n            var expressionInParents = parseInnerExpression();\n            if (token === ')') {\n                token = tokenizer.next();\n            }\n            return expressionInParents;\n        }\n        if (isIdentifier(token)) {\n            var identifiers = [];\n            do {\n                identifiers.push(token);\n                token = tokenizer.next();\n            } while (isIdentifier(token));\n            return function (matcherInput) { return matchesName(identifiers, matcherInput); };\n        }\n        return null;\n    }\n    function parseConjunction() {\n        var matchers = [];\n        var matcher = parseOperand();\n        while (matcher) {\n            matchers.push(matcher);\n            matcher = parseOperand();\n        }\n        return function (matcherInput) { return matchers.every(function (matcher) { return matcher(matcherInput); }); }; // and\n    }\n    function parseInnerExpression() {\n        var matchers = [];\n        var matcher = parseConjunction();\n        while (matcher) {\n            matchers.push(matcher);\n            if (token === '|' || token === ',') {\n                do {\n                    token = tokenizer.next();\n                } while (token === '|' || token === ','); // ignore subsequent commas\n            }\n            else {\n                break;\n            }\n            matcher = parseConjunction();\n        }\n        return function (matcherInput) { return matchers.some(function (matcher) { return matcher(matcherInput); }); }; // or\n    }\n}\nexports.createMatchers = createMatchers;\nfunction isIdentifier(token) {\n    return token && token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n    var regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n    var match = regex.exec(input);\n    return {\n        next: function () {\n            if (!match) {\n                return null;\n            }\n            var res = match[0];\n            match = regex.exec(input);\n            return res;\n        }\n    };\n}\n//# sourceMappingURL=matcher.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar grammar_1 = require(\"./grammar\");\nvar SyncRegistry = /** @class */ (function () {\n    function SyncRegistry(theme) {\n        this._theme = theme;\n        this._grammars = {};\n        this._rawGrammars = {};\n        this._injectionGrammars = {};\n    }\n    SyncRegistry.prototype.setTheme = function (theme) {\n        var _this = this;\n        this._theme = theme;\n        Object.keys(this._grammars).forEach(function (scopeName) {\n            var grammar = _this._grammars[scopeName];\n            grammar.onDidChangeTheme();\n        });\n    };\n    SyncRegistry.prototype.getColorMap = function () {\n        return this._theme.getColorMap();\n    };\n    /**\n     * Add `grammar` to registry and return a list of referenced scope names\n     */\n    SyncRegistry.prototype.addGrammar = function (grammar, injectionScopeNames) {\n        this._rawGrammars[grammar.scopeName] = grammar;\n        var includedScopes = {};\n        grammar_1.collectIncludedScopes(includedScopes, grammar);\n        if (injectionScopeNames) {\n            this._injectionGrammars[grammar.scopeName] = injectionScopeNames;\n            injectionScopeNames.forEach(function (scopeName) {\n                includedScopes[scopeName] = true;\n            });\n        }\n        return Object.keys(includedScopes);\n    };\n    /**\n     * Lookup a raw grammar.\n     */\n    SyncRegistry.prototype.lookup = function (scopeName) {\n        return this._rawGrammars[scopeName];\n    };\n    /**\n     * Returns the injections for the given grammar\n     */\n    SyncRegistry.prototype.injections = function (targetScope) {\n        return this._injectionGrammars[targetScope];\n    };\n    /**\n     * Get the default theme settings\n     */\n    SyncRegistry.prototype.getDefaults = function () {\n        return this._theme.getDefaults();\n    };\n    /**\n     * Match a scope in the theme.\n     */\n    SyncRegistry.prototype.themeMatch = function (scopeName) {\n        return this._theme.match(scopeName);\n    };\n    /**\n     * Lookup a grammar.\n     */\n    SyncRegistry.prototype.grammarForScopeName = function (scopeName, initialLanguage, embeddedLanguages, tokenTypes) {\n        if (!this._grammars[scopeName]) {\n            var rawGrammar = this._rawGrammars[scopeName];\n            if (!rawGrammar) {\n                return null;\n            }\n            this._grammars[scopeName] = grammar_1.createGrammar(rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, this);\n        }\n        return this._grammars[scopeName];\n    };\n    return SyncRegistry;\n}());\nexports.SyncRegistry = SyncRegistry;\n//# sourceMappingURL=registry.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = require(\"path\");\nvar utils_1 = require(\"./utils\");\nvar onigasm_1 = require(\"onigasm\");\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar Rule = /** @class */ (function () {\n    function Rule($location, id, name, contentName) {\n        this.$location = $location;\n        this.id = id;\n        this._name = name || null;\n        this._nameIsCapturing = utils_1.RegexSource.hasCaptures(this._name);\n        this._contentName = contentName || null;\n        this._contentNameIsCapturing = utils_1.RegexSource.hasCaptures(this._contentName);\n    }\n    Object.defineProperty(Rule.prototype, \"debugName\", {\n        get: function () {\n            return this.constructor.name + \"#\" + this.id + \" @ \" + path.basename(this.$location.filename) + \":\" + this.$location.line;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Rule.prototype.getName = function (lineText, captureIndices) {\n        if (!this._nameIsCapturing) {\n            return this._name;\n        }\n        return utils_1.RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n    };\n    Rule.prototype.getContentName = function (lineText, captureIndices) {\n        if (!this._contentNameIsCapturing) {\n            return this._contentName;\n        }\n        return utils_1.RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n    };\n    Rule.prototype.collectPatternsRecursive = function (grammar, out, isFirst) {\n        throw new Error('Implement me!');\n    };\n    Rule.prototype.compile = function (grammar, endRegexSource, allowA, allowG) {\n        throw new Error('Implement me!');\n    };\n    return Rule;\n}());\nexports.Rule = Rule;\nvar CaptureRule = /** @class */ (function (_super) {\n    __extends(CaptureRule, _super);\n    function CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n        var _this = _super.call(this, $location, id, name, contentName) || this;\n        _this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n        return _this;\n    }\n    return CaptureRule;\n}(Rule));\nexports.CaptureRule = CaptureRule;\nvar RegExpSource = /** @class */ (function () {\n    function RegExpSource(regExpSource, ruleId, handleAnchors) {\n        if (handleAnchors === void 0) { handleAnchors = true; }\n        if (handleAnchors) {\n            this._handleAnchors(regExpSource);\n        }\n        else {\n            this.source = regExpSource;\n            this.hasAnchor = false;\n        }\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n        this.ruleId = ruleId;\n        this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n        // console.log('input: ' + regExpSource + ' => ' + this.source + ', ' + this.hasAnchor);\n    }\n    RegExpSource.prototype.clone = function () {\n        return new RegExpSource(this.source, this.ruleId, true);\n    };\n    RegExpSource.prototype.setSource = function (newSource) {\n        if (this.source === newSource) {\n            return;\n        }\n        this.source = newSource;\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n    };\n    RegExpSource.prototype._handleAnchors = function (regExpSource) {\n        if (regExpSource) {\n            var pos = void 0, len = void 0, ch = void 0, nextCh = void 0, lastPushedPos = 0, output = [];\n            var hasAnchor = false;\n            for (pos = 0, len = regExpSource.length; pos < len; pos++) {\n                ch = regExpSource.charAt(pos);\n                if (ch === '\\\\') {\n                    if (pos + 1 < len) {\n                        nextCh = regExpSource.charAt(pos + 1);\n                        if (nextCh === 'z') {\n                            output.push(regExpSource.substring(lastPushedPos, pos));\n                            output.push('$(?!\\\\n)(?<!\\\\n)');\n                            lastPushedPos = pos + 2;\n                        }\n                        else if (nextCh === 'A' || nextCh === 'G') {\n                            hasAnchor = true;\n                        }\n                        pos++;\n                    }\n                }\n            }\n            this.hasAnchor = hasAnchor;\n            if (lastPushedPos === 0) {\n                // No \\z hit\n                this.source = regExpSource;\n            }\n            else {\n                output.push(regExpSource.substring(lastPushedPos, len));\n                this.source = output.join('');\n            }\n        }\n        else {\n            this.hasAnchor = false;\n            this.source = regExpSource;\n        }\n    };\n    RegExpSource.prototype.resolveBackReferences = function (lineText, captureIndices) {\n        var capturedValues = captureIndices.map(function (capture) {\n            return lineText.substring(capture.start, capture.end);\n        });\n        BACK_REFERENCING_END.lastIndex = 0;\n        return this.source.replace(BACK_REFERENCING_END, function (match, g1) {\n            return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || '');\n        });\n    };\n    RegExpSource.prototype._buildAnchorCache = function () {\n        var A0_G0_result = [];\n        var A0_G1_result = [];\n        var A1_G0_result = [];\n        var A1_G1_result = [];\n        var pos, len, ch, nextCh;\n        for (pos = 0, len = this.source.length; pos < len; pos++) {\n            ch = this.source.charAt(pos);\n            A0_G0_result[pos] = ch;\n            A0_G1_result[pos] = ch;\n            A1_G0_result[pos] = ch;\n            A1_G1_result[pos] = ch;\n            if (ch === '\\\\') {\n                if (pos + 1 < len) {\n                    nextCh = this.source.charAt(pos + 1);\n                    if (nextCh === 'A') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = '\\uFFFF';\n                        A1_G0_result[pos + 1] = 'A';\n                        A1_G1_result[pos + 1] = 'A';\n                    }\n                    else if (nextCh === 'G') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = 'G';\n                        A1_G0_result[pos + 1] = '\\uFFFF';\n                        A1_G1_result[pos + 1] = 'G';\n                    }\n                    else {\n                        A0_G0_result[pos + 1] = nextCh;\n                        A0_G1_result[pos + 1] = nextCh;\n                        A1_G0_result[pos + 1] = nextCh;\n                        A1_G1_result[pos + 1] = nextCh;\n                    }\n                    pos++;\n                }\n            }\n        }\n        return {\n            A0_G0: A0_G0_result.join(''),\n            A0_G1: A0_G1_result.join(''),\n            A1_G0: A1_G0_result.join(''),\n            A1_G1: A1_G1_result.join('')\n        };\n    };\n    RegExpSource.prototype.resolveAnchors = function (allowA, allowG) {\n        if (!this.hasAnchor) {\n            return this.source;\n        }\n        if (allowA) {\n            if (allowG) {\n                return this._anchorCache.A1_G1;\n            }\n            else {\n                return this._anchorCache.A1_G0;\n            }\n        }\n        else {\n            if (allowG) {\n                return this._anchorCache.A0_G1;\n            }\n            else {\n                return this._anchorCache.A0_G0;\n            }\n        }\n    };\n    return RegExpSource;\n}());\nexports.RegExpSource = RegExpSource;\nfunction createOnigScanner(sources) {\n    return new onigasm_1.OnigScanner(sources);\n}\nfunction createOnigString(sources) {\n    var r = new onigasm_1.OnigString(sources);\n    r.$str = sources;\n    return r;\n}\nexports.createOnigString = createOnigString;\nfunction getString(str) {\n    return str.$str;\n}\nexports.getString = getString;\nvar RegExpSourceList = /** @class */ (function () {\n    function RegExpSourceList() {\n        this._items = [];\n        this._hasAnchors = false;\n        this._cached = null;\n        this._cachedSources = null;\n        this._anchorCache = {\n            A0_G0: null,\n            A0_G1: null,\n            A1_G0: null,\n            A1_G1: null\n        };\n    }\n    RegExpSourceList.prototype.push = function (item) {\n        this._items.push(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    };\n    RegExpSourceList.prototype.unshift = function (item) {\n        this._items.unshift(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    };\n    RegExpSourceList.prototype.length = function () {\n        return this._items.length;\n    };\n    RegExpSourceList.prototype.setSource = function (index, newSource) {\n        if (this._items[index].source !== newSource) {\n            // bust the cache\n            this._cached = null;\n            this._anchorCache.A0_G0 = null;\n            this._anchorCache.A0_G1 = null;\n            this._anchorCache.A1_G0 = null;\n            this._anchorCache.A1_G1 = null;\n            this._items[index].setSource(newSource);\n        }\n    };\n    RegExpSourceList.prototype.compile = function (grammar, allowA, allowG) {\n        if (!this._hasAnchors) {\n            if (!this._cached) {\n                var regExps = this._items.map(function (e) { return e.source; });\n                this._cached = {\n                    scanner: createOnigScanner(regExps),\n                    rules: this._items.map(function (e) { return e.ruleId; }),\n                    debugRegExps: regExps\n                };\n            }\n            return this._cached;\n        }\n        else {\n            this._anchorCache = {\n                A0_G0: this._anchorCache.A0_G0 || (allowA === false && allowG === false ? this._resolveAnchors(allowA, allowG) : null),\n                A0_G1: this._anchorCache.A0_G1 || (allowA === false && allowG === true ? this._resolveAnchors(allowA, allowG) : null),\n                A1_G0: this._anchorCache.A1_G0 || (allowA === true && allowG === false ? this._resolveAnchors(allowA, allowG) : null),\n                A1_G1: this._anchorCache.A1_G1 || (allowA === true && allowG === true ? this._resolveAnchors(allowA, allowG) : null),\n            };\n            if (allowA) {\n                if (allowG) {\n                    return this._anchorCache.A1_G1;\n                }\n                else {\n                    return this._anchorCache.A1_G0;\n                }\n            }\n            else {\n                if (allowG) {\n                    return this._anchorCache.A0_G1;\n                }\n                else {\n                    return this._anchorCache.A0_G0;\n                }\n            }\n        }\n    };\n    RegExpSourceList.prototype._resolveAnchors = function (allowA, allowG) {\n        var regExps = this._items.map(function (e) { return e.resolveAnchors(allowA, allowG); });\n        return {\n            scanner: createOnigScanner(regExps),\n            rules: this._items.map(function (e) { return e.ruleId; }),\n            debugRegExps: regExps\n        };\n    };\n    return RegExpSourceList;\n}());\nexports.RegExpSourceList = RegExpSourceList;\nvar MatchRule = /** @class */ (function (_super) {\n    __extends(MatchRule, _super);\n    function MatchRule($location, id, name, match, captures) {\n        var _this = _super.call(this, $location, id, name, null) || this;\n        _this._match = new RegExpSource(match, _this.id);\n        _this.captures = captures;\n        _this._cachedCompiledPatterns = null;\n        return _this;\n    }\n    Object.defineProperty(MatchRule.prototype, \"debugMatchRegExp\", {\n        get: function () {\n            return \"\" + this._match.source;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MatchRule.prototype.collectPatternsRecursive = function (grammar, out, isFirst) {\n        out.push(this._match);\n    };\n    MatchRule.prototype.compile = function (grammar, endRegexSource, allowA, allowG) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n        }\n        return this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n    };\n    return MatchRule;\n}(Rule));\nexports.MatchRule = MatchRule;\nvar IncludeOnlyRule = /** @class */ (function (_super) {\n    __extends(IncludeOnlyRule, _super);\n    function IncludeOnlyRule($location, id, name, contentName, patterns) {\n        var _this = _super.call(this, $location, id, name, contentName) || this;\n        _this.patterns = patterns.patterns;\n        _this.hasMissingPatterns = patterns.hasMissingPatterns;\n        _this._cachedCompiledPatterns = null;\n        return _this;\n    }\n    IncludeOnlyRule.prototype.collectPatternsRecursive = function (grammar, out, isFirst) {\n        var i, len, rule;\n        for (i = 0, len = this.patterns.length; i < len; i++) {\n            rule = grammar.getRule(this.patterns[i]);\n            rule.collectPatternsRecursive(grammar, out, false);\n        }\n    };\n    IncludeOnlyRule.prototype.compile = function (grammar, endRegexSource, allowA, allowG) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n        }\n        return this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n    };\n    return IncludeOnlyRule;\n}(Rule));\nexports.IncludeOnlyRule = IncludeOnlyRule;\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n}\nvar BeginEndRule = /** @class */ (function (_super) {\n    __extends(BeginEndRule, _super);\n    function BeginEndRule($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n        var _this = _super.call(this, $location, id, name, contentName) || this;\n        _this._begin = new RegExpSource(begin, _this.id);\n        _this.beginCaptures = beginCaptures;\n        _this._end = new RegExpSource(end, -1);\n        _this.endHasBackReferences = _this._end.hasBackReferences;\n        _this.endCaptures = endCaptures;\n        _this.applyEndPatternLast = applyEndPatternLast || false;\n        _this.patterns = patterns.patterns;\n        _this.hasMissingPatterns = patterns.hasMissingPatterns;\n        _this._cachedCompiledPatterns = null;\n        return _this;\n    }\n    Object.defineProperty(BeginEndRule.prototype, \"debugBeginRegExp\", {\n        get: function () {\n            return \"\" + this._begin.source;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BeginEndRule.prototype, \"debugEndRegExp\", {\n        get: function () {\n            return \"\" + this._end.source;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BeginEndRule.prototype.getEndWithResolvedBackReferences = function (lineText, captureIndices) {\n        return this._end.resolveBackReferences(lineText, captureIndices);\n    };\n    BeginEndRule.prototype.collectPatternsRecursive = function (grammar, out, isFirst) {\n        if (isFirst) {\n            var i = void 0, len = void 0, rule = void 0;\n            for (i = 0, len = this.patterns.length; i < len; i++) {\n                rule = grammar.getRule(this.patterns[i]);\n                rule.collectPatternsRecursive(grammar, out, false);\n            }\n        }\n        else {\n            out.push(this._begin);\n        }\n    };\n    BeginEndRule.prototype.compile = function (grammar, endRegexSource, allowA, allowG) {\n        var precompiled = this._precompile(grammar);\n        if (this._end.hasBackReferences) {\n            if (this.applyEndPatternLast) {\n                precompiled.setSource(precompiled.length() - 1, endRegexSource);\n            }\n            else {\n                precompiled.setSource(0, endRegexSource);\n            }\n        }\n        return this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n    };\n    BeginEndRule.prototype._precompile = function (grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n            if (this.applyEndPatternLast) {\n                this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n            else {\n                this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n        }\n        return this._cachedCompiledPatterns;\n    };\n    return BeginEndRule;\n}(Rule));\nexports.BeginEndRule = BeginEndRule;\nvar BeginWhileRule = /** @class */ (function (_super) {\n    __extends(BeginWhileRule, _super);\n    function BeginWhileRule($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n        var _this = _super.call(this, $location, id, name, contentName) || this;\n        _this._begin = new RegExpSource(begin, _this.id);\n        _this.beginCaptures = beginCaptures;\n        _this.whileCaptures = whileCaptures;\n        _this._while = new RegExpSource(_while, -2);\n        _this.whileHasBackReferences = _this._while.hasBackReferences;\n        _this.patterns = patterns.patterns;\n        _this.hasMissingPatterns = patterns.hasMissingPatterns;\n        _this._cachedCompiledPatterns = null;\n        _this._cachedCompiledWhilePatterns = null;\n        return _this;\n    }\n    BeginWhileRule.prototype.getWhileWithResolvedBackReferences = function (lineText, captureIndices) {\n        return this._while.resolveBackReferences(lineText, captureIndices);\n    };\n    BeginWhileRule.prototype.collectPatternsRecursive = function (grammar, out, isFirst) {\n        if (isFirst) {\n            var i = void 0, len = void 0, rule = void 0;\n            for (i = 0, len = this.patterns.length; i < len; i++) {\n                rule = grammar.getRule(this.patterns[i]);\n                rule.collectPatternsRecursive(grammar, out, false);\n            }\n        }\n        else {\n            out.push(this._begin);\n        }\n    };\n    BeginWhileRule.prototype.compile = function (grammar, endRegexSource, allowA, allowG) {\n        this._precompile(grammar);\n        return this._cachedCompiledPatterns.compile(grammar, allowA, allowG);\n    };\n    BeginWhileRule.prototype._precompile = function (grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatternsRecursive(grammar, this._cachedCompiledPatterns, true);\n        }\n    };\n    BeginWhileRule.prototype.compileWhile = function (grammar, endRegexSource, allowA, allowG) {\n        this._precompileWhile(grammar);\n        if (this._while.hasBackReferences) {\n            this._cachedCompiledWhilePatterns.setSource(0, endRegexSource);\n        }\n        return this._cachedCompiledWhilePatterns.compile(grammar, allowA, allowG);\n    };\n    BeginWhileRule.prototype._precompileWhile = function (grammar) {\n        if (!this._cachedCompiledWhilePatterns) {\n            this._cachedCompiledWhilePatterns = new RegExpSourceList();\n            this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n        }\n    };\n    return BeginWhileRule;\n}(Rule));\nexports.BeginWhileRule = BeginWhileRule;\nvar RuleFactory = /** @class */ (function () {\n    function RuleFactory() {\n    }\n    RuleFactory.createCaptureRule = function (helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n        return helper.registerRule(function (id) {\n            return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n        });\n    };\n    RuleFactory.getCompiledRuleId = function (desc, helper, repository) {\n        if (!desc.id) {\n            helper.registerRule(function (id) {\n                desc.id = id;\n                if (desc.match) {\n                    return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, RuleFactory._compileCaptures(desc.captures, helper, repository));\n                }\n                if (!desc.begin) {\n                    if (desc.repository) {\n                        repository = utils_1.mergeObjects({}, repository, desc.repository);\n                    }\n                    return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, RuleFactory._compilePatterns(desc.patterns, helper, repository));\n                }\n                if (desc.while) {\n                    return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), RuleFactory._compilePatterns(desc.patterns, helper, repository));\n                }\n                return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, RuleFactory._compilePatterns(desc.patterns, helper, repository));\n            });\n        }\n        return desc.id;\n    };\n    RuleFactory._compileCaptures = function (captures, helper, repository) {\n        var r = [], numericCaptureId, maximumCaptureId, i, captureId;\n        if (captures) {\n            // Find the maximum capture id\n            maximumCaptureId = 0;\n            for (captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                numericCaptureId = parseInt(captureId, 10);\n                if (numericCaptureId > maximumCaptureId) {\n                    maximumCaptureId = numericCaptureId;\n                }\n            }\n            // Initialize result\n            for (i = 0; i <= maximumCaptureId; i++) {\n                r[i] = null;\n            }\n            // Fill out result\n            for (captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                numericCaptureId = parseInt(captureId, 10);\n                var retokenizeCapturedWithRuleId = 0;\n                if (captures[captureId].patterns) {\n                    retokenizeCapturedWithRuleId = RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n                }\n                r[numericCaptureId] = RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n            }\n        }\n        return r;\n    };\n    RuleFactory._compilePatterns = function (patterns, helper, repository) {\n        var r = [], pattern, i, len, patternId, externalGrammar, rule, skipRule;\n        if (patterns) {\n            for (i = 0, len = patterns.length; i < len; i++) {\n                pattern = patterns[i];\n                patternId = -1;\n                if (pattern.include) {\n                    if (pattern.include.charAt(0) === '#') {\n                        // Local include found in `repository`\n                        var localIncludedRule = repository[pattern.include.substr(1)];\n                        if (localIncludedRule) {\n                            patternId = RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n                        }\n                        else {\n                            // console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                        }\n                    }\n                    else if (pattern.include === '$base' || pattern.include === '$self') {\n                        // Special include also found in `repository`\n                        patternId = RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n                    }\n                    else {\n                        var externalGrammarName = null, externalGrammarInclude = null, sharpIndex = pattern.include.indexOf('#');\n                        if (sharpIndex >= 0) {\n                            externalGrammarName = pattern.include.substring(0, sharpIndex);\n                            externalGrammarInclude = pattern.include.substring(sharpIndex + 1);\n                        }\n                        else {\n                            externalGrammarName = pattern.include;\n                        }\n                        // External include\n                        externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n                        if (externalGrammar) {\n                            if (externalGrammarInclude) {\n                                var externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                                if (externalIncludedRule) {\n                                    patternId = RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                                }\n                                else {\n                                    // console.warn('CANNOT find rule for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                                }\n                            }\n                            else {\n                                patternId = RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                            }\n                        }\n                        else {\n                            // console.warn('CANNOT find grammar for scopeName: ' + pattern.include + ', I am: ', repository['$base'].name);\n                        }\n                    }\n                }\n                else {\n                    patternId = RuleFactory.getCompiledRuleId(pattern, helper, repository);\n                }\n                if (patternId !== -1) {\n                    rule = helper.getRule(patternId);\n                    skipRule = false;\n                    if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n                        if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n                            skipRule = true;\n                        }\n                    }\n                    if (skipRule) {\n                        // console.log('REMOVING RULE ENTIRELY DUE TO EMPTY PATTERNS THAT ARE MISSING');\n                        continue;\n                    }\n                    r.push(patternId);\n                }\n            }\n        }\n        return {\n            patterns: r,\n            hasMissingPatterns: ((patterns ? patterns.length : 0) !== r.length)\n        };\n    };\n    return RuleFactory;\n}());\nexports.RuleFactory = RuleFactory;\n//# sourceMappingURL=rule.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParsedThemeRule = /** @class */ (function () {\n    function ParsedThemeRule(scope, parentScopes, index, fontStyle, foreground, background) {\n        this.scope = scope;\n        this.parentScopes = parentScopes;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n    return ParsedThemeRule;\n}());\nexports.ParsedThemeRule = ParsedThemeRule;\nfunction isValidHexColor(hex) {\n    if (/^#[0-9a-f]{6}$/i.test(hex)) {\n        // #rrggbb\n        return true;\n    }\n    if (/^#[0-9a-f]{8}$/i.test(hex)) {\n        // #rrggbbaa\n        return true;\n    }\n    if (/^#[0-9a-f]{3}$/i.test(hex)) {\n        // #rgb\n        return true;\n    }\n    if (/^#[0-9a-f]{4}$/i.test(hex)) {\n        // #rgba\n        return true;\n    }\n    return false;\n}\n/**\n * Parse a raw theme into rules.\n */\nfunction parseTheme(source) {\n    if (!source) {\n        return [];\n    }\n    if (!source.settings || !Array.isArray(source.settings)) {\n        return [];\n    }\n    var settings = source.settings;\n    var result = [], resultLen = 0;\n    for (var i = 0, len = settings.length; i < len; i++) {\n        var entry = settings[i];\n        if (!entry.settings) {\n            continue;\n        }\n        var scopes = void 0;\n        if (typeof entry.scope === 'string') {\n            var _scope = entry.scope;\n            // remove leading commas\n            _scope = _scope.replace(/^[,]+/, '');\n            // remove trailing commans\n            _scope = _scope.replace(/[,]+$/, '');\n            scopes = _scope.split(',');\n        }\n        else if (Array.isArray(entry.scope)) {\n            scopes = entry.scope;\n        }\n        else {\n            scopes = [''];\n        }\n        var fontStyle = -1 /* NotSet */;\n        if (typeof entry.settings.fontStyle === 'string') {\n            fontStyle = 0 /* None */;\n            var segments = entry.settings.fontStyle.split(' ');\n            for (var j = 0, lenJ = segments.length; j < lenJ; j++) {\n                var segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* Underline */;\n                        break;\n                }\n            }\n        }\n        var foreground = null;\n        if (typeof entry.settings.foreground === 'string' && isValidHexColor(entry.settings.foreground)) {\n            foreground = entry.settings.foreground;\n        }\n        var background = null;\n        if (typeof entry.settings.background === 'string' && isValidHexColor(entry.settings.background)) {\n            background = entry.settings.background;\n        }\n        for (var j = 0, lenJ = scopes.length; j < lenJ; j++) {\n            var _scope = scopes[j].trim();\n            var segments = _scope.split(' ');\n            var scope = segments[segments.length - 1];\n            var parentScopes = null;\n            if (segments.length > 1) {\n                parentScopes = segments.slice(0, segments.length - 1);\n                parentScopes.reverse();\n            }\n            result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);\n        }\n    }\n    return result;\n}\nexports.parseTheme = parseTheme;\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedThemeRules(parsedThemeRules) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort(function (a, b) {\n        var r = strcmp(a.scope, b.scope);\n        if (r !== 0) {\n            return r;\n        }\n        r = strArrCmp(a.parentScopes, b.parentScopes);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    var defaultFontStyle = 0 /* None */;\n    var defaultForeground = '#000000';\n    var defaultBackground = '#ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === '') {\n        var incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    var colorMap = new ColorMap();\n    var defaults = new ThemeTrieElementRule(0, null, defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n    var root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n    for (var i = 0, len = parsedThemeRules.length; i < len; i++) {\n        var rule = parsedThemeRules[i];\n        root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = /** @class */ (function () {\n    function ColorMap() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = Object.create(null);\n    }\n    ColorMap.prototype.getId = function (color) {\n        if (color === null) {\n            return 0;\n        }\n        color = color.toUpperCase();\n        var value = this._color2id[color];\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id[color] = value;\n        this._id2color[value] = color;\n        return value;\n    };\n    ColorMap.prototype.getColorMap = function () {\n        return this._id2color.slice(0);\n    };\n    return ColorMap;\n}());\nexports.ColorMap = ColorMap;\nvar Theme = /** @class */ (function () {\n    function Theme(colorMap, defaults, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._defaults = defaults;\n        this._cache = {};\n    }\n    Theme.createFromRawTheme = function (source) {\n        return this.createFromParsedTheme(parseTheme(source));\n    };\n    Theme.createFromParsedTheme = function (source) {\n        return resolveParsedThemeRules(source);\n    };\n    Theme.prototype.getColorMap = function () {\n        return this._colorMap.getColorMap();\n    };\n    Theme.prototype.getDefaults = function () {\n        return this._defaults;\n    };\n    Theme.prototype.match = function (scopeName) {\n        if (!this._cache.hasOwnProperty(scopeName)) {\n            this._cache[scopeName] = this._root.match(scopeName);\n        }\n        return this._cache[scopeName];\n    };\n    return Theme;\n}());\nexports.Theme = Theme;\nfunction strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexports.strcmp = strcmp;\nfunction strArrCmp(a, b) {\n    if (a === null && b === null) {\n        return 0;\n    }\n    if (!a) {\n        return -1;\n    }\n    if (!b) {\n        return 1;\n    }\n    var len1 = a.length;\n    var len2 = b.length;\n    if (len1 === len2) {\n        for (var i = 0; i < len1; i++) {\n            var res = strcmp(a[i], b[i]);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    }\n    return len1 - len2;\n}\nexports.strArrCmp = strArrCmp;\nvar ThemeTrieElementRule = /** @class */ (function () {\n    function ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background) {\n        this.scopeDepth = scopeDepth;\n        this.parentScopes = parentScopes;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n    ThemeTrieElementRule.prototype.clone = function () {\n        return new ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n    };\n    ThemeTrieElementRule.cloneArr = function (arr) {\n        var r = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            r[i] = arr[i].clone();\n        }\n        return r;\n    };\n    ThemeTrieElementRule.prototype.acceptOverwrite = function (scopeDepth, fontStyle, foreground, background) {\n        if (this.scopeDepth > scopeDepth) {\n            console.log('how did this happen?');\n        }\n        else {\n            this.scopeDepth = scopeDepth;\n        }\n        // console.log('TODO -> my depth: ' + this.scopeDepth + ', overwriting depth: ' + scopeDepth);\n        if (fontStyle !== -1 /* NotSet */) {\n            this.fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            this.foreground = foreground;\n        }\n        if (background !== 0) {\n            this.background = background;\n        }\n    };\n    return ThemeTrieElementRule;\n}());\nexports.ThemeTrieElementRule = ThemeTrieElementRule;\nvar ThemeTrieElement = /** @class */ (function () {\n    function ThemeTrieElement(mainRule, rulesWithParentScopes, children) {\n        if (rulesWithParentScopes === void 0) { rulesWithParentScopes = []; }\n        if (children === void 0) { children = {}; }\n        this._mainRule = mainRule;\n        this._rulesWithParentScopes = rulesWithParentScopes;\n        this._children = children;\n    }\n    ThemeTrieElement._sortBySpecificity = function (arr) {\n        if (arr.length === 1) {\n            return arr;\n        }\n        arr.sort(this._cmpBySpecificity);\n        return arr;\n    };\n    ThemeTrieElement._cmpBySpecificity = function (a, b) {\n        if (a.scopeDepth === b.scopeDepth) {\n            var aParentScopes = a.parentScopes;\n            var bParentScopes = b.parentScopes;\n            var aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;\n            var bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;\n            if (aParentScopesLen === bParentScopesLen) {\n                for (var i = 0; i < aParentScopesLen; i++) {\n                    var aLen = aParentScopes[i].length;\n                    var bLen = bParentScopes[i].length;\n                    if (aLen !== bLen) {\n                        return bLen - aLen;\n                    }\n                }\n            }\n            return bParentScopesLen - aParentScopesLen;\n        }\n        return b.scopeDepth - a.scopeDepth;\n    };\n    ThemeTrieElement.prototype.match = function (scope) {\n        if (scope === '') {\n            return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n        }\n        var dotIndex = scope.indexOf('.');\n        var head;\n        var tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        if (this._children.hasOwnProperty(head)) {\n            return this._children[head].match(tail);\n        }\n        return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n    };\n    ThemeTrieElement.prototype.insert = function (scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n        if (scope === '') {\n            this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n            return;\n        }\n        var dotIndex = scope.indexOf('.');\n        var head;\n        var tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        var child;\n        if (this._children.hasOwnProperty(head)) {\n            child = this._children[head];\n        }\n        else {\n            child = new ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n            this._children[head] = child;\n        }\n        child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n    };\n    ThemeTrieElement.prototype._doInsertHere = function (scopeDepth, parentScopes, fontStyle, foreground, background) {\n        if (parentScopes === null) {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n            return;\n        }\n        // Try to merge into existing rule\n        for (var i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n            var rule = this._rulesWithParentScopes[i];\n            if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n                // bingo! => we get to merge this into an existing one\n                rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n                return;\n            }\n        }\n        // Must add a new rule\n        // Inherit from main rule\n        if (fontStyle === -1 /* NotSet */) {\n            fontStyle = this._mainRule.fontStyle;\n        }\n        if (foreground === 0) {\n            foreground = this._mainRule.foreground;\n        }\n        if (background === 0) {\n            background = this._mainRule.background;\n        }\n        this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n    };\n    return ThemeTrieElement;\n}());\nexports.ThemeTrieElement = ThemeTrieElement;\n//# sourceMappingURL=theme.js.map","\"use strict\";\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction clone(something) {\n    return doClone(something);\n}\nexports.clone = clone;\nfunction doClone(something) {\n    if (Array.isArray(something)) {\n        return cloneArray(something);\n    }\n    if (typeof something === 'object') {\n        return cloneObj(something);\n    }\n    return something;\n}\nfunction cloneArray(arr) {\n    var r = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n        r[i] = doClone(arr[i]);\n    }\n    return r;\n}\nfunction cloneObj(obj) {\n    var r = {};\n    for (var key in obj) {\n        r[key] = doClone(obj[key]);\n    }\n    return r;\n}\nfunction mergeObjects(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        for (var key in source) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n}\nexports.mergeObjects = mergeObjects;\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/;\nvar RegexSource = /** @class */ (function () {\n    function RegexSource() {\n    }\n    RegexSource.hasCaptures = function (regexSource) {\n        return CAPTURING_REGEX_SOURCE.test(regexSource);\n    };\n    RegexSource.replaceCaptures = function (regexSource, captureSource, captureIndices) {\n        return regexSource.replace(CAPTURING_REGEX_SOURCE, function (match, index, commandIndex, command) {\n            var capture = captureIndices[parseInt(index || commandIndex, 10)];\n            if (capture) {\n                var result = captureSource.substring(capture.start, capture.end);\n                // Remove leading dots that would make the selector invalid\n                while (result[0] === '.') {\n                    result = result.substring(1);\n                }\n                switch (command) {\n                    case 'downcase':\n                        return result.toLowerCase();\n                    case 'upcase':\n                        return result.toUpperCase();\n                    default:\n                        return result;\n                }\n            }\n            else {\n                return match;\n            }\n        });\n    };\n    return RegexSource;\n}());\nexports.RegexSource = RegexSource;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst OnigScanner_1 = require(\"./OnigScanner\");\nclass OnigRegExp {\n    /**\n     * Create a new regex with the given pattern\n     * @param source A string pattern\n     */\n    constructor(source) {\n        this.source = source;\n        try {\n            this.scanner = new OnigScanner_1.default([this.source]);\n        }\n        catch (error) {\n            // doesn't make much sense, but this to pass atom/node-oniguruam tests\n        }\n    }\n    /**\n     * Synchronously search the string for a match starting at the given position\n     * @param string The string to search\n     * @param startPosition The optional position to start the search at, defaults to `0`\n     */\n    searchSync(string, startPosition) {\n        let match;\n        if (startPosition == null) {\n            startPosition = 0;\n        }\n        match = this.scanner.findNextMatchSync(string, startPosition);\n        return this.captureIndicesForMatch(string, match);\n    }\n    /**\n     * Search the string for a match starting at the given position\n     * @param string The string to search\n     * @param startPosition The optional position to start the search at, defaults to `0`\n     * @param callback The `(error, match)` function to call when done, match will be null if no matches were found. match will be an array of objects for each matched group on a successful search\n     */\n    search(string, startPosition, callback) {\n        if (startPosition == null) {\n            startPosition = 0;\n        }\n        if (typeof startPosition === 'function') {\n            callback = startPosition;\n            startPosition = 0;\n        }\n        try {\n            const ret = this.searchSync(string, startPosition);\n            callback(null, ret);\n        }\n        catch (error) {\n            callback(error);\n        }\n    }\n    /**\n     * Synchronously test if this regular expression matches the given string\n     * @param string The string to test against\n     */\n    testSync(string) {\n        if ((typeof this.source === 'boolean' || typeof string === 'boolean')) {\n            return this.source === string;\n        }\n        return this.searchSync(string) != null;\n    }\n    /**\n     * Test if this regular expression matches the given string\n     * @param string The string to test against\n     * @param callback The (error, matches) function to call when done, matches will be true if at least one match is found, false otherwise\n     */\n    test(string, callback) {\n        if (typeof callback !== 'function') {\n            callback = () => { };\n        }\n        try {\n            callback(null, this.testSync(string));\n        }\n        catch (error) {\n            callback(error);\n        }\n    }\n    captureIndicesForMatch(string, match) {\n        if (match != null) {\n            const { captureIndices } = match;\n            let capture;\n            string = this.scanner.convertToString(string);\n            for (let i = 0; i < captureIndices.length; i++) {\n                capture = captureIndices[i];\n                capture.match = string.slice(capture.start, capture.end);\n            }\n            return captureIndices;\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.default = OnigRegExp;\n//# sourceMappingURL=OnigRegExp.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LRUCache = require(\"lru-cache\");\nconst onigasmH_1 = require(\"./onigasmH\");\nconst OnigString_1 = require(\"./OnigString\");\n/**\n * Allocates space on the heap and copies the string bytes on to it\n * @param str\n * @returns pointer to the first byte's address on heap\n */\nfunction mallocAndWriteString(str) {\n    const ptr = onigasmH_1.onigasmH._malloc(str.utf8Bytes.length);\n    onigasmH_1.onigasmH.HEAPU8.set(str.utf8Bytes, ptr);\n    return ptr;\n}\nfunction convertUTF8BytesFromPtrToString(ptr) {\n    const chars = [];\n    let i = 0;\n    while (onigasmH_1.onigasmH.HEAPU8[ptr] !== 0x00) {\n        chars[i++] = onigasmH_1.onigasmH.HEAPU8[ptr++];\n    }\n    return chars.join();\n}\nconst cache = new LRUCache({\n    dispose: (scanner, info) => {\n        const regexTPtrsPtr = onigasmH_1.onigasmH._malloc(info.regexTPtrs.length);\n        onigasmH_1.onigasmH.HEAPU8.set(info.regexTPtrs, regexTPtrsPtr);\n        const status = onigasmH_1.onigasmH._disposeCompiledPatterns(regexTPtrsPtr, scanner.patterns.length);\n        if (status !== 0) {\n            const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1.onigasmH._getLastError());\n            throw new Error(errMessage);\n        }\n        onigasmH_1.onigasmH._free(regexTPtrsPtr);\n    },\n    max: 1000,\n});\nclass OnigScanner {\n    /**\n     * Create a new scanner with the given patterns\n     * @param patterns  An array of string patterns\n     */\n    constructor(patterns) {\n        if (onigasmH_1.onigasmH === null) {\n            throw new Error(`Onigasm has not been initialized, call loadWASM from 'onigasm' exports before using any other API`);\n        }\n        for (let i = 0; i < patterns.length; i++) {\n            const pattern = patterns[i];\n            if (typeof pattern !== 'string') {\n                throw new TypeError(`First parameter to OnigScanner constructor must be array of (pattern) strings`);\n            }\n        }\n        this.sources = patterns.slice();\n    }\n    get patterns() {\n        return this.sources.slice();\n    }\n    /**\n     * Find the next match from a given position\n     * @param string The string to search\n     * @param startPosition The optional position to start at, defaults to 0\n     * @param callback The (error, match) function to call when done, match will null when there is no match\n     */\n    findNextMatch(string, startPosition, callback) {\n        if (startPosition == null) {\n            startPosition = 0;\n        }\n        if (typeof startPosition === 'function') {\n            callback = startPosition;\n            startPosition = 0;\n        }\n        try {\n            const match = this.findNextMatchSync(string, startPosition);\n            callback(null, match);\n        }\n        catch (error) {\n            callback(error);\n        }\n    }\n    /**\n     * Find the next match from a given position\n     * @param string The string to search\n     * @param startPosition The optional position to start at, defaults to 0\n     */\n    findNextMatchSync(string, startPosition) {\n        if (startPosition == null) {\n            startPosition = 0;\n        }\n        startPosition = this.convertToNumber(startPosition);\n        let onigNativeInfo = cache.get(this);\n        let status = 0;\n        if (!onigNativeInfo) {\n            const regexTAddrRecieverPtr = onigasmH_1.onigasmH._malloc(4);\n            const regexTPtrs = [];\n            for (let i = 0; i < this.sources.length; i++) {\n                const pattern = this.sources[i];\n                const patternStrPtr = mallocAndWriteString(new OnigString_1.default(pattern));\n                status = onigasmH_1.onigasmH._compilePattern(patternStrPtr, regexTAddrRecieverPtr);\n                if (status !== 0) {\n                    const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1.onigasmH._getLastError());\n                    throw new Error(errMessage);\n                }\n                const regexTAddress = onigasmH_1.onigasmH.HEAP32[regexTAddrRecieverPtr / 4];\n                regexTPtrs.push(regexTAddress);\n                onigasmH_1.onigasmH._free(patternStrPtr);\n            }\n            onigNativeInfo = {\n                regexTPtrs: new Uint8Array(Uint32Array.from(regexTPtrs).buffer),\n            };\n            onigasmH_1.onigasmH._free(regexTAddrRecieverPtr);\n            cache.set(this, onigNativeInfo);\n        }\n        const onigString = string instanceof OnigString_1.default ? string : new OnigString_1.default(this.convertToString(string));\n        const strPtr = mallocAndWriteString(onigString);\n        const resultInfoReceiverPtr = onigasmH_1.onigasmH._malloc(8);\n        const regexTPtrsPtr = onigasmH_1.onigasmH._malloc(onigNativeInfo.regexTPtrs.length);\n        onigasmH_1.onigasmH.HEAPU8.set(onigNativeInfo.regexTPtrs, regexTPtrsPtr);\n        status = onigasmH_1.onigasmH._findBestMatch(\n        // regex_t **patterns\n        regexTPtrsPtr, \n        // int patternCount\n        this.sources.length, \n        // UChar *utf8String\n        strPtr, \n        // int strLen\n        onigString.utf8Bytes.length - 1, \n        // int startOffset\n        onigString.convertUtf16OffsetToUtf8(startPosition), \n        // int *resultInfo\n        resultInfoReceiverPtr);\n        if (status !== 0) {\n            const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1.onigasmH._getLastError());\n            throw new Error(errMessage);\n        }\n        const [\n        // The index of pattern which matched the string at least offset from 0 (start)\n        bestPatternIdx, \n        // Begin address of capture info encoded as pairs\n        // like [start, end, start, end, start, end, ...]\n        //  - first start-end pair is entire match (index 0 and 1)\n        //  - subsequent pairs are capture groups (2, 3 = first capture group, 4, 5 = second capture group and so on)\n        encodedResultBeginAddress, \n        // Length of the [start, end, ...] sequence so we know how much memory to read (will always be 0 or multiple of 2)\n        encodedResultLength,] = new Uint32Array(onigasmH_1.onigasmH.HEAPU32.buffer, resultInfoReceiverPtr, 3);\n        onigasmH_1.onigasmH._free(strPtr);\n        onigasmH_1.onigasmH._free(resultInfoReceiverPtr);\n        onigasmH_1.onigasmH._free(regexTPtrsPtr);\n        if (encodedResultLength > 0) {\n            const encodedResult = new Uint32Array(onigasmH_1.onigasmH.HEAPU32.buffer, encodedResultBeginAddress, encodedResultLength);\n            const captureIndices = [];\n            let i = 0;\n            let captureIdx = 0;\n            while (i < encodedResultLength) {\n                const index = captureIdx++;\n                let start = encodedResult[i++];\n                let end = encodedResult[i++];\n                if (onigString.hasMultiByteCharacters) {\n                    start = onigString.convertUtf8OffsetToUtf16(start);\n                    end = onigString.convertUtf8OffsetToUtf16(end);\n                }\n                captureIndices.push({\n                    end,\n                    index,\n                    length: end - start,\n                    start,\n                });\n            }\n            onigasmH_1.onigasmH._free(encodedResultBeginAddress);\n            return {\n                captureIndices,\n                index: bestPatternIdx,\n                scanner: this,\n            };\n        }\n        return null;\n    }\n    convertToString(value) {\n        if (value === undefined) {\n            return 'undefined';\n        }\n        if (value === null) {\n            return 'null';\n        }\n        if (value instanceof OnigString_1.default) {\n            return value.content;\n        }\n        return value.toString();\n    }\n    convertToNumber(value) {\n        value = parseInt(value, 10);\n        if (!isFinite(value)) {\n            value = 0;\n        }\n        value = Math.max(value, 0);\n        return value;\n    }\n}\nexports.OnigScanner = OnigScanner;\nexports.default = OnigScanner;\n//# sourceMappingURL=OnigScanner.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass OnigString {\n    constructor(content) {\n        this.substring = (start, end) => {\n            return this.source.substring(start, end);\n        };\n        this.toString = (start, end) => {\n            return this.source;\n        };\n        if (typeof content !== 'string') {\n            throw new TypeError('Argument must be a string');\n        }\n        this.source = content;\n        this._utf8Bytes = null;\n        this._utf8Indexes = null;\n    }\n    get utf8Bytes() {\n        if (!this._utf8Bytes) {\n            this.encode();\n        }\n        return this._utf8Bytes;\n    }\n    /**\n     * Returns `null` if all utf8 offsets match utf-16 offset (content has no multi byte characters)\n     */\n    get utf8Indexes() {\n        if (!this._utf8Bytes) {\n            this.encode();\n        }\n        return this._utf8Indexes;\n    }\n    get content() {\n        return this.source;\n    }\n    get length() {\n        return this.source.length;\n    }\n    get hasMultiByteCharacters() {\n        return this.utf8Indexes !== null;\n    }\n    convertUtf8OffsetToUtf16(utf8Offset) {\n        if (utf8Offset < 0) {\n            return 0;\n        }\n        const utf8Array = this._utf8Bytes;\n        if (utf8Offset >= utf8Array.length - 1) {\n            return this.source.length;\n        }\n        const utf8OffsetMap = this.utf8Indexes;\n        if (utf8OffsetMap && utf8Offset >= this._mappingTableStartOffset) {\n            return findFirstInSorted(utf8OffsetMap, utf8Offset - this._mappingTableStartOffset) + this._mappingTableStartOffset;\n        }\n        return utf8Offset;\n    }\n    convertUtf16OffsetToUtf8(utf16Offset) {\n        if (utf16Offset < 0) {\n            return 0;\n        }\n        const utf8Array = this._utf8Bytes;\n        if (utf16Offset >= this.source.length) {\n            return utf8Array.length - 1;\n        }\n        const utf8OffsetMap = this.utf8Indexes;\n        if (utf8OffsetMap && utf16Offset >= this._mappingTableStartOffset) {\n            return utf8OffsetMap[utf16Offset - this._mappingTableStartOffset] + this._mappingTableStartOffset;\n        }\n        return utf16Offset;\n    }\n    encode() {\n        const str = this.source;\n        const n = str.length;\n        let utf16OffsetToUtf8;\n        let utf8Offset = 0;\n        let mappingTableStartOffset = 0;\n        function createOffsetTable(startOffset) {\n            const maxUtf8Len = (n - startOffset) * 3;\n            if (maxUtf8Len <= 0xff) {\n                utf16OffsetToUtf8 = new Uint8Array(n - startOffset);\n            }\n            else if (maxUtf8Len <= 0xffff) {\n                utf16OffsetToUtf8 = new Uint16Array(n - startOffset);\n            }\n            else {\n                utf16OffsetToUtf8 = new Uint32Array(n - startOffset);\n            }\n            mappingTableStartOffset = startOffset;\n            utf16OffsetToUtf8[utf8Offset++] = 0;\n        }\n        const u8view = new Uint8Array((n * 3) /* alloc max now, trim later*/ + 1 /** null termination character */);\n        let ptrHead = 0;\n        let i = 0;\n        // for some reason, v8 is faster with str.length than using a variable (might be illusion)\n        while (i < str.length) {\n            let codepoint;\n            const c = str.charCodeAt(i);\n            if (utf16OffsetToUtf8) {\n                utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset;\n            }\n            if (c < 0xD800 || c > 0xDFFF) {\n                codepoint = c;\n            }\n            else if (c >= 0xDC00) {\n                codepoint = 0xFFFD;\n            }\n            else {\n                if (i === n - 1) {\n                    codepoint = 0xFFFD;\n                }\n                else {\n                    const d = str.charCodeAt(i + 1);\n                    if (0xDC00 <= d && d <= 0xDFFF) {\n                        if (!utf16OffsetToUtf8) {\n                            createOffsetTable(i);\n                        }\n                        const a = c & 0x3FF;\n                        const b = d & 0x3FF;\n                        codepoint = 0x10000 + (a << 10) + b;\n                        i += 1;\n                        utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset;\n                    }\n                    else {\n                        codepoint = 0xFFFD;\n                    }\n                }\n            }\n            let bytesRequiredToEncode;\n            let offset;\n            if (codepoint <= 0x7F) {\n                bytesRequiredToEncode = 1;\n                offset = 0;\n            }\n            else if (codepoint <= 0x07FF) {\n                bytesRequiredToEncode = 2;\n                offset = 0xC0;\n            }\n            else if (codepoint <= 0xFFFF) {\n                bytesRequiredToEncode = 3;\n                offset = 0xE0;\n            }\n            else {\n                bytesRequiredToEncode = 4;\n                offset = 0xF0;\n            }\n            if (bytesRequiredToEncode === 1) {\n                u8view[ptrHead++] = codepoint;\n            }\n            else {\n                if (!utf16OffsetToUtf8) {\n                    createOffsetTable(ptrHead);\n                }\n                u8view[ptrHead++] = (codepoint >> (6 * (--bytesRequiredToEncode))) + offset;\n                while (bytesRequiredToEncode > 0) {\n                    const temp = codepoint >> (6 * (bytesRequiredToEncode - 1));\n                    u8view[ptrHead++] = (0x80 | (temp & 0x3F));\n                    bytesRequiredToEncode -= 1;\n                }\n            }\n            i += 1;\n        }\n        const utf8 = u8view.slice(0, ptrHead + 1);\n        utf8[ptrHead] = 0x00;\n        this._utf8Bytes = utf8;\n        if (utf16OffsetToUtf8) { // set if UTF-16 surrogate chars or multi-byte characters found\n            this._utf8Indexes = utf16OffsetToUtf8;\n            this._mappingTableStartOffset = mappingTableStartOffset;\n        }\n    }\n}\nfunction findFirstInSorted(array, i) {\n    let low = 0;\n    let high = array.length;\n    if (high === 0) {\n        return 0; // no children\n    }\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (array[mid] >= i) {\n            high = mid;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n    // low is on the index of the first value >= i or array.length. Decrement low until we find array[low] <= i\n    while (low > 0 && (low >= array.length || array[low] > i)) {\n        low--;\n    }\n    // check whether we are on the second index of a utf-16 surrogate char. If so, go to the first index.\n    if (low > 0 && array[low] === array[low - 1]) {\n        low--;\n    }\n    return low;\n}\nexports.default = OnigString;\n//# sourceMappingURL=OnigString.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst onigasmH_1 = require(\"./onigasmH\");\nexports.loadWASM = onigasmH_1.loadWASM;\nconst OnigRegExp_1 = require(\"./OnigRegExp\");\nexports.OnigRegExp = OnigRegExp_1.default;\nconst OnigScanner_1 = require(\"./OnigScanner\");\nexports.OnigScanner = OnigScanner_1.default;\nconst OnigString_1 = require(\"./OnigString\");\nexports.OnigString = OnigString_1.default;\n//# sourceMappingURL=index.js.map","\nvar Onigasm = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return (\nfunction(Onigasm) {\n  Onigasm = Onigasm || {};\n\nvar Module=typeof Onigasm!==\"undefined\"?Onigasm:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram=\"./this.program\";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=true;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readBinary;if(ENVIRONMENT_IS_SHELL){if(typeof read!=\"undefined\"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer===\"function\"){return new Uint8Array(readbuffer(f))}data=read(f,\"binary\");assert(typeof data===\"object\");return data};if(typeof scriptArgs!=\"undefined\"){arguments_=scriptArgs}else if(typeof arguments!=\"undefined\"){arguments_=arguments}if(typeof quit===\"function\"){quit_=function(status){quit(status)}}if(typeof print!==\"undefined\"){if(typeof console===\"undefined\")console={};console.log=print;console.warn=console.error=typeof printErr!==\"undefined\"?printErr:print}}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var STACK_ALIGN=16;function dynamicAlloc(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;if(end>_emscripten_get_heap_size()){abort()}HEAP32[DYNAMICTOP_PTR>>2]=end;return ret}function getNativeTypeSize(type){switch(type){case\"i1\":case\"i8\":return 1;case\"i16\":return 2;case\"i32\":return 4;case\"i64\":return 8;case\"float\":return 4;case\"double\":return 8;default:{if(type[type.length-1]===\"*\"){return 4}else if(type[0]===\"i\"){var bits=parseInt(type.substr(1));assert(bits%8===0,\"getNativeTypeSize invalid bits \"+bits+\", type \"+type);return bits/8}else{return 0}}}}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}function convertJsFunctionToWasm(func,sig){var typeSection=[1,0,1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={\"i\":127,\"j\":126,\"f\":125,\"d\":124};typeSection.push(sigParam.length);for(var i=0;i<sigParam.length;++i){typeSection.push(typeCodes[sigParam[i]])}if(sigRet==\"v\"){typeSection.push(0)}else{typeSection=typeSection.concat([1,typeCodes[sigRet]])}typeSection[1]=typeSection.length-2;var bytes=new Uint8Array([0,97,115,109,1,0,0,0].concat(typeSection,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0]));var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports.f;return wrappedFunc}function addFunctionWasm(func,sig){var table=wasmTable;var ret=table.length;try{table.grow(1)}catch(err){if(!err instanceof RangeError){throw err}throw\"Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.\"}try{table.set(ret,func)}catch(err){if(!err instanceof TypeError){throw err}assert(typeof sig!==\"undefined\",\"Missing signature argument to addFunction\");var wrapped=convertJsFunctionToWasm(func,sig);table.set(ret,wrapped)}return ret}function removeFunctionWasm(index){}var funcWrappers={};function dynCall(sig,ptr,args){if(args&&args.length){return Module[\"dynCall_\"+sig].apply(null,[ptr].concat(args))}else{return Module[\"dynCall_\"+sig].call(null,ptr)}}var tempRet0=0;var setTempRet0=function(value){tempRet0=value};var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime;if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(typeof WebAssembly!==\"object\"){err(\"no native wasm support detected\")}function setValue(ptr,value,type,noSafe){type=type||\"i8\";if(type.charAt(type.length-1)===\"*\")type=\"i32\";switch(type){case\"i1\":HEAP8[ptr>>0]=value;break;case\"i8\":HEAP8[ptr>>0]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;default:abort(\"invalid type for setValue: \"+type)}}var wasmMemory;var wasmTable=new WebAssembly.Table({\"initial\":244,\"maximum\":244+0,\"element\":\"anyfunc\"});var ABORT=false;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort(\"Assertion failed: \"+text)}}function getCFunc(ident){var func=Module[\"_\"+ident];assert(func,\"Cannot call unknown function \"+ident+\", make sure it is exported\");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={\"string\":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},\"array\":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\")return UTF8ToString(ret);if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}var ALLOC_NONE=3;var UTF8Decoder=typeof TextDecoder!==\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str=\"\";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!==\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var STACK_BASE=5507664,DYNAMIC_BASE=5507664,DYNAMICTOP_PTR=264624;var INITIAL_TOTAL_MEMORY=Module[\"TOTAL_MEMORY\"]||157286400;if(Module[\"wasmMemory\"]){wasmMemory=Module[\"wasmMemory\"]}else{wasmMemory=new WebAssembly.Memory({\"initial\":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE})}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback==\"function\"){callback();continue}var func=callback.func;if(typeof func===\"number\"){if(callback.arg===undefined){Module[\"dynCall_v\"](func)}else{Module[\"dynCall_vi\"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){runtimeExited=true}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module[\"preloadedImages\"]={};Module[\"preloadedAudios\"]={};function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what+=\"\";out(what);err(what);ABORT=true;EXITSTATUS=1;what=\"abort(\"+what+\"). Build with -s ASSERTIONS=1 for more info.\";throw new WebAssembly.RuntimeError(what)}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile=\"onigasm.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(wasmBinaryFile)}else{throw\"both async and sync fetching of the wasm failed\"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&typeof fetch===\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary()})}return new Promise(function(resolve,reject){resolve(getBinary())})}function createWasm(){var info={\"env\":asmLibraryArg,\"wasi_unstable\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiatedSource(output){receiveInstance(output[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming===\"function\"&&!isDataURI(wasmBinaryFile)&&typeof fetch===\"function\"){fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");instantiateArrayBuffer(receiveInstantiatedSource)})})}else{return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);return false}}instantiateAsync();return{}}var tempDouble;var tempI64;__ATINIT__.push({func:function(){___wasm_call_ctors()}});function demangle(func){var __cxa_demangle_func=Module[\"___cxa_demangle\"]||Module[\"__cxa_demangle\"];assert(__cxa_demangle_func);try{var s=func;if(s.startsWith(\"__Z\"))s=s.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(HEAP32[status>>2]===0&&ret){return UTF8ToString(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}return func}function demangleAll(text){var regex=/\\b_Z[\\w\\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+\" [\"+x+\"]\"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return\"(no stack trace available)\"}}return err.stack.toString()}function _abort(){abort()}function _emscripten_get_heap_size(){return HEAP8.length}function _emscripten_get_sbrk_ptr(){return 264624}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE)}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT)}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}var PATH={splitPath:function(filename){var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)===\"/\",trailingSlash=path.substr(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(function(p){return!!p}),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:function(path){if(path===\"/\")return\"/\";var lastSlash=path.lastIndexOf(\"/\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join(\"/\"))},join2:function(l,r){return PATH.normalize(l+\"/\"+r)}};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get()}};function _fd_close(fd){try{return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _fd_write(fd,iov,iovcnt,pnum){try{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS===\"undefined\"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function _setTempRet0($i){setTempRet0($i|0)}var ASSERTIONS=false;var asmLibraryArg={\"abort\":_abort,\"emscripten_get_sbrk_ptr\":_emscripten_get_sbrk_ptr,\"emscripten_memcpy_big\":_emscripten_memcpy_big,\"emscripten_resize_heap\":_emscripten_resize_heap,\"fd_close\":_fd_close,\"fd_seek\":_fd_seek,\"fd_write\":_fd_write,\"memory\":wasmMemory,\"setTempRet0\":_setTempRet0,\"table\":wasmTable};var asm=createWasm();Module[\"asm\"]=asm;var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return Module[\"asm\"][\"malloc\"].apply(null,arguments)};var _free=Module[\"_free\"]=function(){return Module[\"asm\"][\"free\"].apply(null,arguments)};var _getLastError=Module[\"_getLastError\"]=function(){return Module[\"asm\"][\"getLastError\"].apply(null,arguments)};var _compilePattern=Module[\"_compilePattern\"]=function(){return Module[\"asm\"][\"compilePattern\"].apply(null,arguments)};var _disposeCompiledPatterns=Module[\"_disposeCompiledPatterns\"]=function(){return Module[\"asm\"][\"disposeCompiledPatterns\"].apply(null,arguments)};var _findBestMatch=Module[\"_findBestMatch\"]=function(){return Module[\"asm\"][\"findBestMatch\"].apply(null,arguments)};var ___cxa_demangle=Module[\"___cxa_demangle\"]=function(){return Module[\"asm\"][\"__cxa_demangle\"].apply(null,arguments)};var _setThrew=Module[\"_setThrew\"]=function(){return Module[\"asm\"][\"setThrew\"].apply(null,arguments)};var stackSave=Module[\"stackSave\"]=function(){return Module[\"asm\"][\"stackSave\"].apply(null,arguments)};var stackAlloc=Module[\"stackAlloc\"]=function(){return Module[\"asm\"][\"stackAlloc\"].apply(null,arguments)};var stackRestore=Module[\"stackRestore\"]=function(){return Module[\"asm\"][\"stackRestore\"].apply(null,arguments)};var __growWasmMemory=Module[\"__growWasmMemory\"]=function(){return Module[\"asm\"][\"__growWasmMemory\"].apply(null,arguments)};var dynCall_vi=Module[\"dynCall_vi\"]=function(){return Module[\"asm\"][\"dynCall_vi\"].apply(null,arguments)};var dynCall_iiii=Module[\"dynCall_iiii\"]=function(){return Module[\"asm\"][\"dynCall_iiii\"].apply(null,arguments)};var dynCall_iiiii=Module[\"dynCall_iiiii\"]=function(){return Module[\"asm\"][\"dynCall_iiiii\"].apply(null,arguments)};var dynCall_iii=Module[\"dynCall_iii\"]=function(){return Module[\"asm\"][\"dynCall_iii\"].apply(null,arguments)};var dynCall_iidiiii=Module[\"dynCall_iidiiii\"]=function(){return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null,arguments)};var dynCall_vii=Module[\"dynCall_vii\"]=function(){return Module[\"asm\"][\"dynCall_vii\"].apply(null,arguments)};var dynCall_ii=Module[\"dynCall_ii\"]=function(){return Module[\"asm\"][\"dynCall_ii\"].apply(null,arguments)};var dynCall_i=Module[\"dynCall_i\"]=function(){return Module[\"asm\"][\"dynCall_i\"].apply(null,arguments)};var dynCall_v=Module[\"dynCall_v\"]=function(){return Module[\"asm\"][\"dynCall_v\"].apply(null,arguments)};var dynCall_viiiiii=Module[\"dynCall_viiiiii\"]=function(){return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null,arguments)};var dynCall_viiiii=Module[\"dynCall_viiiii\"]=function(){return Module[\"asm\"][\"dynCall_viiiii\"].apply(null,arguments)};var dynCall_viiii=Module[\"dynCall_viiii\"]=function(){return Module[\"asm\"][\"dynCall_viiii\"].apply(null,arguments)};var dynCall_jiji=Module[\"dynCall_jiji\"]=function(){return Module[\"asm\"][\"dynCall_jiji\"].apply(null,arguments)};Module[\"asm\"]=asm;Module[\"ccall\"]=ccall;var calledRun;Module[\"then\"]=function(func){if(calledRun){func(Module)}else{var old=Module[\"onRuntimeInitialized\"];Module[\"onRuntimeInitialized\"]=function(){if(old)old();func(Module)}}return Module};function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}Module[\"run\"]=run;if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}noExitRuntime=true;run();\n\n\n  return Onigasm\n}\n);\n})();\nif (typeof exports === 'object' && typeof module === 'object')\n      module.exports = Onigasm;\n    else if (typeof define === 'function' && define['amd'])\n      define([], function() { return Onigasm; });\n    else if (typeof exports === 'object')\n      exports[\"Onigasm\"] = Onigasm;\n    ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst OnigasmModuleFactory = require('./onigasm.js' /** when TS is compiled to JS, this will mean `lib/onigasm.js` (emitted by `emcc`) */);\nasync function initModule(bytes) {\n    return new Promise((resolve, reject) => {\n        const { log, warn, error } = console;\n        OnigasmModuleFactory({\n            instantiateWasm(imports, successCallback) {\n                WebAssembly.instantiate(bytes, imports)\n                    .then((output) => {\n                    successCallback(output.instance);\n                })\n                    .catch((e) => {\n                    throw e;\n                });\n                return {};\n            },\n        })\n            .then(moduleH => {\n            exports.onigasmH = moduleH;\n            resolve();\n        });\n        if (typeof print !== 'undefined') {\n            // can be removed when https://github.com/emscripten-core/emscripten/issues/9829 is fixed.\n            // tslint:disable-next-line:no-console\n            console.log = log;\n            // tslint:disable-next-line:no-console\n            console.error = error;\n            // tslint:disable-next-line:no-console\n            console.warn = warn;\n        }\n    });\n}\nlet isInitialized = false;\n/**\n * Mount the .wasm file that will act as library's \"backend\"\n * @param data Path to .wasm file or it's ArrayBuffer\n */\nasync function loadWASM(data) {\n    if (isInitialized) {\n        throw new Error(`Onigasm#init has been called and was succesful, subsequent calls are not allowed once initialized`);\n    }\n    if (typeof data === 'string') {\n        const arrayBuffer = await (await fetch(data)).arrayBuffer();\n        await initModule(arrayBuffer);\n    }\n    else if (data instanceof ArrayBuffer) {\n        await initModule(data);\n    }\n    else {\n        throw new TypeError(`Expected a string (URL of .wasm file) or ArrayBuffer (.wasm file itself) as first parameter`);\n    }\n    isInitialized = true;\n}\nexports.loadWASM = loadWASM;\n//# sourceMappingURL=onigasmH.js.map","'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","const getVueApp = () => {\n  return (document.querySelector('#app') as any).__vue__\n}\n\nexport default getVueApp\n","import * as monaco from 'monaco-editor/esm/vs/editor/editor.api'\nimport { loadWASM } from 'onigasm'\nimport { IGrammarDefinition, Registry } from 'monaco-textmate'\nimport { wireTmGrammars } from 'monaco-editor-textmate'\nimport getVueApp from '@/util/get-vue-app'\nimport themeDark from '@/monaco/theme/editor.dark.theme.json'\nimport themeLight from '@/monaco/theme/editor.light.theme.json'\n\ntype CodeLensSupportedService = 'klipper' | 'moonraker' | 'moonraker-telegram-bot'\n\nconst isCodeLensSupportedService = (service: string) : service is CodeLensSupportedService => [\n  'klipper',\n  'moonraker',\n  'moonraker-telegram-bot'\n].includes(service)\n\nconst getDocsSection = (service: CodeLensSupportedService, sectionName: string) => {\n  switch (service) {\n    case 'klipper':\n      if (sectionName.startsWith('stepper_')) {\n        return 'stepper'\n      }\n\n      if (/^extruder[0-9]+$/.test(sectionName)) {\n        return 'extruder'\n      }\n  }\n\n  return sectionName\n}\n\nasync function setupMonaco () {\n  const wasm = await require('onigasm/lib/onigasm.wasm')\n  await loadWASM(wasm.default)\n\n  // Register our custom TextMate languages.\n  const registry = new Registry({\n    getGrammarDefinition: async (scopeName): Promise<IGrammarDefinition> => {\n      const fileName = scopeName.split('.').pop()\n      return import(\n                /* webpackChunkName: \"grammar-[request]\" */\n                `@/monaco/language/${fileName}.tmLanguage.json`\n      )\n        .then(language => {\n          return Promise.resolve({\n            format: 'json',\n            content: language.default\n          })\n        })\n    }\n  })\n\n  // Load our grammars...\n  const grammars = new Map()\n  grammars.set('gcode', 'source.gcode')\n  grammars.set('klipper-config', 'source.klipper-config')\n  grammars.set('log', 'text.log')\n\n  // ... and our languages\n  monaco.languages.register({ id: 'gcode', extensions: ['gcode', 'g', 'gc', 'gco', 'ufp', 'nc'] })\n  monaco.languages.register({ id: 'klipper-config', extensions: ['cfg', 'conf'] })\n  monaco.languages.register({ id: 'log', extensions: ['log'] })\n\n  // Define how commenting works.\n  monaco.languages.setLanguageConfiguration('gcode', {\n    comments: {\n      lineComment: ';'\n    }\n  })\n  monaco.languages.setLanguageConfiguration('klipper-config', {\n    comments: {\n      lineComment: '#'\n    }\n  })\n\n  const app = getVueApp()\n\n  monaco.editor.registerCommand('fluidd_open_docs', (_, service: CodeLensSupportedService, hash: string) => {\n    const serviceKey = service.replace(/-/g, '_')\n    const url = app.$t(`app.file_system.url.${serviceKey}_config`, { hash }).toString()\n\n    window.open(url)\n  })\n\n  monaco.languages.registerCodeLensProvider('klipper-config', {\n    provideCodeLenses: (model) => {\n      const { service } = app.$store.getters['server/getConfigMapByFilename'](model.uri.path.split('/').pop())\n\n      if (!isCodeLensSupportedService(service)) {\n        return null\n      }\n\n      const linesContent = model.getLinesContent()\n\n      const sections = linesContent.reduce((ranges, lineContent, index) => {\n        const section = /^\\[([^\\]]+)\\]/.exec(lineContent)\n        if (section) {\n          const [sectionName] = section[1].split(' ')\n\n          const referenceSection = getDocsSection(service, sectionName)\n\n          return ranges.concat({\n            referenceSection,\n            range: {\n              startLineNumber: index + 1,\n              startColumn: model.getLineFirstNonWhitespaceColumn(index + 1),\n              endLineNumber: index + 1,\n              endColumn: model.getLineLastNonWhitespaceColumn(index + 1)\n            }\n          })\n        }\n        return ranges\n      }, [] as { referenceSection: string, range: monaco.IRange }[])\n\n      return {\n        lenses: sections.map((section, index) =>\n          ({\n            range: section.range,\n            id: `docs${index}`,\n            command: {\n              id: 'fluidd_open_docs',\n              title: app.$t('app.file_system.label.view_section_documentation', { section: section.referenceSection }).toString(),\n              arguments: [service, section.referenceSection]\n            }\n          })\n        ),\n        dispose: () => undefined\n      }\n    },\n    resolveCodeLens: (_model, codeLens) => codeLens\n  })\n\n  monaco.languages.registerFoldingRangeProvider('klipper-config', {\n    provideFoldingRanges: (model) => {\n      const linesContent = model.getLinesContent()\n\n      const sectionBlocks = linesContent.reduce((sectionBlocks, lineContent, index) => {\n        const isSection = /^\\[([^\\]]+)\\]/.test(lineContent)\n\n        if (isSection) {\n          return sectionBlocks.concat({\n            start: index + 1,\n            end: index + 1\n          })\n        }\n\n        const isNotComment = /^\\s*[^#;]/.test(lineContent)\n\n        if (isNotComment && sectionBlocks.length > 0) {\n          sectionBlocks[sectionBlocks.length - 1].end = index + 1\n        }\n\n        return sectionBlocks\n      }, [] as Array<{ start: number, end: number }>)\n\n      const commentBlocks = linesContent.reduce((commentBlocks, lineContent, index) => {\n        lineContent = lineContent.trim()\n\n        if (lineContent.length > 0) {\n          const isComment = ['#', ';'].includes(lineContent[0])\n\n          const lastCommentBlock = commentBlocks.length > 0 ? commentBlocks[commentBlocks.length - 1] : undefined\n\n          if (isComment) {\n            if (lastCommentBlock && !lastCommentBlock.complete) {\n              lastCommentBlock.end = index + 1\n            } else {\n              return commentBlocks.concat({\n                start: index + 1,\n                end: index + 1,\n                complete: false\n              })\n            }\n          } else if (lastCommentBlock) {\n            lastCommentBlock.complete = true\n          }\n        }\n\n        return commentBlocks\n      }, [] as Array<{start: number, end: number, complete: boolean}>)\n\n      return [\n        ...sectionBlocks.map(section => ({\n          start: section.start,\n          end: section.end,\n          kind: monaco.languages.FoldingRangeKind.Region\n        })),\n        ...commentBlocks.map(section => ({\n          start: section.start,\n          end: section.end,\n          kind: monaco.languages.FoldingRangeKind.Comment\n        }))\n      ]\n    }\n  })\n\n  // Defined the themes.\n  monaco.editor.defineTheme('dark-converted', themeDark as any)\n  monaco.editor.defineTheme('light-converted', themeLight as any)\n\n  // Wire it up.\n  await wireTmGrammars(monaco, registry, grammars)\n\n  return monaco\n}\n\n// Exporting a promise ensures that setupMonaco is run only once\nconst promise = setupMonaco()\nexport default promise\n","var map = {\n\t\"./gcode.tmLanguage.json\": [\n\t\t93512,\n\t\t503\n\t],\n\t\"./klipper-config.tmLanguage.json\": [\n\t\t12789,\n\t\t511\n\t],\n\t\"./log.tmLanguage.json\": [\n\t\t24581,\n\t\t85\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__.t(id, 3 | 16);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 10006;\nmodule.exports = webpackAsyncContext;"],"names":["parseWithLocation","content","filename","locationKeyName","_parse","parse","len","length","pos","line","char","advancePosBy","by","chCode","charCodeAt","advancePosTo","to","skipWhitespace","advanceIfStartsWith","str","substr","advanceUntil","nextOccurence","indexOf","captureUntil","r","substring","state","cur","stateStack","objStack","curKey","pushState","newState","newCur","push","popState","pop","fail","msg","Error","dictState","enterDict","newDict","enterArray","newArr","arrState","leaveDict","leaveArray","acceptKey","val","acceptString","acceptReal","isNaN","acceptInteger","acceptDate","acceptData","acceptBool","escapeVal","replace","_","m0","String","fromCodePoint","parseInt","parseOpenTag","isClosed","name","trim","parseTagValue","tag","peekChCode","parseFloat","Date","test","exports","monaco_textmate_1","tm_to_monaco_token_1","TokenizerState","constructor","_ruleStack","this","ruleStack","clone","equals","other","wireTmGrammars","monaco","registry","languages","editor","Promise","all","Array","from","keys","map","async","languageId","grammar","loadGrammar","get","setTokensProvider","getInitialState","INITIAL","tokenize","res","tokenizeLine","endState","tokens","token","scopes","TMToMonacoToken","Object","defineProperty","value","scopeName","i","scope","slice","getColorTheme","_tokenTheme","_match","_foreground","self","paths","stripTrailingSlash","globalAPI","getWorkerUrl","moduleId","label","pathPrefix","result","currentUrl","window","location","currentOrigin","hash","search","pathname","protocol","js","blob","Blob","type","URL","createObjectURL","module","WindowManager","_zoomFactor","getZoomFactor","INSTANCE","DevicePixelRatioMonitor","super","_onDidChange","_register","onDidChange","event","_listener","_handleChange","_mediaQueryList","fireEvent","removeEventListener","matchMedia","devicePixelRatio","addEventListener","fire","PixelRatioImpl","_value","_getPixelRatio","dprMonitor","ctx","document","createElement","getContext","dpr","bsr","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","PixelRatioFacade","_pixelRatioMonitor","_getOrCreatePixelRatioMonitor","PixelRatio","userAgent","navigator","isFirefox","isWebKit","isChrome","isSafari","isWebkitWebView","isElectron","isAndroid","isStandalone","matches","BrowserFeatures","clipboard","writeText","queryCommandSupported","readText","keyboard","touch","maxTouchPoints","pointerEvents","PointerEvent","DataTransfers","RESOURCES","DOWNLOAD_URL","FILES","TEXT","TERMINALS","DragAndDropData","data","update","getData","StaticDND","CurrentDragAndDropData","undefined","clearNode","node","firstChild","remove","isInDOM","_a","isConnected","DomListener","handler","options","_node","_type","_handler","_options","dispose","addDisposableListener","useCaptureOrOptions","_wrapAsStandardMouseEvent","e","_wrapAsStandardKeyboardEvent","addStandardDisposableListener","useCapture","wrapHandler","addDisposableNonBubblingMouseOutListener","toElement","parentNode","addDisposableNonBubblingPointerOutListener","createEventEmitter","target","domListener","onFirstListenerAdd","onLastListenerRemove","runAtThisOrScheduleAtNextAnimationFrame","scheduleAtNextAnimationFrame","_animationFrame","doRequestAnimationFrame","callback","emulatedRequestAnimationFrame","setTimeout","getTime","requestAnimationFrame","msRequestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","call","AnimationFrameQueueItem","runner","priority","_runner","_canceled","execute","static","a","b","NEXT_QUEUE","CURRENT_QUEUE","animFrameRequested","inAnimationFrameRunner","animationFrameRunner","sort","top","shift","item","MINIMUM_TIME_MS","DEFAULT_EVENT_MERGER","lastEvent","currentEvent","TimeoutThrottledDomListener","eventMerger","minimumTimeMs","lastHandlerTime","timeout","invokeHandler","elapsedTime","cancel","setIfNotSet","addDisposableThrottledListener","getComputedStyle","el","defaultView","getClientArea","element","body","Dimension","clientWidth","clientHeight","visualViewport","width","height","innerWidth","innerHeight","documentElement","SizeUtils","cssPropertyName","jsPropertyName","computedStyle","getPropertyValue","getAttribute","convertToPixels","getDimension","with","obj","getTopLeftOffset","offsetParent","offsetTop","left","offsetLeft","scrollTop","c","isShadowRoot","direction","scrollLeft","getBorderLeftWidth","getBorderTopWidth","size","style","getDomNodePagePosition","domNode","bb","getBoundingClientRect","StandardWindow","scrollX","scrollY","None","getTotalWidth","margin","getMarginLeft","getMarginRight","offsetWidth","getContentWidth","border","getBorderRightWidth","padding","getPaddingLeft","getPaddingRight","getContentHeight","getBorderBottomWidth","getPaddingTop","getPaddingBottom","offsetHeight","getTotalHeight","getMarginTop","getMarginBottom","isAncestor","testChild","testAncestor","findParentWithClass","clazz","stopAtClazzOrNode","nodeType","ELEMENT_NODE","classList","contains","hasParentWithClass","host","mode","isInShadowDOM","getShadowRoot","getActiveElement","activeElement","shadowRoot","createStyleSheet","container","getElementsByTagName","media","appendChild","_sharedStyleSheet","getSharedStyleSheet","getDynamicStyleSheetRules","_b","sheet","rules","cssRules","createCSSRule","selector","cssText","insertRule","removeCSSRulesContainingSelector","ruleName","toDelete","rule","selectorText","deleteRule","isHTMLElement","o","HTMLElement","nodeName","EventType","CLICK","AUXCLICK","DBLCLICK","MOUSE_UP","MOUSE_DOWN","MOUSE_OVER","MOUSE_MOVE","MOUSE_OUT","MOUSE_ENTER","MOUSE_LEAVE","MOUSE_WHEEL","POINTER_UP","POINTER_DOWN","POINTER_MOVE","CONTEXT_MENU","WHEEL","KEY_DOWN","KEY_PRESS","KEY_UP","LOAD","BEFORE_UNLOAD","UNLOAD","PAGE_SHOW","PAGE_HIDE","ABORT","ERROR","RESIZE","SCROLL","FULLSCREEN_CHANGE","WK_FULLSCREEN_CHANGE","SELECT","CHANGE","SUBMIT","RESET","FOCUS","FOCUS_IN","FOCUS_OUT","BLUR","INPUT","STORAGE","DRAG_START","DRAG","DRAG_ENTER","DRAG_LEAVE","DRAG_OVER","DROP","DRAG_END","ANIMATION_START","ANIMATION_END","ANIMATION_ITERATION","EventHelper","stop","cancelBubble","preventDefault","returnValue","stopPropagation","saveParentsScrollTop","restoreParentsScrollTop","FocusTracker","_onDidFocus","onDidFocus","_onDidBlur","onDidBlur","hasFocus","hasFocusWithin","loosingFocus","onFocus","onBlur","_refreshStateHandler","currentNodeHasFocus","trackFocus","append","parent","children","prepend","child","insertBefore","reset","innerText","SELECTOR_REGEX","Namespace","_$","namespace","description","attrs","match","exec","assign","tagName","HTML","createElementNS","id","className","forEach","setAttribute","$","show","elements","display","removeAttribute","hide","prototype","computeScreenAwareSize","cssPx","screenPx","Math","max","floor","windowOpenNoOpener","url","open","animate","fn","step","stepDisposable","asCSSUrl","uri","toString","asCSSPropertyValue","SVG","href","ModifierKeyEmitter","_subscriptions","_keyStatus","altKey","shiftKey","ctrlKey","metaKey","add","defaultPrevented","keyCode","repeat","lastKeyPressed","lastKeyReleased","buttons","resetKeyStatus","keyStatus","doResetKeyStatus","instance","addMatchMediaChangeListener","query","mediaQueryList","DomEmitter","emitter","stopEvent","FastDomNode","_maxWidth","_width","_height","_top","_left","_bottom","_right","_fontFamily","_fontWeight","_fontSize","_fontStyle","_fontFeatureSettings","_textDecoration","_lineHeight","_letterSpacing","_className","_display","_position","_visibility","_color","_backgroundColor","_layerHint","_contain","_boxShadow","setMaxWidth","maxWidth","setWidth","setHeight","setTop","unsetTop","setLeft","setBottom","bottom","setRight","right","setFontFamily","fontFamily","setFontWeight","fontWeight","setFontSize","fontSize","setFontStyle","fontStyle","setFontFeatureSettings","fontFeatureSettings","setTextDecoration","textDecoration","setLineHeight","lineHeight","setLetterSpacing","letterSpacing","setClassName","toggleClassName","shouldHaveIt","toggle","setDisplay","setPosition","position","setVisibility","visibility","setColor","color","setBackgroundColor","backgroundColor","setLayerHinting","layerHint","transform","setBoxShadow","boxShadow","setContain","contain","removeChild","createFastDomNode","renderText","text","textContent","renderFormattedText","formattedText","_renderFormattedText","parseFormattedText","renderCodeSegments","actionHandler","inline","StringStream","source","index","eos","next","peek","advance","treeNode","createTextNode","disposables","isArray","nodeChild","parseCodeSegments","root","actionViewItemIndex","current","stack","stream","isEscapedFormatType","formatTagType","isFormatTag","newCurrent","textCurrent","supportCodeSegments","standardMouseMoveMerger","ev","leftButton","posx","posy","GlobalMouseMoveMonitor","_hooks","_mouseMoveEventMerger","_mouseMoveCallback","_onStopCallback","stopMonitoring","invokeStopCallback","browserEvent","isMonitoring","clear","onStopCallback","startMonitoring","initialElement","initialButtons","mouseMoveEventMerger","mouseMoveCallback","windowChain","mouseMove","mouseUp","listenTo","unshift","lastSameOriginAncestor","toLowerCase","hasDifferentOriginAncestorFlag","sameOriginWindowChainCache","getParentWindowIfSameOrigin","w","parentLocation","origin","IframeUtils","iframeElement","frameElement","getSameOriginWindowChain","childWindow","ancestorWindow","windowChainEl","boundingRect","extractKeyCode","charCode","fromCharCode","toUpperCase","ctrlKeyMod","altKeyMod","shiftKeyMod","metaKeyMod","StandardKeyboardEvent","_standardKeyboardEventBrand","code","_asKeybinding","_computeKeybinding","_asRuntimeKeybinding","_computeRuntimeKeybinding","toKeybinding","key","StandardMouseEvent","timestamp","now","button","middleButton","rightButton","detail","pageX","pageY","clientX","clientY","iframeOffsets","view","StandardWheelEvent","deltaX","deltaY","targetNode","srcElement","e1","e2","wheelDeltaY","VERTICAL_AXIS","axis","deltaMode","DOM_DELTA_LINE","wheelDeltaX","HORIZONTAL_AXIS","wheelDelta","__decorate","decorators","desc","d","arguments","getOwnPropertyDescriptor","Reflect","decorate","Tap","Change","Start","End","Contextmenu","Gesture","dispatched","activeTouches","handle","targets","ignoreTargets","_lastSetTapCountTime","onTouchStart","passive","onTouchEnd","onTouchMove","isTouchDevice","filter","t","targetTouches","identifier","initialTarget","initialTimeStamp","initialPageX","initialPageY","rollingTimestamps","rollingPageX","rollingPageY","evt","newGestureEvent","dispatchEvent","activeTouchCount","changedTouches","hasOwnProperty","console","warn","holdTime","HOLD_DELAY","abs","finalX","finalY","deltaT","dispatchTo","Node","inertia","createEvent","initEvent","tapCount","currentTime","setTapCount","CLEAR_TAP_COUNT_TIME","t1","vX","dirX","x","vY","dirY","y","delta_pos_x","delta_pos_y","stopped","SCROLL_FRICTION","translationX","translationY","BaseActionViewItem","context","action","_context","_action","handleActionChangeEvent","enabled","updateEnabled","checked","updateChecked","class","updateClass","updateLabel","updateTooltip","tooltip","actionRunner","_actionRunner","getAction","isEnabled","setActionContext","newContext","render","enableDragging","draggable","dataTransfer","setData","onClick","isMenu","preserveFocus","useEventAsContext","run","focus","tabIndex","blur","setFocusable","focusable","trapsArrowNavigation","ActionViewItem","icon","cssClass","keybinding","title","comment","split","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","reject","fulfilled","rejected","done","then","apply","ActionBar","_c","_d","_e","_f","previousKeys","nextKeys","triggerKeyDown","_onDidCancel","cancelHasListener","onDidCancel","_onDidRun","onDidRun","_onBeforeRun","onBeforeRun","_orientation","orientation","_triggerKeys","keyDown","triggerKeys","_actionIds","viewItems","focusedItem","animated","eventHandled","focusPrevious","focusNext","focusFirst","focusLast","isTriggerKeyEvent","doTrigger","updateFocusedItem","focusTracker","previouslyFocusedItem","actionsList","ariaLabel","refreshRole","firstEnabled","find","vi","ret","elem","getContainer","arg","actions","actionViewItemElement","allowContextMenu","actionViewItemProvider","splice","selectFirst","findIndex","updateFocus","forceLoop","startIndex","preventLoopNavigation","focusOnlyEnabledItems","fromRight","preventScroll","forceFocus","actionViewItem","focusItem","MAX_MESSAGE_LENGTH","ariaContainer","alertContainer","alertContainer2","statusContainer","statusContainer2","setARIAContainer","createAlertContainer","createStatusContainer","alert","insertMessage","status","defaultOpts","inputActiveOptionBorder","inputActiveOptionForeground","inputActiveOptionBackground","Checkbox","opts","_onChange","onChange","_onKeyDown","onKeyDown","_opts","_checked","isChecked","classes","actionClassName","notFocusable","applyStyles","onclick","ignoreGesture","onkeydown","keyboardEvent","newIsChecked","styles","borderColor","enable","disable","formatRule","def","definition","fontCharacter","badgeBackground","badgeForeground","CountBadge","count","create","badgeBorder","countFormat","titleFormat","setCount","setTitleFormat","background","foreground","borderWidth","borderStyle","NLS_CASE_SENSITIVE_CHECKBOX_LABEL","NLS_WHOLE_WORD_CHECKBOX_LABEL","NLS_REGEX_CHECKBOX_LABEL","CaseSensitiveCheckbox","appendTitle","WholeWordsCheckbox","RegexCheckbox","HighlightedLabel","highlights","didEverRender","supportIcons","set","escapeNewLines","highlight","end","start","extraClasses","total","extra","offset","setupNativeHover","htmlElement","markdownNotSupportedFallback","UpdatableHoverWidget","hoverDelegate","fadeInAnimation","_cancellationTokenSource","isDisposed","resolvedContent","markdown","_hoverWidget","isCancellationRequested","oldHoverWidget","hasContent","hoverOptions","showPointer","placement","hoverPosition","skipFadeInAnimation","showHover","setupCustomHover","hoverPreparation","hoverWidget","hideHover","disposeWidget","disposePreparation","onDidHideHover","triggerShowHover","delay","onMouseOver","toDispose","onMouseLeave","fromElement","dom","onMouseDown","targetElements","onMouseMove","mouseOverDomEmitter","hover","newContent","FastLabelNode","_element","disposed","_textContent","empty","_empty","marginLeft","IconLabel","customHovers","Map","labelContainer","nameContainer","descriptionContainer","supportHighlights","nameNode","LabelWithHighlights","Label","supportDescriptionHighlights","descriptionNodeFactory","setLabel","italic","strikethrough","join","setupHover","descriptionTitle","descriptionNode","descriptionMatches","previousCustomHover","delete","hoverDisposable","disposable","values","singleLabel","domId","l","separator","splitMatches","labels","labelStart","labelRange","range","labelEscapeNewLines","m","highlightedLabel","labelWithIconsRegex","RegExp","renderLabelWithIcons","textStart","textStop","escaped","codicon","renderIcon","ArrayNavigator","items","min","previous","first","last","HistoryNavigator","history","limit","_initialize","_limit","getHistory","_elements","_history","_currentPosition","_navigator","has","_reduceToLimit","currentElement","Set","entry","inputBackground","inputForeground","inputValidationInfoBorder","inputValidationInfoBackground","inputValidationWarningBorder","inputValidationWarningBackground","inputValidationErrorBorder","inputValidationErrorBackground","InputBox","contextViewProvider","maxHeight","Number","POSITIVE_INFINITY","_onDidHeightChange","onDidHeightChange","message","placeholder","inputBorder","inputValidationInfoForeground","inputValidationWarningForeground","inputValidationErrorForeground","validationOptions","validation","flexibleHeight","wrapper","input","onfocus","onblur","flexibleMaxHeight","mirror","scrollableElement","vertical","flexibleWidth","whiteSpace","wordWrap","getDomNode","onScroll","onSelectionChange","onAnchoredSelectionChange","selection","getSelection","anchorNode","updateScrollDimensions","showPlaceholderOnFocus","setPlaceHolder","setTooltip","oninput","onValueChange","updateMirror","actionbar","_hideMessage","_showMessage","placeHolder","setAriaLabel","getAriaLabel","inputElement","newValue","cachedHeight","select","setSelectionRange","scrollWidth","isSelectionAtEnd","selectionEnd","selectionStart","disabled","horizontalPadding","paddingLeft","paddingRight","cachedContentHeight","scrollHeight","setScrollDimensions","setScrollPosition","showMessage","force","classForType","stylesForType","hideMessage","validate","errorMsg","hasAttribute","div","alertText","layout","showContextView","getAnchor","anchorAlignment","renderOptions","spanElement","formatContent","onHide","nls","aria","hideContextView","lastCharCode","suffix","mirrorTextContent","previousHeight","insertAtCursor","HistoryInputBox","NLS_PLACEHOLDER_HISTORY_HINT","NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX","NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS","addSuffix","showHistoryHint","endsWith","suffixedPlaceholder","observer","MutationObserver","mutationList","mutation","observe","attributeFilter","resetPlaceholder","historyHint","revertedPlaceholder","disconnect","addToHistory","getCurrentValue","showNextValue","getNextValue","showPreviousValue","getPreviousValue","currentValue","groupIntersect","groups","intersection","much","consolidate","previousGroup","group","concat","reduce","g","RangeMap","_size","deleteCount","diff","before","after","middle","indexAt","newSize","indexAfter","positionAt","groupCount","newCount","removeFromParent","parentElement","RowCache","renderers","cache","alloc","templateId","getTemplateCache","renderer","getRenderer","templateData","renderTemplate","release","row","releaseRow","cachedRows","cachedRow","disposeTemplate","DefaultOptions","useShadows","verticalScrollMode","setRowLineHeight","setRowHeight","supportDynamicHeights","dnd","getDragElements","getDragURI","onDragStart","onDragOver","drop","horizontalScrolling","transformOptimization","alwaysConsumeMouseWheel","ElementsDragAndDropData","ExternalElementsDragAndDropData","NativeDragAndDropData","types","files","file","equalsDragFeedback","f1","f2","ListViewAccessibilityProvider","accessibilityProvider","getSetSize","bind","getPosInSet","getRole","ListView","virtualDelegate","InstanceCount","renderWidth","_scrollHeight","scrollableElementUpdateDisposable","scrollableElementWidthDelayer","splicing","dragOverAnimationStopDisposable","dragOverMouseY","canDrop","currentDragFeedbackDisposable","onDragLeaveTimeout","_onDidChangeContentHeight","_horizontalScrolling","itemId","rangeMap","lastRenderTop","lastRenderHeight","mouseSupport","additionalScrollHeight","rowsContainer","scrollable","forceIntegerValues","smoothScrollDuration","smoothScrolling","cb","horizontal","mouseWheelScrollSensitivity","fastScrollSensitivity","onTouchChange","toDragEvent","onDrop","onDragLeave","onDragEnd","contentHeight","measureItemWidth","updateScrollWidth","updateOptions","setSmoothScrollDuration","_splice","previousRenderRange","getRenderRange","deleteRange","removeRange","rowsToDispose","dragStartDisposable","rows","disposeElement","previousRestRange","previousRenderedRestRange","previousUnrenderedRestRanges","inserted","getTemplateId","getHeight","hasDynamicHeight","lastDynamicHeightWidth","dropTarget","checkedDisposable","deleted","delta","renderRange","renderedRestRange","updateRange","updateItemInDOM","removeRanges","removeItemFromDOM","unrenderedRestRanges","elementsRange","insertRanges","beforeElement","getNextToLastElement","insertItemInDOM","eventuallyUpdateScrollDimensions","_rerender","renderHeight","eventuallyUpdateScrollWidth","trigger","rerender","scrollDimensions","getScrollDimensions","domElement","elementHeight","elementTop","renderTop","renderLeft","updateItemsInDOM","rangesToInsert","rangesToRemove","rangesToUpdate","role","renderElement","getElementDomId","getScrollTop","scrollPosition","getScrollPosition","setScrollTop","reuseAnimation","onMouseClick","toMouseEvent","onMouseDblClick","onMouseMiddleClick","onContextMenu","toGestureEvent","toTouchEvent","onTap","getItemIndexFromEventTarget","inSmoothScrolling","err","error","effectAllowed","setDragImage","getDragLabel","dragImage","currentDragData","setupDragAndDropScrollTopAnimation","accept","currentDragFeedback","feedback","dropEffect","effect","clearDragOverFeedback","dragData","teardownDragAndDropScrollTopAnimation","dragOverAnimationDisposable","viewTop","animateDragAndDropScrollTop","upperLimit","rawIndex","anchorElementIndex","anchorElementTopDelta","heightDiff","didChange","probeDynamicHeight","unrenderRanges","renderRanges","afterIndex","beforeRow","deltaScrollTop","getFutureScrollPosition","newScrollTop","getDynamicHeight","setDynamicHeight","ranges","lastRange","nextToLastItem","CombinedSpliceable","spliceables","s","ListError","user","TypeLabelControllerState","TraitRenderer","trait","renderedElements","renderedElementIndex","rendered","unrender","renderIndex","insertCount","renderedElement","renderIndexes","indexes","Trait","_trait","sortedIndexes","hasTrait","_set","numericSort","sortedResult","toRender","disjunction","SelectionTrait","setAriaSelected","TraitSpliceable","identityProvider","pastElementsWithTrait","getId","elementsWithTrait","isInputElement","isMonacoEditor","KeyboardController","list","multipleSelectionDisposables","on","onEnter","onUpArrow","onDownArrow","onPageUpArrow","onPageDownArrow","onEscape","multipleSelectionSupport","platform","onCtrlA","optionsUpdate","setSelection","getFocus","setAnchor","reveal","focusPreviousPage","focusNextPage","DefaultKeyboardNavigationDelegate","mightProducePrintableCharacter","TypeLabelController","keyboardNavigationLabelProvider","delegate","Idle","automaticKeyboardNavigation","triggered","previouslyFocused","enabledDisposables","enableKeyboardNavigation","onChar","onClear","onInput","word","Typing","getKeyboardNavigationLabel","labelStr","setFocus","DOMFocusController","onTab","focusedDomElement","tabIndexElement","querySelector","isSelectionSingleChangeEvent","isSelectionRangeChangeEvent","isMouseRightClick","MouseEvent","DefaultMultipleSelectionController","MouseController","_onPointer","onPointer","multipleSelectionController","onDoubleClick","getHTMLElement","onViewPointer","isSelectionChangeEvent","domFocus","changeSelection","anchor","currentFocus","rangeSelection","contiguousRange","getContiguousRangeContaining","newSelection","relativeComplement","DefaultStyleController","styleElement","selectorSuffix","listBackground","isOpaque","listFocusBackground","listFocusForeground","listActiveSelectionBackground","listActiveSelectionForeground","listActiveSelectionIconForeground","listFocusAndSelectionBackground","listFocusAndSelectionForeground","listInactiveFocusForeground","listInactiveSelectionIconForeground","listInactiveFocusBackground","listInactiveSelectionBackground","listInactiveSelectionForeground","listHoverBackground","listHoverForeground","listSelectionOutline","listFocusOutline","listInactiveFocusOutline","listHoverOutline","listDropBackground","listFilterWidgetBackground","listFilterWidgetOutline","listFilterWidgetNoMatchesOutline","listMatchesShadow","tableColumnsBorder","tableOddRowsBackgroundColor","defaultStyles","treeIndentGuidesStroke","transparent","keyboardSupport","reverse","one","j","PipelineRenderer","_templateId","AccessibiltyRenderer","ariaLevel","getAriaLevel","ListViewDragAndDrop","getSelectedElements","originalEvent","targetElement","targetIndex","List","eventBufferer","_ariaLabel","_onDidDispose","onDidDispose","getWidgetRole","baseRenderers","onDidChangeActiveDescendant","viewOptions","styleController","spliceable","keyboardController","keyboardNavigationDelegate","typeLabelController","mouseController","createMouseController","onDidChangeFocus","_onFocusChange","onDidChangeSelection","_onSelectionChange","getWidgetAriaLabel","wrapEvent","toListEvent","didJustPressContextMenuKey","fromKeyDown","fromKeyUp","fromMouse","bufferEvents","getAnchorElement","n","loop","findNextIndex","findPreviousIndex","lastPageIndex","lastPageElement","currentlyFocusedElement","getFocusedElements","lastGoodPageIndex","previousScrollTop","firstPageIndex","firstPageElement","firstGoodPageIndex","focusNth","relativeTop","viewItemBottom","scrollBottom","getRelativeTop","getActiveDescendantId","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","DEBUG","OrthogonalEdge","globalSize","onDidChangeGlobalSize","globalHoverDelay","onDidChangeHoverDelay","MouseEventFactory","onPointerMove","onPointerUp","GestureEventFactory","OrthogonalPointerEventFactory","factory","PointerEventsDisabledCssClass","Sash","layoutProvider","hoverDelay","hoverDelayer","_state","onDidEnablementChange","_onDidStart","_onDidReset","_onDidEnd","orthogonalStartSashDisposables","orthogonalStartDragHandleDisposables","orthogonalEndSashDisposables","orthogonalEndDragHandleDisposables","onDidStart","onDidReset","onDidEnd","linkedSash","orthogonalEdge","onPointerStart","onMouseDoubleClick","onPointerDoublePress","onMouseEnter","onDoubleTap","orthogonalStartSash","orthogonalEndSash","_orthogonalStartSash","_orthogonalEndSash","sash","_orthogonalStartDragHandle","_orthogonalEndDragHandle","pointerEventFactory","isMultisashResize","__orthogonalSashEvent","orthogonalSash","getOrthogonalSash","__linkedSashEvent","iframes","iframe","startX","startY","startEvent","currentX","currentY","updateStyle","cursor","fromLinkedSash","clearSashHoverState","verticalProvider","getVerticalSashLeft","getVerticalSashTop","getVerticalSashHeight","horizontalProvider","getHorizontalSashTop","getHorizontalSashLeft","getHorizontalSashWidth","ARROW_IMG_SIZE","ScrollbarArrow","_onActivate","onActivate","bgDomNode","bgWidth","bgHeight","classNamesArray","_mouseMoveMonitor","onmousedown","_arrowMouseDown","_mousedownRepeatTimer","_mousedownScheduleRepeatTimer","scheduleRepeater","cancelAndSet","mouseMoveData","ScrollbarVisibilityController","visibleClassName","invisibleClassName","_visibleClassName","_invisibleClassName","_domNode","_isVisible","_isNeeded","_rawShouldBeVisible","_shouldBeVisible","_revealTimer","_updateShouldBeVisible","setShouldBeVisible","rawShouldBeVisible","_applyVisibilitySetting","shouldBeVisible","ensureVisibility","setIsNeeded","isNeeded","setDomNode","_reveal","_hide","withFadeAway","MOUSE_DRAG_RESET_DISTANCE","AbstractScrollbar","_lazyRender","lazyRender","_host","_scrollable","_scrollByPage","scrollByPage","_scrollbarState","scrollbarState","_visibilityController","extraScrollbarClassName","_shouldRender","_domNodeMouseDown","_createArrow","arrow","_createSlider","slider","_sliderMouseDown","_onElementSize","visibleSize","setVisibleSize","_onElementScrollSize","elementScrollSize","setScrollSize","_onElementScrollPosition","elementScrollPosition","beginReveal","beginHide","_renderDomNode","getRectangleLargeSize","getRectangleSmallSize","_updateSlider","getSliderSize","getArrowSize","getSliderPosition","_onMouseDown","delegateMouseDown","domTop","getClientRects","sliderStart","sliderStop","mousePos","_sliderMousePosition","offsetX","offsetY","domNodePosition","_mouseDownRelativePosition","_setDesiredScrollPositionNow","getDesiredScrollPositionFromOffsetPaged","getDesiredScrollPositionFromOffset","onDragFinished","initialMousePosition","initialMouseOrthogonalPosition","_sliderOrthogonalMousePosition","initialScrollbarState","mouseOrthogonalPosition","mouseOrthogonalDelta","mousePosition","mouseDelta","getDesiredScrollPositionFromDelta","_desiredScrollPosition","desiredScrollPosition","writeScrollPosition","setScrollPositionNow","updateScrollbarSize","scrollbarSize","_updateScrollbarSize","setScrollbarSize","MINIMUM_SLIDER_SIZE","ScrollbarState","arrowSize","oppositeScrollbarSize","scrollSize","_scrollbarSize","round","_oppositeScrollbarSize","_arrowSize","_visibleSize","_scrollSize","_scrollPosition","_computedAvailableSize","_computedIsNeeded","_computedSliderSize","_computedSliderRatio","_computedSliderPosition","_refreshComputedValues","iVisibleSize","iScrollSize","iScrollPosition","setOppositeScrollbarSize","computedAvailableSize","computedRepresentableSize","computedIsNeeded","computedSliderSize","computedSliderRatio","computedSliderPosition","_computeValues","desiredSliderPosition","correctedOffset","HorizontalScrollbar","getCurrentScrollPosition","horizontalHasArrows","horizontalScrollbarSize","verticalScrollbarSize","arrowDelta","scrollbarDelta","onMouseWheel","horizontalSliderSize","sliderSize","sliderPosition","largeSize","smallSize","onDidScroll","VerticalScrollbar","verticalHasArrows","verticalSliderSize","HIDE_TIMEOUT","SCROLL_WHEEL_SENSITIVITY","SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED","MouseWheelClassifierItem","score","MouseWheelClassifier","_capacity","_memory","_front","_rear","isPhysicalMouseWheel","remainingInfluence","iteration","influence","pow","_computeScore","_isAlmostInt","AbstractScrollableElement","_onScroll","_onWillScroll","overflow","resolveOptions","_onDidScroll","scrollbarHost","mouseWheelEvent","_onMouseWheel","_onDragStart","_onDragEnd","_verticalScrollbar","_horizontalScrollbar","_leftShadowDomNode","_topShadowDomNode","_topLeftShadowDomNode","_listenOnDomNode","listenOnDomNode","_mouseWheelToDispose","_setListeningToMouseWheel","handleMouseWheel","onmouseover","_onMouseOver","onnonbubblingmouseout","_onMouseOut","_hideTimeout","_isDragging","_mouseIsOver","_revealOnScroll","getOverviewRulerLayoutInfo","delegateVerticalScrollbarMouseDown","dimensions","updateClassName","newClassName","newOptions","scrollPredominantAxis","_render","shouldListen","isListening","classifier","osZoomFactor","didScroll","flipAxes","shiftConvert","scrollYToX","futureScrollPosition","desiredScrollTop","ceil","deltaScrollLeft","desiredScrollLeft","validateScrollPosition","canPerformSmoothScroll","mouseWheelSmoothScroll","setScrollPositionSmooth","consumeMouseWheel","consumeMouseWheelIfScrollbarIsNeeded","renderNow","scrollState","enableTop","enableLeft","leftClassName","topClassName","topLeftClassName","_scheduleHide","ScrollableElement","SmoothScrollableElement","DomScrollableElement","scrollTopChanged","scrollLeftChanged","scanDomNode","separatorBorder","ViewItem","_cachedVisibleSize","cachedVisibleSize","visible","setVisible","viewMinimumSize","viewMaximumSize","minimumSize","maximumSize","snap","layoutContext","layoutContainer","VerticalViewItem","HorizontalViewItem","State","Sizing","Split","Invisible","Distribute","SplitView","contentSize","proportions","sashItems","_onDidSashChange","_onDidSashReset","_startSnappingEnabled","_endSnappingEnabled","onDidSashChange","onDidSashReset","inverseAltBehavior","proportionalLayout","getSashOrthogonalSize","sashContainer","viewContainer","scrollbarVisibility","descriptor","views","viewDescriptor","sizing","doAddView","saveProportions","startSnappingEnabled","endSnappingEnabled","sashItem","updateSashEnablement","isTransparent","removeProperty","setProperty","addView","skipLayout","previousSize","lowPriorityIndexes","highPriorityIndexes","resize","distributeEmptySpace","layoutViews","onSashStart","alt","resetSashDragState","sashDragState","sizes","snapBefore","snapAfter","minDelta","NEGATIVE_INFINITY","maxDelta","isLastSash","viewItem","upIndexes","downIndexes","minDeltaUp","maxDeltaUp","maxDeltaDown","minDeltaDown","snapBeforeIndex","findFirstSnapIndex","snapAfterIndex","halfSize","limitDelta","onSashChange","newDelta","newSizes","viewItemIndex","newMinDelta","newMaxDelta","resizeIndex","onSashEnd","onViewChange","relayout","resizeView","Busy","distributeViewSizes","flexibleViewItems","flexibleSize","getViewSize","onChangeDisposable","containerDisposable","viewSize","getSashPosition","sashEventMapper","onStart","onStartDisposable","onEnd","onEndDisposable","onDidResetDisposable","overloadMinDelta","overloadMaxDelta","upItems","upSizes","downItems","downSizes","snapped","snapView","deltaUp","viewDelta","deltaDown","lowPriorityIndex","emptyDelta","updateScrollableElement","collapsesDown","expandsDown","reverseViews","collapsesUp","expandsUp","snappedBefore","snappedAfter","Widget","listener","onkeyup","Action","actionCallback","_enabled","_id","_label","_cssClass","_actionCallback","_setLabel","_tooltip","_setTooltip","_setClass","_setEnabled","_setChecked","ActionRunner","runAction","Separator","ID","SubmenuAction","_actions","EmptySubmenuAction","tail","array","tail2","arr","itemEquals","binarySearch","comparator","low","high","mid","comp","findFirstInSorted","p","quickSelect","nth","compare","TypeError","pivotValue","random","lower","higher","pivots","groupBy","currentGroup","coalesce","isFalsyOrEmpty","isNonEmptyArray","distinct","keyFn","seen","findLast","predicate","idx","lastIndex","firstOrDefault","notFoundValue","flatten","arrayInsert","insertIndex","insertArr","pushToStart","pushToEnd","asArray","insertInto","newItems","startIdx","getActualStartIndex","originalLength","newItemsLength","compareBy","numberComparator","findMaxBy","findLastMaxBy","findMinBy","ArrayQueue","firstIdx","lastIdx","takeWhile","takeFromEndWhile","endIdx","dequeue","takeCount","ok","__asyncValues","Symbol","asyncIterator","__values","iterator","verb","v","settle","isThenable","createCancelablePromise","thenable","promise","subscription","onCancellationRequested","catch","finally","onfinally","raceCancellation","defaultValue","ref","Throttler","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","onComplete","timeoutDeferred","scheduled","isTriggered","clearTimeout","microtaskDeferred","queueMicrotask","MicrotaskDelay","Delayer","defaultDelay","deferred","completionPromise","doResolve","doReject","task","cancelTimeout","ThrottledDelayer","delayer","throttler","millis","disposableTimeout","timer","promiseFactories","shouldStop","TimeoutTimer","_token","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","isScheduled","schedule","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","freeze","didTimeout","timeRemaining","IdleValue","executor","_didRun","_executor","_error","_handle","isInitialized","DeferredPromise","resolved","completeCallback","errorCallback","isRejected","isSettled","complete","Promises","settled","promises","firstError","withAsyncBody","bodyFn","AsyncIterableObject","_results","_onStateChanged","writer","emitOne","emitMany","iterables","iterable","iterable_1","iterable_1_1","e_1","e_1_1","return","mapFn","e_2","iterable_2_1","iterable_2","e_2_1","filterFn","e_3","iterable_3_1","iterable_3","e_3_1","iterable_4","iterable_4_1","e_4","e_4_1","toPromise","EMPTY","fromArray","hasBuffer","Buffer","textDecoder","VSBuffer","buffer","byteLength","actual","isBuffer","byteOffset","TextDecoder","decode","readUInt16LE","writeUInt16LE","destination","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","shortcutEvent","CancellationToken","isCancellationToken","thing","Cancelled","MutableToken","_isCancelled","_emitter","CancellationTokenSource","_parentListener","getCodiconAriaLabel","codiconName","Codicon","_allCodicons","classNames","cssSelector","CSSIcon","plus","gistNew","repoCreate","lightbulb","lightBulb","repo","repoDelete","gistFork","repoForked","gitPullRequest","gitPullRequestAbandoned","recordKeys","tagAdd","tagRemove","person","personFollow","personOutline","personFilled","gitBranch","gitBranchCreate","gitBranchDelete","sourceControl","mirrorPublic","star","starAdd","starDelete","starEmpty","commentAdd","warning","searchSave","logOut","signOut","logIn","signIn","eye","eyeUnwatch","eyeWatch","circleFilled","primitiveDot","closeDirty","debugBreakpoint","debugBreakpointDisabled","debugHint","primitiveSquare","edit","pencil","info","issueOpened","gistPrivate","gitForkPrivate","lock","mirrorPrivate","close","removeClose","repoSync","sync","desktopDownload","beaker","microscope","vm","deviceDesktop","fileText","more","ellipsis","kebabHorizontal","mailReply","reply","organization","organizationFilled","organizationOutline","newFile","fileAdd","newFolder","fileDirectoryCreate","trash","trashcan","clock","folder","fileDirectory","symbolFolder","logoGithub","markGithub","github","terminal","repl","zap","symbolEvent","variable","symbolVariable","symbolArray","symbolModule","symbolPackage","symbolNamespace","symbolObject","symbolMethod","symbolFunction","symbolConstructor","symbolBoolean","symbolNull","symbolNumeric","symbolNumber","symbolStructure","symbolStruct","symbolParameter","symbolTypeParameter","symbolKey","symbolText","symbolReference","goToFile","symbolEnum","symbolValue","symbolRuler","symbolUnit","activateBreakpoints","archive","arrowBoth","arrowDown","arrowLeft","arrowRight","arrowSmallDown","arrowSmallLeft","arrowSmallRight","arrowSmallUp","arrowUp","bell","bold","book","bookmark","debugBreakpointConditionalUnverified","debugBreakpointConditional","debugBreakpointConditionalDisabled","debugBreakpointDataUnverified","debugBreakpointData","debugBreakpointDataDisabled","debugBreakpointLogUnverified","debugBreakpointLog","debugBreakpointLogDisabled","briefcase","broadcast","browser","bug","calendar","caseSensitive","check","checklist","chevronDown","dropDownButton","chevronLeft","chevronRight","chevronUp","chromeClose","chromeMaximize","chromeMinimize","chromeRestore","circleOutline","debugBreakpointUnverified","circleSlash","circuitBoard","clearAll","clippy","closeAll","cloudDownload","cloudUpload","collapseAll","colorMode","commentDiscussion","compareChanges","creditCard","dash","dashboard","database","debugContinue","debugDisconnect","debugPause","debugRestart","debugStart","debugStepInto","debugStepOut","debugStepOver","debugStop","debug","deviceCameraVideo","deviceCamera","deviceMobile","diffAdded","diffIgnored","diffModified","diffRemoved","diffRenamed","discard","editorLayout","emptyWindow","exclude","extensions","eyeClosed","fileBinary","fileCode","fileMedia","filePdf","fileSubmodule","fileSymlinkDirectory","fileSymlinkFile","fileZip","flame","foldDown","foldUp","fold","folderActive","folderOpened","gear","gift","gistSecret","gist","gitCommit","gitCompare","gitMerge","githubAction","githubAlt","globe","grabber","graph","gripper","heart","home","horizontalRule","hubot","inbox","issueClosed","issueReopened","issues","jersey","json","kebabVertical","law","lightbulbAutofix","linkExternal","link","listOrdered","listUnordered","liveShare","loading","mailRead","mail","megaphone","mention","milestone","mortarBoard","move","multipleWindows","mute","noNewline","note","octoface","openPreview","package_","paintcan","pin","play","plug","preserveCase","preview","project","pulse","question","quote","radioTower","reactions","references","refresh","regex","remoteExplorer","remote","replaceAll","repoClone","repoForcePush","repoPull","repoPush","report","requestChanges","rocket","rootFolderOpened","rootFolder","rss","ruby","saveAll","saveAs","save","screenFull","screenNormal","searchStop","server","settingsGear","settings","shield","smiley","sortPrecedence","splitHorizontal","splitVertical","squirrel","starFull","starHalf","symbolClass","symbolColor","symbolCustomColor","symbolConstant","symbolEnumMember","symbolField","symbolFile","symbolInterface","symbolKeyword","symbolMisc","symbolOperator","symbolProperty","wrench","wrenchSubaction","symbolSnippet","tasklist","telescope","textSize","threeBars","thumbsdown","thumbsup","tools","triangleDown","triangleLeft","triangleRight","triangleUp","twitter","unfold","unlock","unmute","unverified","verified","versions","vmActive","vmOutline","vmRunning","watch","whitespace","wholeWord","zoomIn","zoomOut","listFilter","listFlat","listSelection","listTree","debugBreakpointFunctionUnverified","debugBreakpointFunction","debugBreakpointFunctionDisabled","debugStackframeActive","debugStackframeDot","debugStackframe","debugStackframeFocused","debugBreakpointUnsupported","symbolString","debugReverseContinue","debugStepBack","debugRestartFrame","callIncoming","callOutgoing","menu","expandAll","groupByRefType","ungroupByRefType","account","bellDot","debugConsole","library","output","runAll","syncIgnored","pinned","githubInverted","debugAlt","serverProcess","serverEnvironment","pass","stopCircle","playCircle","record","debugAltSmall","vmConnect","cloud","merge","exportIcon","graphLeft","magnet","notebook","redo","checkAll","pinnedDirty","passFilled","circleLargeFilled","circleLargeOutline","combine","gather","table","variableGroup","typeHierarchy","typeHierarchySub","typeHierarchySuper","gitPullRequestCreate","runAbove","runBelow","notebookTemplate","debugRerun","workspaceTrusted","workspaceUntrusted","workspaceUnspecified","terminalCmd","terminalDebian","terminalLinux","terminalPowershell","terminalTmux","terminalUbuntu","terminalBash","arrowSwap","copy","personAdd","filterFilled","wand","debugLineByLine","inspect","layers","layersDot","layersActive","compass","compassDot","compassActive","azure","issueDraft","gitPullRequestClosed","gitPullRequestDraft","debugAll","debugCoverage","runErrors","folderLibrary","debugContinueSmall","beakerStop","graphLine","graphScatter","pieChart","bracket","bracketDot","bracketError","lockSmall","azureDevops","verifiedFilled","newLine","layoutActivitybarLeft","layoutActivitybarRight","layoutPanelLeft","layoutPanelCenter","layoutPanelJustify","layoutPanelRight","layoutPanel","layoutSidebarLeft","layoutSidebarRight","layoutStatusbar","layoutMenubar","layoutCentered","indent","recordSmall","errorSmall","arrowCircleDown","arrowCircleLeft","arrowCircleRight","arrowCircleUp","dialogError","dialogWarning","dialogInfo","dialogClose","treeItemExpanded","treeFilterOnTypeOn","treeFilterOnTypeOff","treeFilterClear","treeItemLoading","menuSelection","menuSubmenu","menuBarMore","scrollbarButtonLeft","scrollbarButtonRight","scrollbarButtonUp","scrollbarButtonDown","toolBarMore","quickInputBack","iconNameSegment","iconNameExpression","iconModifierExpression","iconNameCharacter","cssIconIdRegex","asClassNameArray","modifier","asClassName","asCSSSelector","SetMap","roundFloat","number","decimalPoints","decimal","RGBA","_rgbaBrand","HSLA","h","_hslaBrand","rgba","chroma","q","hsla","_hue2rgb","HSVA","_hsvaBrand","cmax","cmin","hsva","Color","_hsla","toRGBA","_hsva","hex","Format","CSS","parseHex","red","fromRGBA","getRelativeLuminance","R","_relativeLuminanceForComponent","G","B","luminance","isLighter","yiq","isLighterThan","another","lum1","lum2","isDarkerThan","lighten","factor","darken","opposite","_toString","format","of","relative","white","black","blue","green","cyan","lightgrey","formatRGB","formatRGBA","toFixed","formatHSL","formatHSLA","_toTwoDigitHex","formatHex","formatHexA","compact","_parseHexDigit","memoize","_target","fnKey","memoizeKey","args","configurable","enumerable","writable","DiffChange","originalStart","modifiedStart","modifiedLength","getOriginalEnd","getModifiedEnd","StringDiffSequence","getElements","characters","Int32Array","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","condition","MyArray","sourceArray","sourceIndex","destinationArray","destinationIndex","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","AddOriginalElement","originalIndex","modifiedIndex","AddModifiedElement","getChanges","getReverseChanges","originalSequence","modifiedSequence","continueProcessingPredicate","ContinueProcessingPredicate","_originalSequence","_modifiedSequence","originalStringElements","originalElementsOrHash","originalHasStrings","_getElements","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","sequence","_isStringArray","hashes","ElementsAreEqual","newIndex","ElementsAreStrictEqual","originalElement","_getStrictElement","modifiedElement","getStrictElement","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalEnd","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","Assert","midOriginalArr","midModifiedArr","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","maxDifferences","numDiagonals","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","matchLengthOfLongest","temp","Copy2","change","originalStop","modifiedStop","checkOriginal","checkModified","startStrictEqual","endStrictEqual","mergedChangeArr","ChangesOverlap","prevChange","bestDelta","bestScore","_boundaryScore","touchingPreviousChange","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","_findBetterContiguousSequence","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","_contiguousSequenceScore","_OriginalIsBoundary","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","originalScore","modifiedScore","Copy","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","ErrorHandler","listeners","unexpectedErrorHandler","emit","onUnexpectedError","onUnexpectedExternalError","errorHandler","isCancellationError","transformErrorForSerialization","stacktrace","$isError","canceledName","CancellationError","canceled","illegalArgument","illegalState","NotSupportedError","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","_addLeakageTraceLogic","onListenerDidAdd","origListenerDidAdd","Stacktrace","print","once","thisArgs","didFire","snapshot","each","signal","any","events","initial","Emitter","debounce","leading","leakWarningThreshold","numDebouncedCalls","_output","latch","firstCall","shouldEmit","isT","flushAfterTimeout","_buffer","flush","onFirstListenerDidAdd","ChainableEvent","chain","fromNodeEventEmitter","eventName","removeListener","fromDOMEventEmitter","runAndSubscribe","runAndSubscribeWithStore","store","EventProfiling","_listenerCount","_invocationCount","_elapsedOverall","_name","_idPool","listenerCount","_stopWatch","elapsed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","_warnCountdown","_stacks","threshold","topStack","topCount","Listener","callbackThis","invoke","_disposed","_leakageMon","_perfMon","_profName","_listeners","isset","unset","_deliveryQueue","_event","firstListener","isEmpty","removeMonitor","hasListeners","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","DebounceEmitter","_delay","EventBufferer","buffers","Relay","listening","inputEvent","inputEventListener","isPathSeparator","toSlashes","osPath","toPosixPath","getRoot","path","sep","firstLetter","isWindowsDriveLetter","isEqualOrParent","base","parentCandidate","ignoreCase","beginsWith","sepOffset","charAt","char0","isRootOrDriveLetter","pathNormalized","hasDriveLetter","continueAsWindows","isWindowsPath","or","wordToMatchAgainst","_matchesPrefix","matchesPrefix","matchesContiguousSubString","matchesSubString","_matchesSubString","isLower","isUpper","isNumber","isWhitespace","wordSeparators","isWordSeparator","charactersMatch","codeA","codeB","isAlphanumeric","head","nextAnchor","camelCaseWord","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","matchesCamelCase","matchesWords","contiguous","_matchesWords","nextWord","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","anyScore","pattern","lowPattern","patternPos","lowWord","wordPos","fuzzyScore","createMatches","_maxLen","initTable","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","printTables","patternStart","wordStart","log","isSeparatorAtPos","codePointAt","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","firstMatchCanBeWeak","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","backwardsDiagLength","maxMatchColumn","diagColumn","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2","isDefault","Default","_this","didCall","doHash","hashVal","numberHash","arrayHash","objectHash","stringHash","booleanHash","initialHashVal","leftRotate","bits","totalBits","mask","fill","dest","leftPad","toHexString","bufferOrValue","bitsize","ArrayBuffer","Uint8Array","padStart","StringSHA1","_h0","_h1","_h2","_h3","_h4","_buff","_buffDV","DataView","_buffLen","_totalLen","_leftoverHighSurrogate","_finished","strLen","buff","buffLen","leftoverHighSurrogate","codePoint","nextCharCode","_push","_step","digest","_wrapUp","ml","setUint32","bigBlock32","_bigBlock32","getUint32","f","k","MarkdownString","isTrustedOrOptions","isTrusted","supportThemeIcons","supportHtml","appendText","newlineStyle","escapeMarkdownSyntaxTokens","g1","appendMarkdown","appendCodeblock","langId","isEmptyMarkdownString","oneOrMany","isMarkdownString","every","removeMarkdownEscapes","parseHrefAndDimensions","splitted","parameters","heightFromParams","widthFromParams","widthIsFinite","isFinite","heightIsFinite","iconStartMarker","iconsRegex","iconNameCharacterRegexp","escapeIconsRegex","escapeIcons","markdownEscapedIconsRegex","markdownEscapeEscapedIcons","stripIconsRegex","stripIcons","preWhitespace","postWhitespace","parseLabelWithIcons","firstIconIndex","doParseLabelWithIcons","iconOffsets","textWithoutIcons","appendChars","chars","iconsOffset","nextChar","currentIconStart","currentIconValue","currentIconLength","matchesFuzzyIconAware","wordToMatchAgainstWithoutIconsTrimmed","leadingWhitespaceOffset","iconOffset","IdGenerator","prefix","_prefix","_lastId","nextId","defaultGenerator","Iterable","is","single","some","concatNested","reducer","initialValue","consume","atMost","consumed","at","bt","ai","bi","an","bn","KeyCodeStrMap","_keyCodeToStr","_strToKeyCode","define","keyCodeToStr","strToKeyCode","uiMap","userSettingsUSMap","userSettingsGeneralMap","EVENT_KEY_CODE_MAP","NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE","scanCodeIntToStr","scanCodeStrToInt","scanCodeLowerCaseStrToInt","IMMUTABLE_CODE_TO_KEY_CODE","IMMUTABLE_KEY_CODE_TO_CODE","KeyCodeUtils","KeyChord","firstPart","secondPart","chordPart","mappings","seenKeyCode","seenScanCode","mapping","_keyCodeOrd","immutable","scanCode","scanCodeStr","keyCodeStr","eventKeyCode","vkey","usUserSettingsLabel","generalUserSettingsLabel","fromString","toUserSettingsUS","toUserSettingsGeneral","fromUserSettings","toElectronAccelerator","ModifierLabelProvider","mac","windows","linux","modifierLabels","toLabel","OS","parts","keyLabelProvider","part","keyLabel","_simpleAsString","UILabelProvider","AriaLabelProvider","ElectronAcceleratorLabelProvider","modifiers","createKeybinding","ChordKeybinding","createSimpleKeybinding","ctrlCmd","winCtrl","SimpleKeybinding","isModifierKey","toChord","isDuplicateModifierCase","ResolvedKeybindingPart","kbLabel","kbAriaLabel","keyAriaLabel","ResolvedKeybinding","getBaseLabel","resource","scheme","fsPath","normalizeDriveLetter","TRACK_DISPOSABLES","disposableTracker","setDisposableTracker","tracker","__is_disposable_tracked__","trackDisposable","setParent","Disposable","markAsDisposed","markAsSingleton","setParentOfDisposable","setParentOfDisposables","singleton","MultiDisposeError","errors","isDisposable","combinedDisposable","toDisposable","DisposableStore","_toDispose","_isDisposed","DISABLE_DISPOSED_WARNING","_store","MutableDisposable","clearAndLeak","oldValue","SafeDisposable","ImmortalReference","object","Undefined","prev","LinkedList","_first","_last","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","StringIterator","_pos","hasNext","cmp","aCode","thisCode","ConfigKeysIterator","_caseSensitive","_from","_to","justSeps","ch","PathIterator","_splitOnBackslash","_valueLen","UriIterator","_ignorePathCasing","_states","_stateIdx","authority","_pathIterator","fragment","TernarySearchTreeNode","rotateLeft","tmp","updateHeight","rotateRight","heightLeft","heightRight","balanceFactor","TernarySearchTree","segments","_iter","ignorePathCasing","_root","iter","segment","oldElement","bf","d1","d2","_getNode","_delete","deleteSuperstr","superStr","_min","newChild","dir","findSubstr","findSuperstr","_entries","ResourceMapEntry","ResourceMap","mapOrKeyFn","toKey","defaultToKey","clb","toStringTag","LinkedMap","_map","_head","_tail","addItemLast","addItemFirst","removeItem","callbackfn","entries","trimOld","currentSize","toJSON","fromJSON","LRUCache","ratio","_ratio","checkTrim","JSON","revive","depth","$mid","flags","Mimes","binary","unknown","latex","uriList","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","mailto","untitled","command","vscodeRemote","vscodeRemoteResource","userData","vscodeCustomEditor","vscodeNotebook","vscodeNotebookCell","vscodeNotebookCellMetadata","vscodeNotebookCellOutput","vscodeInteractive","vscodeInteractiveInput","vscodeSettings","vscodeWorkspaceTrust","vscodeTerminal","webviewPanel","vscodeWebview","extension","vscodeFileResource","vsls","connectionTokenQueryName","RemoteAuthoritiesImpl","_hosts","_ports","_connectionTokens","_preferredWebSchema","_delegate","setPreferredWebSchema","schema","rewrite","port","connectionToken","encodeURIComponent","RemoteAuthorities","FileAccessImpl","asBrowserUri","uriOrModule","moduleIdToUrl","toUri","FALLBACK_AUTHORITY","toUrl","FileAccess","clamp","MovingAverage","_n","_val","SlidingWindowAverage","_values","_index","_sum","deepClone","deepFreeze","_hasOwnProperty","prop","isFrozen","cloneAndChange","changer","_cloneAndChange","changed","r1","r2","i2","mixin","overwrite","oneKeys","otherKeys","getOrDefault","safeProcess","sandboxProcess","arch","env","cwd","process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","expected","determiner","validateString","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","allowAboveRoot","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","_format","pathObject","ext","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","rootEnd","device","isAbsolute","normalize","joined","needsReplace","slashCount","firstLen","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","toNamespacedPath","resolvedPath","dirname","matchedSlash","basename","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","delimiter","posix","trailingSeparator","hasRoot","LANGUAGE_DEFAULT","_locale","_userAgent","_isWindows","_isMacintosh","_isLinux","_isLinuxSnap","_isNative","_isWeb","_isElectron","_isIOS","_isCI","_language","_translationsConfigFile","globals","nodeProcess","isElectronProcess","electron","isElectronRenderer","rawNlsConfig","nlsConfig","availableLanguages","locale","language","_platform","isWindows","isMacintosh","isLinux","isNative","isWeb","isWebWorker","importScripts","isIOS","setTimeout0","postMessage","pending","vscodeScheduleAsyncWork","lastId","myId","_isLittleEndian","_isLittleEndianComputed","isLittleEndian","Uint16Array","isEdge","Range","intersect","intersects","second","originalFSPath","ExtUri","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","isEqualAuthority","joinPath","pathFragment","basenameOrAuthority","normalizePath","normalizedPath","relativePath","fromPath","toPath","resolvePath","newURI","isAbsolutePath","a1","a2","hasTrailingPathSeparator","fsp","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","DataUri","parseMetaData","dataUri","metadata","meta","property","mime","META_DATA_MIME","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","ScrollState","_forceIntegerValues","_scrollStateBrand","rawScrollLeft","rawScrollTop","withScrollDimensions","useRawScrollPositions","withScrollPosition","createScrollEvent","widthChanged","scrollWidthChanged","heightChanged","scrollHeightChanged","oldWidth","oldScrollWidth","oldScrollLeft","oldHeight","oldScrollHeight","oldScrollTop","Scrollable","_scrollableBrand","_smoothScrollDuration","_scheduleAtNextAnimationFrame","_smoothScrolling","_setState","Boolean","acceptScrollDimensions","validTarget","newSmoothScrolling","SmoothScrollingOperation","startTime","duration","animationFrameDisposable","_performSmoothScrolling","tick","isDone","oldState","SmoothScrollingUpdate","createEaseOutCubic","completion","easeOutCubic","createComposed","cut","_initAnimations","_initAnimation","viewportSize","stop1","stop2","_tick","newScrollLeft","easeInCubic","Severity","_warning","_warn","_info","_ignore","fromValue","Warning","Info","Ignore","severity","hasPerformanceNow","StopWatch","highResolution","_highResolution","_startTime","_now","_stopTime","LRUCachedComputed","computeFn","lastCache","lastArgKey","stringify","Lazy","getValue","rawValue","isFalsyOrWhitespace","_formatRegexp","html","escapeRegExpCharacters","haystack","needle","trimmed","ltrim","rtrim","needleLen","haystackLen","convertSimple2RegExpPattern","stripWildcards","createRegExp","searchString","isRegex","global","matchCase","multiline","unicode","regExpLeadsToEndlessLoop","regExpFlags","splitLines","firstNonWhitespaceIndex","getLeadingWhitespace","lastNonWhitespaceIndex","compareSubstring","aStart","aEnd","bStart","bEnd","aLen","bLen","compareIgnoreCase","compareSubstringIgnoreCase","isLowerAsciiLetter","isUpperAsciiLetter","equalsIgnoreCase","startsWithIgnoreCase","candidateLength","commonPrefixLength","commonSuffixLength","aLastIndex","bLastIndex","isHighSurrogate","isLowSurrogate","computeCodePoint","highSurrogate","lowSurrogate","getNextCodePoint","getPrevCodePoint","prevCharCode","CodePointIterator","_str","_len","_offset","setOffset","prevCodePoint","nextCodePoint","eol","GraphemeIterator","_iterator","nextGraphemeLength","graphemeBreakTree","GraphemeBreakTree","getInstance","initialOffset","graphemeBreakType","getGraphemeBreakType","nextGraphemeBreakType","breakBetweenGraphemeBreakType","prevGraphemeLength","prevGraphemeBreakType","nextCharLength","prevCharLength","getCharContainingOffset","endOffset","startOffset","CONTAINS_RTL","containsRTL","IS_BASIC_ASCII","isBasicASCII","UNUSUAL_LINE_TERMINATORS","containsUnusualLineTerminators","isFullWidthCharacter","isEmojiImprecise","UTF8_BOM_CHARACTER","startsWithUTF8BOM","containsUppercaseCharacter","ignoreEscapedChars","singleLetterHash","LETTERS_CNT","breakTypeA","breakTypeB","_data","getGraphemeBreakRawData","_INSTANCE","nodeCount","nodeIndex","getLeftDeleteOffset","emojiOffset","getOffsetBeforeLastEmojiComponent","isEmojiModifier","resultOffset","optionalZwjCodePoint","AmbiguousCharacters","confusableDictionary","locales","_locales","isAmbiguous","getPrimaryConfusable","getConfusableCodePoints","ambiguousCharacterData","arrayToMap","mergeMaps","map1","map2","intersectMaps","languageSpecificMap","filteredLocales","startsWith","commonMap","InvisibleCharacters","getRawData","codePoints","isString","isObject","isIterable","isBoolean","isUndefined","isDefined","isUndefinedOrNull","assertType","assertIsDefined","isFunction","validateConstraints","constraints","validateConstraint","constraint","getAllPropertyNames","proto","getPrototypeOf","getOwnPropertyNames","getAllMethodNames","methods","createProxyObject","methodNames","createProxyMethod","method","methodName","withNullAsUndefined","assertNever","toUint8","toUint32","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","_schemeFix","_referenceResolution","_slash","_regexp","URI","schemeOrData","uriToFsPath","Uri","percentDecode","components","newPath","skipEncoding","_asFormatted","_formatted","external","_fsPath","_sep","_pathSepMarker","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","encodeURIComponentMinimal","keepDriveLetterCasing","encoder","userinfo","decodeURIComponentGraceful","decodeURIComponent","_rEncodedAsHex","NO_KEY_MODS","QuickInputHideReason","ItemActivation","QuickPickItemScorerAccessor","__defProp","__getOwnPropDesc","__getOwnPropNames","__hasOwnProp","__reExport","copyDefault","monaco_editor_core_exports","languageDefinitions","lazyLanguageLoaders","LazyLanguageLoader","_languageId","_loadingTriggered","_lazyLoadPromise","_lazyLoadPromiseResolve","_lazyLoadPromiseReject","load","loader","mod","registerLanguage","register","lazyLanguageLoader","getOrCreate","registerTokensProviderFactory","onLanguage","setLanguageConfiguration","conf","aliases","applyFontInfo","fontInfo","getMassagedFontFamily","ElementSizeObserver","referenceDomElement","dimension","_referenceDomElement","_resizeObserver","measureReferenceDomElement","stopObserving","getWidth","startObserving","ResizeObserver","contentRect","emitEvent","observedWidth","observedHeight","CharWidthRequest","chr","fulfill","DomCharWidthReader","bareFontInfo","requests","_bareFontInfo","_requests","_container","_testElements","read","_createDomElements","_readFromDomElements","regularDomNode","boldDomNode","italicDomNode","testElements","request","testElement","htmlString","testString","readCharWidths","reader","FontMeasurementsImpl","_cache","FontMeasurementsCache","_evictUntrustedReadingsTimeout","clearAllFontInfos","_writeToCache","put","_evictUntrustedReadings","getValues","somethingRemoved","readFontInfo","readConfig","_actualReadFontInfo","typicalHalfwidthCharacterWidth","typicalFullwidthCharacterWidth","spaceWidth","maxDigitWidth","pixelRatio","isMonospace","canUseHalfwidthRightwardsArrow","middotWidth","wsmiddotWidth","_createRequest","monospace","typicalHalfwidthCharacter","typicalFullwidthCharacter","space","digit0","digit1","digit2","digit3","digit4","digit5","digit6","digit7","digit8","digit9","rightwardsArrow","halfwidthRightwardsArrow","middot","monospaceTestChars","referenceWidth","_keys","FontMeasurements","TabFocusImpl","_tabFocus","_onDidChangeTabFocus","onDidChangeTabFocus","getTabFocusMode","setTabFocusMode","tabFocusMode","TabFocus","TextAreaSyntethicEvents","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","_lastState","lastCopiedValue","pastedText","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","TextAreaInput","_textArea","_OS","_browser","_onFocus","_onBlur","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncTriggerCut","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","_selectionChangeListener","_hasFocus","_currentComposition","lastKeyDown","currentComposition","setIgnoreSelectionChangeTime","_ensureClipboardGetsEditorSelection","onCopy","clipboardData","ClipboardEventUtils","getTextData","hadFocus","_setHasFocus","onSyntheticTap","_installSelectionChangeListener","previousSelectionChangeEventTime","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selectionStartPosition","selectionEndPosition","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","lineNumber","focusTextArea","refreshFocusState","isFocused","newHasFocus","_setAndWriteTextAreaState","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","setTextData","rawmetadata","TextAreaWrapper","_actual","_onSyntheticTap","_ignoreSelectionChangeTime","setValue","textArea","selectionDirection","currentIsFocused","currentSelectionStart","currentSelectionEnd","_debugComposition","TextAreaState","_finishDeduceEditorPosition","str1","str2","deltaText","signum","lineFeedCnt","lastLineFeedIndex","previousState","currentState","couldBeEmojiInput","prefixLength","suffixLength","previousValue","previousSelectionStart","previousSelectionEnd","replacePreviousCharacters","PagedScreenReaderStrategy","linesPerPage","page","startLineNumber","endLineNumber","model","trimLongText","selectionStartPage","_getPageOfLine","selectionStartPageRange","_getRangeForPage","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS","ColumnSelection","config","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","lineCount","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleColumnFromColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","toViewVisualColumn","columnSelect","fromViewLineNumber","fromViewVisualColumn","toViewLineNumber","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","CORE_WEIGHT","CoreEditorCommand","runEditorCommand","accessor","viewModel","_getViewModel","runCoreEditorCommand","EditorScroll_","RevealLine_","CoreNavigationCommands","isEditorScrollArgs","scrollArg","revealCursor","unit","RawDirection","Up","Down","RawUnit","Line","WrappedLine","Page","HalfPage","isRevealLineArgs","reveaLineArg","RawAtArgument","Top","Center","Bottom","EditorOrNativeTextInputCommand","addImplementation","focusedEditor","getFocusedCodeEditor","hasTextFocus","_runEditorCommand","runDOMCommand","activeEditor","getActiveCodeEditor","BaseMoveToCommand","_minimalReveal","minimalReveal","_inSelectionMode","inSelectionMode","pushStackElement","cursorStateChanged","setCursorStates","getPrimaryCursorState","viewPosition","revealPrimaryCursor","MoveTo","precondition","MoveToSelect","ColumnSelectCommand","_getColumnSelectResult","getCursorColumnSelectData","viewState","setCursorColumnSelectData","isReal","revealTopMostCursor","revealBottomMostCursor","ColumnSelect","primary","validatedPosition","validatePosition","validatedViewPosition","coordinatesConverter","validateViewPosition","doColumnSelect","mouseColumn","cursorConfig","CursorColumnSelectLeft","kbOpts","weight","kbExpr","columnSelectLeft","CursorColumnSelectRight","columnSelectRight","ColumnSelectUpCommand","_isPaged","columnSelectUp","CursorColumnSelectUp","CursorColumnSelectPageUp","ColumnSelectDownCommand","columnSelectDown","CursorColumnSelectDown","CursorColumnSelectPageDown","CursorMoveImpl","parsed","_runCursorMove","_move","getCursorStates","cursors","CursorMove","CursorMoveBasedCommand","_staticArgs","dynamicArgs","CursorLeft","secondary","CursorLeftSelect","CursorRight","CursorRightSelect","CursorUp","CursorUpSelect","CursorPageUp","CursorPageUpSelect","CursorDown","CursorDownSelect","CursorPageDown","CursorPageDownSelect","CreateCursor","wholeLine","states","newModelPosition","modelState","newViewPosition","containsPosition","LastCursorMoveToSelect","lastAddedCursorIndex","getLastAddedCursorIndex","newStates","HomeCommand","CursorHome","CursorHomeSelect","LineStartCommand","_exec","CursorLineStart","CursorLineStartSelect","EndCommand","sticky","CursorEnd","properties","default","CursorEndSelect","LineEndCommand","CursorLineEnd","CursorLineEndSelect","TopCommand","CursorTop","CursorTopSelect","BottomCommand","CursorBottom","CursorBottomSelect","EditorScrollImpl","_runEditorScroll","_computeDesiredScrollTop","desiredVisibleViewRange","getCompletelyVisibleViewRangeAtScrollTop","viewLayout","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","convertViewRangeToModelRange","desiredTopModelLineNumber","convertModelPositionToViewPosition","getVerticalOffsetForLineNumber","noOfLines","deltaLines","getCurrentScrollTop","EditorScroll","ScrollLineUp","ScrollPageUp","win","ScrollLineDown","ScrollPageDown","WordCommand","WordSelect","WordSelectDrag","LastCursorWordSelect","lastAddedState","hasSelection","LineCommand","LineSelect","LineSelectDrag","LastCursorLineCommand","LastCursorLineSelect","LastCursorLineSelectDrag","CancelSelection","RemoveSecondaryCursors","RevealLine","revealLineArg","lineNumberArg","revealAt","viewRange","convertModelRangeToViewRange","revealRange","SelectAll","execCommand","SetSelection","columnSelectionCondition","registerColumnSelection","when","registerCommand","CoreEditingCommands","CoreEditingCommand","runCoreEditingCommand","LineBreakInsert","pushUndoStop","executeCommands","Outdent","Tab","DeleteLeft","shouldPushStackElementBefore","commands","getPrevEditOperationType","getCursorAutoClosedCharacters","setPrevEditOperationType","DeleteRight","Undo","hasModel","getOption","getModel","undo","Redo","EditorHandlerCommand","handlerId","_handlerId","runCommand","registerOverwritableCommand","isCodeEditor","getEditorType","isDiffEditor","getCodeEditor","getModifiedEditor","PageCoordinates","_pageCoordinatesBrand","toClientCoordinates","ClientCoordinates","_clientCoordinatesBrand","toPageCoordinates","EditorPagePosition","_editorPagePositionBrand","CoordinatesRelativeToEditor","_positionRelativeToEditorBrand","createEditorPagePosition","editorViewDomNode","editorPos","createCoordinatesRelativeToEditor","editorPagePosition","scaleX","scaleY","relativeX","relativeY","EditorMouseEvent","_editorMouseEventBrand","relativePos","EditorMouseEventFactory","_editorViewDomNode","_create","onMouseUp","onMouseMoveThrottled","merger","myMerger","EditorPointerEventFactory","onPointerDown","onPointerLeave","onPointerMoveThrottled","GlobalEditorMouseMoveMonitor","_globalMouseMoveMonitor","_keydownListener","kb","DynamicCssRules","_editor","_instanceId","_counter","_rules","_garbageCollectionScheduler","garbageCollect","createClassNameRef","getOrCreateRule","increaseRefCount","decreaseRefCount","computeUniqueKey","existingRule","counter","RefCountedCssRule","getContainerDomNode","hasReferences","_containerElement","_referenceCount","_styleElement","getCssText","cssValue","cssPropName","camelToDashes","letter","EditorExtensionsRegistry","Command","_kbOpts","_menuOpts","menuOpts","_description","_registerMenuItem","kbOptsArr","kbWhen","menuId","order","MultiCommand","_implementations","implementation","logService","trace","impl","ProxyCommand","EditorCommand","controllerGetter","_callback","controller","codeEditorService","invokeWithinContext","editorAccessor","kbService","contextMatchesRules","EditorAction","convertOptions","alias","withDefaults","contextMenuOpts","reportTelemetry","publicLog2","MultiEditorAction","registerModelAndPositionCommand","instaService","editorPosition","invokeFunction","createModelReference","reference","textEditorModel","registerEditorCommand","editorCommand","EditorContributionRegistry","registerEditorAction","ctor","registerMultiEditorAction","registerInstantiatedEditorAction","editorAction","registerEditorContribution","getEditorCommand","commandId","getEditorActions","getEditorContributions","getSomeEditorContributions","ids","getDiffEditorContributions","Extensions","EditorCommonContributions","editorContributions","diffEditorContributions","editorActions","editorCommands","UndoCommand","RedoCommand","SelectAllCommand","IBulkEditService","isWorkspaceFileEdit","newUri","oldUri","isWorkspaceTextEdit","ResourceEdit","edits","ResourceTextEdit","modelVersionId","ResourceFileEdit","textEdit","versionId","oldResource","newResource","ICodeEditorService","StableEditorScrollState","_visiblePosition","_visiblePositionScrollDelta","_cursorPosition","visiblePosition","visiblePositionScrollDelta","visibleRanges","getVisibleRanges","getStartPosition","visiblePositionScrollTop","getTopForPosition","getPosition","restore","restoreRelativeVerticalPositionOfCursor","currentCursorPosition","getTopForLineNumber","__param","paramIndex","decorator","MarkerDecorationsContribution","_markerDecorationsService","migrateOptions","lineNumbers","autoClosingBrackets","autoClosingQuotes","autoSurround","cursorBlinking","renderWhitespace","renderLineHighlight","acceptSuggestionOnEnter","tabCompletion","suggest","filteredTypes","parameterHints","autoIndent","matchBrackets","renderIndentGuides","highlightActiveIndentGuide","guides","indentation","highlightActiveIndentation","EditorConfiguration","isSimpleWidget","_accessibilityService","_onDidChangeFast","onDidChangeFast","_isDominatedByLongLines","_viewLineCount","_lineNumbersDigitCount","_reservedHeight","_computeOptionsMemory","_containerObserver","_rawOptions","deepCloneAndMigrateOptions","_validatedOptions","EditorOptionsUtil","validateOptions","_computeOptions","_recomputeOptions","onDidChangeScreenReaderOptimized","changeEvent","checkEquals","partialEnv","_readEnvConfiguration","_readFontInfo","memory","outerWidth","outerHeight","extraEditorClassName","isDominatedByLongLines","viewLineCount","lineNumbersDigitCount","emptySelectionClipboard","accessibilitySupport","computeOptions","getExtraEditorClassName","isScreenReaderOptimized","getAccessibilitySupport","getRawOptions","_newOptions","applyUpdate","observeContainer","setIsDominatedByLongLines","setModelLineCount","modelLineCount","digitCount","setViewLineCount","setReservedHeight","reservedHeight","ValidatedEditorOptions","_read","option","_write","ComputedEditorOptions","editorOption","editorOptions","compute","arrays","_deepEquals","somethingChanged","objects","ViewEventHandler","shouldRender","forceShouldRender","setShouldRender","onDidRender","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onThemeChanged","onTokensChanged","onTokensColorsChanged","onZonesChanged","handleEvents","ViewPart","addEventHandler","removeEventHandler","PartFingerprints","partId","stopAt","resultLen","RestrictedRenderingContext","viewportData","_restrictedRenderingContextBrand","_viewLayout","getScrollWidth","getScrollHeight","visibleRange","bigNumbersDelta","vInfo","getCurrentViewport","viewportWidth","viewportHeight","getScrolledTopFromAbsoluteTop","absoluteTop","getDecorationsInViewport","RenderingContext","viewLines","_renderingContextBrand","_viewLines","linesVisibleRangesForRange","includeNewLines","visibleRangeForPosition","LineVisibleRanges","outsideRenderedLine","HorizontalRange","_horizontalRangeBrand","FloatHorizontalRange","_floatHorizontalRangeBrand","HorizontalPosition","originalLeft","VisibleRanges","RangeUtil","_handyReadyRange","createRange","endNode","selectNodeContents","startElement","endElement","_createRange","setStart","setEnd","_detachRange","clientRects","clientRectDeltaLeft","clientRectScale","clientRect","_mergeAdjacentRanges","startChildIndex","endChildIndex","_createHorizontalRangesFromClientRects","_readClientRects","canUseFastRenderedViewLine","monospaceAssumptionsAreValid","DomReadingContext","_clientRectDeltaLeft","_clientRectScale","_clientRectRead","readClientRect","rect","ViewLineOptions","themeType","renderControlCharacters","useMonospaceOptimizations","stopRenderingLineAfter","fontLigatures","ViewLine","_isMaybeInvalid","_renderedViewLine","onContentChanged","onOptionsChanged","onSelectionChanged","renderLine","deltaTop","sb","lineData","getViewLineRenderingData","actualInlineDecorations","inlineDecorations","minColumn","selectionsOnLine","selections","renderLineInput","continuesWithWrappedLine","tabSize","startVisibleColumn","appendASCIIString","CLASS_NAME","renderedViewLine","containsForeignElements","lineTokens","getCount","FastRenderedViewLine","characterMapping","createRenderedLine","layoutLine","getWidthIsFast","needsMonospaceFontCheck","onMonospaceAssumptionsInvalidated","toSlowRenderedLine","getVisibleRangesForRange","lineContent","horizontalRanges","getColumnOfNodeOffset","spanNode","_characterMapping","_charWidth","_getCharPosition","expectedWidth","actualWidth","startPosition","endPosition","charOffset","getAbsoluteOffset","spanNodeTextContentLength","spanIndex","previousSibling","getColumn","RenderedViewLine","_isWhitespaceOnly","_containsForeignElements","_cachedWidth","_pixelOffsetCache","Float32Array","_getReadingTarget","myDomNode","_readPixelOffset","_readVisibleRangesForRange","pixelOffset","_readRawVisibleRangesForRange","readingTarget","cachedPixelOffset","_actualReadPixelOffset","readHorizontalRanges","domPosition","getDomPosition","partIndex","charIndex","expectedResult","startDomPosition","endDomPosition","WebKitRenderedViewLine","endPixelOffset","createWebKitRenderedLine","createNormalRenderedLine","HitTestResult","UnknownHitTestResult","hitTarget","ContentHitTestResult","injectedText","createFromDOMInfo","getPositionFromDOMInfo","PointerHandlerLastRenderData","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","_deduceRage","_typeToString","ElementPath","HitTestContext","viewHelper","lastRenderData","configuration","layoutInfo","viewDomNode","stickyTabStops","_viewHelper","getZoneAtCoord","mouseVerticalOffset","viewZoneWhitespace","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","positionBefore","positionAfter","afterLineNumber","viewZoneId","getFullLineRangeAtCoord","isAfterLines","maxLineColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","findAttribute","attr","_findAttribute","getLineWidth","getCurrentScrollLeft","BareHitTestRequest","mouseContentHorizontalOffset","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_ctx","targetPath","collect","outerHTML","getLineContent","getOptions","fulfillUnknown","createUnknown","fulfillTextarea","createTextarea","fulfillMargin","createMargin","fulfillViewZone","createViewZone","fulfillContentText","createContentText","fulfillContentEmpty","createContentEmpty","fulfillContentWidget","createContentWidget","fulfillScrollbar","createScrollbar","fulfillOverlayWidget","createOverlayWidget","withTarget","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","mouseTargetIsWidget","isChildOfContentWidgets","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","createMouseTarget","_createMouseTarget","domHitTestExecuted","hitTestResult","_doHitTest","createMouseTargetFromHitTestPosition","resolvedRequest","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","mightBeForeignElement","cursorVerticalOffset","viewZoneData","mouseTargetType","isTextArea","glyphMarginWidth","lineNumbersWidth","isChildOfViewLines","isStrictChildOfViewLines","getLineLength","lineWidth","isChildOfMinimap","possibleLineNumber","isChildOfScrollableElement","getMouseColumn","columnHorizontalOffset","points","lineMaxColumn","mouseCoordinates","spanNodeClientRect","mouseIsOverSpanNode","curr","rng","lineVerticalOffset","lineCenteredVerticalOffset","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","coords","caretRangeFromPoint","shadowCaretRangeFromPoint","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","parent2ClassName","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","newPosition","_doHitTestWithCaretRangeFromPoint","_doHitTestWithCaretPositionFromPoint","getInjectedTextAt","normalizedPosition","normalizePosition","_snapToSoftTabBoundary","elementFromPoint","lastChild","font","pixelCursor","charWidthReader","CharWidthReader","getCharWidth","_canvas","cacheKey","metrics","measureText","createMouseMoveEventMerger","mouseTargetFactory","targetIsWidget","MouseHandler","viewController","_mouseDownOperation","MouseDownOperation","testEventTarget","lastMouseLeaveTime","mouseEvents","_onContextMenu","_onMouseMove","MOUSE_MOVE_MINIMUM_TIME","_onMouseUp","_onMouseLeave","emitMouseWheel","doMouseWheelZoom","zoomLevel","capture","hasChanged","onHeightChanged","getTargetAtClientPoint","clientPos","getLastRenderData","elementsFromPoint","emitContextMenu","isActive","actualMouseMoveTime","emitMouseMove","emitMouseLeave","emitMouseUp","targetIsContent","targetIsGutter","targetIsLineNumbers","selectOnLineNumbers","targetIsViewZone","shouldHandle","shouldSuppressMouseDownOnViewZone","shouldSuppressMouseDownOnWidget","emitMouseDown","_viewController","_onScrollTimeout","_mouseState","MouseDownState","_currentSelection","_isActive","_lastMouseEvent","_onMouseDownThenMove","setModifiers","_findMousePosition","isDragAndDrop","emitMouseDrag","_dispatchMouse","targetType","setStartedOnLineNumbers","setStartButtons","trySetCount","KeyboardEvent","emitMouseDropCanceled","emitMouseDrop","_stop","_getPositionOutsideEditor","editorContent","_helpPositionJumpOverViewZone","createOutsideEditor","aboveLineNumber","belowLineNumber","positionOutsideEditor","hintedPosition","selectionStartLineNumber","selectionStartColumn","isBefore","dispatchMouse","startedOnLineNumbers","mouseDownCount","onInjectedText","_altKey","_ctrlKey","_metaKey","_shiftKey","_leftButton","_middleButton","_startedOnLineNumbers","_lastMouseDownPosition","_lastMouseDownPositionEqualCount","_lastMouseDownCount","_lastSetMouseDownCountTime","setMouseDownCount","newMouseDownPosition","CLEAR_MOUSE_DOWN_COUNT_TIME","PointerEventHandler","linesContentDomNode","_lastPointerType","pointerType","deltaScrollNow","TouchHandler","dispatchTextAreaEvent","moveTo","PointerHandler","TouchEvent","DynamicViewOverlay","LineNumbersOverlay","_readConfig","_lastCursorModelPosition","_renderResult","_activeLineNumber","_renderLineNumbers","renderType","_renderCustomLineNumbers","renderFn","_renderFinalNewline","_lineNumbersLeft","lineNumbersLeft","_lineNumbersWidth","primaryViewPosition","convertViewPositionToModelPosition","_getLineRenderLineNumber","viewLineNumber","modelPosition","modelLineNumber","prepareRender","lineHeightClassName","visibleStartLineNumber","visibleEndLineNumber","common","lineIndex","renderLineNumber","theme","collector","getColor","addRule","activeLineNumber","Margin","_canUseLayerHinting","_contentLeft","_glyphMarginLeft","_glyphMarginWidth","OUTER_CLASS_NAME","_glyphMarginBackgroundDomNode","adjustedScrollTop","VisibleTextAreaData","distanceToModelLineStart","widthOfHiddenLineTextBefore","distanceToModelLineEnd","_visibleTextAreaBrand","visibleTextareaStart","visibleTextareaEnd","_previousPresentation","visibleRangeProvider","startModelPosition","endModelPosition","definePresentation","tokenPresentation","underline","canUseZeroSizeTextarea","TextAreaHandler","_primaryCursorPosition","_primaryCursorVisibleRange","_visibleRangeProvider","_scrollLeft","_scrollTop","_setAccessibilityOptions","_contentWidth","contentWidth","_contentHeight","_fontInfo","_emptySelectionClipboard","_copyWithSyntaxHighlighting","_visibleTextArea","_selections","_modelSelections","_lastRenderPosition","write","_getAriaLabel","textAreaCover","simpleModel","textAreaInputHost","rawTextToCopy","getPlainTextToCopy","newLineCharacter","getEOL","richText","getRichTextToCopy","_accessibilitySupport","textBefore","_getWordBeforePosition","_getCharacterBeforePosition","wordAtPosition","positionOffsetInWord","_getAndroidWordAtPosition","_accessibilityPageSize","viewAnchorPosition","deltaOffset","deduceModelPositionRelativeToViewPosition","textAreaWrapper","_textAreaInput","emitKeyDown","emitKeyUp","pasteOnNewLine","paste","compositionType","modelSelection","ta","widthOfHiddenTextBefore","textBeforeSelection","lineFeedOffset1","lineTextBeforeSelection","tabOffset1","desiredVisibleBeforeCharCount","visibleBeforeCharCount","hiddenLineTextBefore","textAfterSelection","lineFeedOffset2","lineTextAfterSelection","tabOffset2","desiredVisibleAfterCharCount","getEndPosition","visibleAfterCharCount","compositionStart","compositionEnd","setHasFocus","ANDROID_WORD_SEPARATORS","goingLeft","goingRight","distance","charClass","charBefore","strings","accessibilityPageSize","modelSelections","setAriaOptions","activeDescendant","positionLineNumber","positionColumn","visibleStart","visibleEnd","_newlinecount","viewLineData","getViewLineData","startTokenIndex","findTokenIndexAtOffset","endTokenIndex","textareaSpansSingleToken","presentation","getPresentation","_doRender","lastRenderPosition","useCover","_renderAtTopLeft","renderData","tac","ViewController","userInputEvents","commandDelegate","startComposition","endComposition","_validateViewColumn","getLineMinColumn","_hasMulticursorModifier","_hasNonMulticursorModifier","selectionClipboardIsOn","columnSelection","_columnSelect","_lastCursorLineSelect","_createCursor","_lineSelectDrag","_lineSelect","_selectAll","_lastCursorLineSelectDrag","_lastCursorWordSelect","_wordSelectDrag","_wordSelect","_lastCursorMoveToSelect","_moveToSelect","_usualArgs","_convertViewToModelPosition","ViewUserInputEvents","onMouseDrag","onMouseDrop","onMouseDropCanceled","_coordinatesConverter","_convertViewToModelMouseEvent","_convertViewToModelMouseTarget","convertViewToModelMouseTarget","RenderedLinesCollection","createLine","_createLine","rendLineNumberStart","lines","_lines","_rendLineNumberStart","_get","getStartLineNumber","getEndLineNumber","getLine","deleteFromLineNumber","deleteToLineNumber","deleteCnt","deleteStartIndex","deleteAboveCount","changeFromLineNumber","changeToLineNumber","someoneNotified","changedLineNumber","insertFromLineNumber","insertToLineNumber","insertCnt","newLines","beforeLines","afterLines","deletedLines","notifiedSomeone","VisibleLinesCollection","_createDomNode","_linesCollection","createVisibleLine","lineDomNode","getVisibleLine","renderLines","inp","ViewLayerRenderer","linesLength","resCtx","relativeVerticalOffset","inContext","stopLineNumber","_finishRendering","_renderUntouchedLines","_insertLinesBefore","removeCnt","_removeLinesBefore","_insertLinesAfter","_removeLinesAfter","endIndex","deltaLN","newLinesLen","removeCount","removeIndex","_finishRenderingNewLines","domNodeIsEmpty","newLinesHTML","wasNew","_ttPolicy","createHTML","innerHTML","insertAdjacentHTML","currChild","_finishRenderingInvalidLines","invalidLinesHTML","wasInvalid","hugeDomNode","replaceChild","_sb","hadNewLine","renderResult","build","hadInvalidLine","trustedTypes","createPolicy","ViewOverlays","_visibleLines","_dynamicOverlays","_isFocused","dynamicOverlay","ViewOverlayLine","addDynamicOverlay","overlay","_viewOverlaysRender","dynamicOverlays","_configuration","_renderedContent","ContentViewOverlays","MarginViewOverlays","Coordinate","_coordinateBrand","ViewContentWidgets","_viewDomNode","_widgets","overflowingContentWidgetsDomNode","addWidget","_widget","myWidget","allowEditorOverflow","setWidgetPosition","widget","preference","removeWidget","suppressMouseDown","onBeforeRender","_fixedOverflowWidgets","_range","_viewRange","_preference","_cachedDomNodeOffsetWidth","_cachedDomNodeOffsetHeight","_getMaxWidth","_renderData","_setPosition","validModelRange","validateRange","modelPositionIsVisible","_layoutBoxInViewport","topLeft","bottomLeft","aboveLineTop","heightAboveLine","underLineTop","heightUnderLine","aboveTop","fitsAbove","belowTop","fitsBelow","actualAboveLeft","actualBelowLeft","aboveLeft","belowLeft","_layoutHorizontalSegmentInPage","windowSize","MIN_LIMIT","MAX_LIMIT","absoluteLeft","_layoutBoxInPage","absoluteAboveTop","absoluteBelowTop","absoluteAboveLeft","absoluteBelowLeft","TOP_PADDING","BOTTOM_PADDING","_prepareRenderWidgetAtExactPositionOverflowing","_getTopAndBottomLeft","visibleRangesForRange","firstLine","visibleRangesForLine","firstLineMinLeft","lastLineMinLeft","topForPosition","topForBottomLine","_prepareRenderWidget","preferredDimensions","beforeRender","safeInvoke","pref","coordinate","afterRender","AbstractLineHighlightOverlay","_renderLineHighlight","_renderLineHighlightOnlyWhenFocus","_selectionIsEmpty","_focused","_cursorLineNumbers","_readFromSelections","cursorsLineNumbers","selectionIsEmpty","_shouldRenderThis","renderedLine","_renderOne","_shouldRenderInMargin","_shouldRenderInContent","CurrentLineHighlightOverlay","_shouldRenderOther","CurrentLineMarginHighlightOverlay","lineHighlight","defines","lineHighlightBorder","DecorationsOverlay","_typicalHalfwidthCharacterWidth","_decorations","decorations","decorationsLen","zIndex","aClassName","bClassName","_renderWholeLineDecorations","_renderNormalDecorations","lenI","isWholeLine","decorationOutput","prevClassName","prevShowIfCollapsed","prevRange","showIfCollapsed","_renderNormalDecoration","linesVisibleRanges","lenJ","lineVisibleRanges","singleVisibleRange","center","lenK","EditorScrollbar","linesContent","overflowGuardDomNode","scrollbar","scrollbarOptions","getScrollable","scrollbarDomNode","_setLayout","onBrowserDesperateReveal","lookAtScrollTop","lookAtScrollLeft","newScrollPosition","deltaLeft","minimap","side","minimapWidth","newOpts","scrollbarShadowColor","scrollbarSliderBackgroundColor","scrollbarSliderHoverBackgroundColor","scrollbarSliderActiveBackgroundColor","DecorationToRender","_decorationToRenderBrand","DedupOverlay","prevEndLineIndex","startLineIndex","endLineIndex","GlyphMarginOverlay","_glyphMargin","_getDecorations","rLen","glyphMarginClassName","IndentGuidesOverlay","_primaryPosition","wrappingInfo","_spaceWidth","_maxIndentLeft","wrappingColumn","_bracketPairGuideOptions","bracketPairs","activeCursorPosition","indents","getGuidesByLine","leftOffset","guide","visibleColumn","horizontalLine","bracketGuides","getBracketGuidesInRangeByLine","highlightActive","highlightActiveBracketPair","horizontalGuides","bracketPairsHorizontal","includeInactive","indentGuides","getLinesIndentGuides","activeIndentStartLineNumber","activeIndentEndLineNumber","activeIndentLevel","activeIndentInfo","getActiveIndentGuide","indentSize","lineGuides","bracketGuidesInLine","bracketGuidesInLineQueue","indentGuidesInLine","indentLvl","indentGuide","peeked","transparentToUndefined","editorIndentGuidesColor","editorActiveIndentGuidesColor","colors","bracketColor","guideColor","guideColorActive","colorProvider","colorValues","effectiveGuideColor","effectiveGuideColorActive","level","getInlineClassNameOfLevel","activeClassName","LastRenderedData","_currentVisibleRange","getCurrentVisibleRange","setCurrentVisibleRange","currentVisibleRange","HorizontalRevealRangeRequest","startScrollTop","stopScrollTop","scrollType","minLineNumber","maxLineNumber","HorizontalRevealSelectionsRequest","ViewLines","_linesContent","_textRangeRestingSpot","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_horizontalScrollbarHeight","horizontalScrollbarHeight","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_viewLineOptions","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_asyncCheckMonospaceFontAssumptions","_checkMonospaceFontAssumptions","_lastRenderedData","_horizontalRevealRequest","_onOptionsMaybeChanged","newViewLineOptions","rendStartLineNumber","rendEndLineNumber","_computeScrollTopToRevealRange","getFutureViewport","verticalType","revealHorizontal","scrollTopDelta","setMaxLineWidth","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","originalEndLineNumber","visibleRangesLen","domReadingContext","nextLineModelLineNumber","currentLineModelLineNumber","_visibleRangesForLineRange","updateLineWidths","_updateLineWidths","_updateLineWidthsFast","fast","localMaxLineWidth","allWidthsComputed","visibleLine","_ensureMaxLineWidth","longestLineNumber","longestWidth","horizontalRevealRequest","_computeScrollLeftToReveal","maxHorizontalOffset","iLineWidth","viewport","viewportStartY","viewportEndY","boxIsSingleRange","boxStartY","boxEndY","shouldIgnoreScrollOff","desiredGapAbove","minScrollTop","boxMiddleY","_computeMinimumScrolling","viewportStartX","viewportEndX","boxStartX","boxEndX","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength","LinesDecorationsOverlay","_decorationsLeft","decorationsLeft","_decorationsWidth","decorationsWidth","linesDecorationsClassName","firstLineDecorationClassName","lineOutput","MarginViewLineDecorationsOverlay","marginClassName","RGBA8","_rgba8Brand","_clamp","Empty","MinimapTokensColorTracker","_updateColorMap","changedColorMap","colorMap","_colors","_backgroundIsLight","colorId","backgroundLuminosity","backgroundIsLight","allCharCodes","getCharIndex","fontScale","MinimapCharRenderer","charData","scale","_minimapCharRendererBrand","charDataNormal","soften","charDataLight","Uint8ClampedArray","renderChar","dx","dy","foregroundAlpha","backgroundAlpha","useLighterFont","force1pxHeight","charWidth","charHeight","destWidth","backgroundR","backgroundG","backgroundB","deltaR","deltaG","deltaB","destAlpha","sourceOffset","blockRenderChar","colorR","colorG","colorB","charTable","A","C","D","E","F","decodeData","prebakedMiniMaps","MinimapCharRendererFactory","lastCreated","lastFontFamily","createFromSampleData","createSampleData","canvas","fillStyle","textBaseline","fillText","getImageData","expectedLength","_downsample","destOffset","brightest","sourceY1","sourceY2","sourceX1","sourceX2","samples","sy","sourceRow","yBalance","sx","xBalance","final","pixelsPerCharacter","_downsampleChar","adjust","GUTTER_DECORATION_WIDTH","MinimapOptions","tokensColorTracker","minimapLayout","minimapOpts","renderMinimap","minimapHeightIsEditorHeight","scrollBeyondLastLine","showSlider","minimapLeft","minimapHeight","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","defaultBackgroundColor","_getMinimapBackground","_getMinimapForegroundOpacity","themeColor","MinimapLayout","sliderNeeded","sliderTop","sliderHeight","getDesiredScrollTopFromDelta","getDesiredScrollTopFromTouchLocation","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportContainsWhitespaceGaps","realLineCount","previousLayout","minimapLinesFitting","logicalScrollHeight","maxMinimapSliderTop","maxLinesFitting","viewportLineCount","expectedViewportLineCount","extraLinesAtTheBottom","partialLine","sliderTopAligned","MinimapLine","INVALID","RenderData","renderedLayout","imageData","_imageData","_renderedLines","linesEquals","scrollEquals","MinimapBuffers","WIDTH","HEIGHT","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","backgroundA","MinimapSamplingState","samplingRatio","minimapLines","oldSamplingState","minimapLineCount","halfRatio","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","MAX_EVENT_COUNT","oldMinimapLineNumber","_oldIndex","selectedViewLineNumber","_i","modelLineToMinimapLine","modelLineRangeToMinimapLineRange","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","_minimapSelections","samplingState","_samplingState","_shouldCheckSampling","InnerMinimap","_recreateLineSampling","onDidChangeOptions","affectsMinimap","minimapLineRange","minimapCtx","whitespaceViewportData","wasSampling","getRealLineCount","getMinimapLinesRenderingData","needed","getSelections","getMinimapDecorationsInViewport","modelStartLineNumber","modelEndLineNumber","decoration","minimapStartLineNumber","minimapEndLineNumber","revealLineNumber","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_getMinimapDomNodeClassName","_shadow","_decorationsCanvas","_slider","_sliderHorizontal","_applyLayout","_mouseDownListener","initialPosY","_startSliderDragging","internalOffsetY","_sliderMouseMoveMonitor","_sliderMouseDownListener","_gestureDisposable","_sliderTouchStartListener","scrollDueToTouchEvent","_sliderTouchMoveListener","_sliderTouchEndListener","initialPosX","initialSliderState","handleMouseMove","_getBuffer","renderingCtx","renderDecorations","characterWidth","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","y1","y2","yy1","yy2","fillRect","highlightColors","minimapOptions","decorationColor","highlightColor","renderDecorationOnLine","renderDecoration","decorationRange","x1","getXOffsetForPosition","x2","minimumXOffset","lineIndexToXOffset","prevx","_lastData","_dirtyY1","_dirtyY2","lineInfo","defaultBackground","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","colorTracker","minimapCharRenderer","maxDx","tabsCharDelta","tokenIndex","tokensLen","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","_startLineNumber","_endLineNumber","_defaultValue","sliderBackground","sliderHoverBackground","sliderActiveBackground","shadow","ViewOverlayWidgets","_verticalScrollbarWidth","verticalScrollbarWidth","_minimapWidth","_editorHeight","_editorWidth","widgetData","_renderWidget","widgetHeight","Settings","overviewRulerLanes","renderBorder","hideCursor","cursorColor","minimapEnabled","minimapSide","overviewRuler","domWidth","domHeight","canvasWidth","canvasHeight","_initLanes","canvasLeftOffset","laneCount","remainingWidth","leftWidth","rightWidth","centerWidth","centerOffset","rightOffset","DecorationsOverviewRuler","_updateSettings","_tokensColorTrackerListener","_cursorPositions","newSettings","_settings","affectsOverviewRuler","editorCtx","heightRatio","getAllOverviewRulerDecorations","minDecorationHeight","halfMinDecorationHeight","canvasCtx","decorationGroup","decorationGroupData","prevLane","prevY1","prevY2","lane","yCenter","cursorHeight","halfCursorHeight","cursorX","cursorW","beginPath","strokeStyle","lineTo","stroke","OverviewRuler","cssClassName","_zoneManager","setDOMWidth","setDOMHeight","setOuterHeight","setPixelRatio","getDOMWidth","getDOMHeight","getCanvasWidth","getCanvasHeight","setLayout","setZones","zones","getOuterHeight","colorZones","resolveColorZones","id2Color","getId2Color","_renderOneLane","currentColorId","currentFrom","currentTo","zone","zoneColorId","zoneFrom","zoneTo","Rulers","_renderedRulers","_rulers","_ensureRulersCount","currentCount","desiredCount","rulerWidth","addCount","ruler","rulerColor","ScrollDecorationViewPart","_updateWidth","_shouldShow","_useShadows","_updateShouldShow","newShouldShow","HorizontalRangeWithStyle","startStyle","endStyle","LineVisibleRangesWithStyle","toStyledRange","toStyled","SelectionsOverlay","_previousFrameVisibleRangesWithStyle","_roundedSelection","_visibleRangesHaveGaps","_enrichVisibleRangesWithStyle","previousFrame","epsilon","previousFrameTop","previousFrameBottom","topLineNumber","bottomLineNumber","curLineRange","curLeft","curRight","prevLeft","prevRight","nextLeft","nextRight","_getVisibleRangesWithStyle","_linesVisibleRanges","visibleRangesHaveGaps","_createSelectionPiece","_actualRenderOneSelection","output2","hasMultipleSelections","visibleRangesHaveStyle","fullLineHeight","reducedLineHeight","firstLineNumber","lastLineNumber","innerCornerOutput","restOfSelectionOutput","SELECTION_CLASS_NAME","ROUNDED_PIECE_WIDTH","EDITOR_BACKGROUND_CLASS_NAME","SELECTION_TOP_RIGHT","SELECTION_BOTTOM_RIGHT","SELECTION_TOP_LEFT","SELECTION_BOTTOM_LEFT","thisFrameVisibleRangesWithStyle","visibleRangesWithStyle","internalCorners","restOfSelection","editorSelectionColor","editorInactiveSelectionColor","editorSelectionForegroundColor","ViewCursorRenderData","textContentClassName","ViewCursor","_cursorStyle","_lineCursorWidth","_lastRenderedContent","onCursorPositionChanged","_getGraphemeAwarePosition","_prepareRender","nextGrapheme","visibleRangeForCharacter","firstVisibleRangeForCharacter","getClassName","ViewCursors","_readOnly","_cursorBlinking","_cursorSmoothCaretAnimation","_isComposingInput","_primaryCursor","_secondaryCursors","_updateDomClassName","_startCursorBlinkAnimation","_cursorFlatBlinkInterval","_blinkingEnabled","_editorHasFocus","_updateBlinking","_onCursorPositionChanged","secondaryPositions","addCnt","newCursor","nextSibling","positions","secondaryCursor","_getCursorBlinking","blinkingStyle","isHidden","isSolid","_show","BLINK_INTERVAL","_getClassName","renderDataLen","primaryRenderData","secondaryRenderData","caret","caretBackground","invalidFunc","ViewZones","marginDomNode","_zones","_recomputeWhitespacesProps","whitespaces","getWhitespaces","oldWhitespaces","hadAChange","changeWhitespace","whitespaceAccessor","props","_computeWhitespaceProps","isInHiddenArea","oldWhitespace","afterViewLineNumber","heightInPx","changeOneWhitespace","_safeCallOnComputedHeight","_getZoneOrdinal","afterColumn","_heightInPixels","minWidthInPx","_minWidthInPixels","zoneAfterModelPosition","zoneBeforeModelPosition","validAfterLineNumber","afterColumnAffinity","isVisible","changeViewZones","zonesHaveChanged","changeAccessor","addZone","_addZone","removeZone","_removeZone","layoutZone","_layoutZone","safeInvoke1Arg","whitespaceId","insertWhitespace","myZone","removeWhitespace","heightInLines","onComputedHeight","_safeCallOnDomNodeTop","onDomNodeTop","visibleWhitespaces","visibleZones","hasVisibleZone","visibleWhitespace","newTop","newHeight","newDisplay","func","arg1","EditorTheme","ViewContext","eventHandler","addViewEventHandler","removeViewEventHandler","ViewportData","partialData","View","colorTheme","overflowWidgetsDomNode","_renderAnimationFrame","_viewParts","_textAreaHandler","_createTextAreaHandlerHelper","_getEditorClassName","_overflowGuardContainer","_scrollbar","_viewZones","decorationsOverviewRuler","scrollDecoration","contentViewOverlays","marginViewOverlays","_contentWidgets","_viewCursors","_overlayWidgets","rulers","overviewRulerData","_pointerHandler","_createPointerHandlerHelper","_flushAccumulatedAndRenderNow","_renderNow","focused","_scheduleRender","viewPart","_onRenderScheduled","safeInvokeNoArg","_actualRender","_getViewPartsToRender","viewPartsToRender","partialViewportData","getLinesViewportData","setViewport","centeredLineNumber","getWhitespaceViewportData","renderingContext","restoreState","tokenizeViewport","getOffsetForColumn","modelColumn","mouseTarget","createOverviewRuler","everything","addContentWidget","layoutContentWidget","newRange","newPreference","removeContentWidget","addOverlayWidget","layoutOverlayWidget","removeOverlayWidget","Cursor","_selTrackedRange","_trackSelection","_removeTrackedRange","startTrackingSelection","_updateTrackedRange","stopTrackingSelection","_setTrackedRange","asCursorState","readSelectionFromMarkers","_getTrackedRange","getDirection","ensureValidState","setState","cacheInput","cacheOutput","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","selectionStartLeftoverVisibleColumns","leftoverVisibleColumns","_validateViewState","equalsRange","viewSelectionStart","validateViewRange","viewSelectionStart1","viewSelectionStart2","CursorCollection","startTrackingSelections","stopTrackingSelections","updateContext","getAll","getViewPositions","getTopMostViewPosition","getBottomMostViewPosition","getViewSelections","setSelections","setStates","getPrimaryCursor","_setSecondaryStates","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","_removeSecondaryCursor","killSecondaryCursors","sortedCursors","sortedCursorIndex","currentSelection","nextSelection","multiCursorMergeOverlapping","shouldMergeCursors","isBeforeOrEqual","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","plusRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","sortedCursor","CursorContext","_cursorContextBrand","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","_source","ViewCursorStateChangedEvent","ViewDecorationsChangedEvent","ViewFlushedEvent","ViewFocusChangedEvent","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","ViewScrollChangedEvent","ViewThemeChangedEvent","ViewTokensChangedEvent","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","ViewModelEventDispatcher","_onEvent","onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","emitOutgoingEvent","_addOutgoingEvent","_emitOutgoingEvents","kind","isNoOp","beginEmitViewEvents","ViewModelEventsCollector","endEmitViewEvents","outgoingEvents","viewEvents","outgoingEvent","_emitMany","emitSingleViewEvent","eventsCollector","emitViewEvent","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","ContentSizeChangedEvent","oldContentWidth","oldContentHeight","_oldContentWidth","_oldContentHeight","contentWidthChanged","contentHeightChanged","FocusChangedEvent","oldHasFocus","ScrollChangedEvent","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","reachedMaxCursorCount","_selectionsAreEqual","ReadOnlyEditAttemptEvent","CursorsController","_knownModelVersionId","getVersionId","_viewModel","_cursors","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","_validateAutoClosedActions","autoClosedAction","isValid","MAX_CURSOR_COUNT","CursorModelState","_emitStateChangedIfNecessary","columnSelectData","revealPrimary","viewPositions","revealViewRange","revealViewSelections","saveState","desiredSelections","onModelContentChanged","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","primaryCursor","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","CommandExecutor","_interpretCommandResult","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","viewSelections","newCursorState","_findAutoClosingPairs","indices","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","closeCharIndex","openCharIndex","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","_executeEdit","cursorChangeReason","readOnly","setIsDoingComposition","isDoingComposition","getAutoClosedCharacters","getAllAutoClosedCharacters","charLength","newSelections","executeCommand","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","getDecorationRange","enclosingRanges","strictContainsRange","selectionsBefore","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","filteredOperations","major","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","losingCursors","losingCursorIndex","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","editOperationBuilder","getEditOperations","previousOp","currentOp","loserMajor","PendingChanges","_hasPending","_inserts","_changes","_removes","insert","mustCommit","commit","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","ordinal","minWidth","prefixSum","LinesLayout","paddingTop","paddingBottom","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","_checkPendingChanges","setPadding","newAfterLineNumber","_insertWhitespace","_changeOneWhitespace","_findWhitespaceIndex","_removeWhitespace","toRemove","toChange","applyRemoveAndChange","findInsertionIndex","getWhitespacesTotalHeight","getWhitespacesAccumulatedHeight","getLinesTotalHeight","linesHeight","whitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","halfDelta","_findFirstWhitespaceAfterLineNumber","firstWhitespaceAfterLineNumber","getFirstWhitespaceIndexAfterLineNumber","previousLinesHeight","previousWhitespacesHeight","getWhitespaceMinWidth","totalHeight","getLineNumberAtOrAfterVerticalOffset","midLineNumber","midLineNumberVerticalOffset","verticalOffset1","verticalOffset2","startLineNumberVerticalOffset","whitespaceIndex","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","getVerticalOffsetForWhitespaceIndex","getWhitespaceIndexAtOrAfterVerticallOffset","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","candidateIndex","candidateTop","candidateHeight","candidateId","getIdForWhitespaceIndex","candidateAfterLineNumber","SMOOTH_SCROLLING_TIME","EditorScrollDimensions","EditorScrollable","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","oldDimensions","ViewLayout","_linesLayout","_configureSmoothScrollDuration","_updateHeight","onHeightMaybeChanged","_getContentHeight","_getHorizontalScrollbarHeight","currentScrollPosition","_computeContentWidth","maxLineWidth","extraHorizontalSpace","whitespaceMinWidth","firstLineNumberInViewport","whitespaceAboveFirstLine","scrollTopWithoutViewZones","visibleBox","getLinesViewportDataAtScrollTop","createModelLineProjection","lineBreakData","IdentityModelLineProjection","HiddenModelLineProjection","ModelLineProjection","_projectionData","getProjectionData","getViewLineCount","getOutputLineCount","getViewLineContent","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","breakOffsets","endOffsetInInputWithInjections","injectionOffsets","injectedTexts","injectionOptions","lineWithInjections","spaces","wrappedTextIndentLength","getViewLineLength","getViewLineMinColumn","_modelLineNumber","getMinOutputOffset","getViewLineMaxColumn","getMaxOutputOffset","getViewLinesData","outputLineIdx","globalStartIndex","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","inlineClassNameAffectsLetterSpacing","getLineTokens","withInserted","tokenMetadata","globalIndex","_getViewLineData","deltaStartIndex","sliceAndInflate","breakOffsetsVisibleColumn","getModelColumnOfViewPosition","outputColumn","translateToInputOffset","getViewPositionOfModelPosition","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","getViewLineNumberOfModelPosition","outputPosition","baseViewLineNumber","normalizedOutputPosition","normalizeOutputPosition","getInjectedText","_outputLineIndex","inflate","_fromOuputLineIndex","_toOutputLineIndex","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","editorId","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","wrappingIndent","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","lineInjectedText","addRequest","linesBreaks","finalize","hiddenAreas","areaId","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","projectedModelLineLineCounts","getHiddenAreas","decId","setHiddenAreas","_ranges","validatedRanges","newRanges","normalizeLineRanges","oldRanges","hasDifference","newDecorations","hasVisibleLine","lineChanged","newOutputLineCount","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","onModelLineChanged","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","getTotalSum","_toValidViewLineNumber","modelMinPosition","modelMaxPosition","viewStartPosition","viewEndPosition","getViewLineInfo","getIndexOf","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getModelStartPositionOfViewLine","minViewColumn","getModelEndPositionOfViewLine","maxViewColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","lastVisibleModelPos","curModelLine","lastVisibleModelPos2","modelRange","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","isWrappedLineContinuation","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","viewLineEndIndex","viewIndents","currIndex","blockAtIndex","startModelLineIndex","startRemainder","fromViewLineIndex","remainingViewLineCount","viewColumn","expectedModelPosition","computedModelColumn","computedModelPosition","expectedModelRange","validViewStart","validViewEnd","inputLineNumber","lineIndexChanged","getDecorationsInRange","ownerId","filterOutValidation","finalResult","finalResultLen","prevDecId","dec","getLineIndentColumn","sortedRanges","currentRangeStart","currentRangeEnd","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","_validPosition","_validRange","_viewPosition","USE_IDENTITY_LINES_COLLECTION","ViewModel","languageConfigurationService","_themeService","_eventDispatcher","getLanguageId","_tokenizeViewportSoon","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","_cursor","_registerModelEvents","_onConfigurationChanged","onDidColorThemeChange","_invalidateDecorationsColorCache","linesViewportData","viewVisibleRange","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","previousViewportStartModelPosition","previousViewportStartViewPosition","restorePreviousViewportStart","viewPositionTop","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","changeType","lineIdx","lineBreakQueue","linesDeletedEvent","insertedLineBreaks","linesInsertedEvent","changedLineBreakData","linesChangedEvent","getAttachedEditorCount","onDidChangeTokens","viewRanges","tokenizationSupportChanged","onDidChangeLanguageConfiguration","onDidChangeLanguage","onDidChangeDecorations","onModelDecorationsChanged","getVisibleRangesPlusViewportAboveBelow","linesAround","startViewLineNumber","endViewLineNumber","hiddenStartLineNumber","hiddenEndLineNumber","compatViewState","firstViewLineNumber","firstPosition","firstPositionDeltaTop","reduceRestoreState","_reduceRestoreStateCompatibility","getTabSize","viewportStartLineTop","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","getDecorationsViewportData","mightContainRTL","mightContainNonBasicASCII","allInlineDecorations","toInlineDecoration","getOverviewRulerDecorations","OverviewRulerDecorations","decorationOptions","opts1","invalidateCachedColor","opts2","modelAnchor","modelAnchorOffset","getOffsetAt","getPositionAt","modelRanges","forceCRLF","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","_getColorMap","hasBadChars","useDefaultFontFamily","hasQuotesOrIsList","needsQuotes","_getHTMLToCopy","_withViewEventsCollector","saveCursorState","restoreCursorState","_executeCursorEdit","_asMap","prevGroup","prevData","prevEndLineNumber","ModelLineProjectionData","lineLength","outputOffset","offsetInInputWithInjection","offsetInInput","inputOffset","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","midStart","midStop","OutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","maxOutputLineIndex","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","cursorStop","baseLineNumber","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","WrappingCharacterClassifier","previousBreakingData","columnsForFullWidthChar","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","_asciiMap","firstLineBreakColumn","prevBreakingOffsets","prevBreakingOffsetsVisibleColumn","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","tabCharacterWidth","numberOfAdditionalTabs","ttPolicy","DOMLineBreaksComputerFactory","injectedTextsPerLine","createEmptyLineBreakWithPossiblyInjectedText","requestIdx","overallWidth","additionalIndent","additionalIndentSize","additionalIndentLength","containerDomNode","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","indentWidth","renderLineContent","trustedhtml","lineDomNodes","readLineBreaks","visibleColumns","curInjectedTexts","initialVisibleColumn","wrappingIndentLength","hangingOffset","charOffsets","producedCharacters","write1","appendASCII","spans","discoverBreaks","lowRects","highRects","midRects","EDITOR_ID","ModelData","hasRealView","listenersToRemove","onBeforeDetached","CodeEditorWidget","codeEditorWidgetOptions","instantiationService","commandService","contextKeyService","themeService","notificationService","accessibilityService","languageFeaturesService","_onDidChangeModelContent","onDidChangeModelContent","_onDidChangeModelLanguage","onDidChangeModelLanguage","_onDidChangeModelLanguageConfiguration","onDidChangeModelLanguageConfiguration","_onDidChangeModelOptions","onDidChangeModelOptions","_onDidChangeModelDecorations","onDidChangeModelDecorations","_onDidChangeConfiguration","onDidChangeConfiguration","_onDidChangeModel","onDidChangeModel","_onDidChangeCursorPosition","onDidChangeCursorPosition","_onDidChangeCursorSelection","onDidChangeCursorSelection","_onDidAttemptReadOnlyEdit","onDidAttemptReadOnlyEdit","_onDidLayoutChange","onDidLayoutChange","_editorTextFocus","BooleanEventEmitter","onDidFocusEditorText","onDidChangeToTrue","onDidBlurEditorText","onDidChangeToFalse","_editorWidgetFocus","onDidFocusEditorWidget","onDidBlurEditorWidget","_onWillType","onWillType","_onDidType","onDidType","_onDidCompositionStart","onDidCompositionStart","_onDidCompositionEnd","onDidCompositionEnd","_onDidPaste","onDidPaste","_onMouseDrag","_onMouseDrop","_onMouseDropCanceled","_onDidScrollChange","onDidScrollChange","_onDidChangeViewZones","onDidChangeViewZones","_onDidChangeHiddenAreas","onDidChangeHiddenAreas","_bannerDomNode","contributions","_domElement","_overflowWidgetsDomNode","_decorationTypeKeysToIds","_decorationTypeSubtypes","_telemetryData","telemetryData","_createConfiguration","_contextKeyService","createScoped","_notificationService","_codeEditorService","_commandService","EditorContextKeysManager","EditorModeContext","_instantiationService","createChild","_modelData","_contributions","_focusTracker","CodeEditorWidgetFocusTracker","contribution","createInstance","internalAction","addCodeEditor","editorCommon","removeCodeEditor","contributionId","_removeDecorationTypes","_postDetachModelCleanup","_detachModel","getOverflowWidgetsDomNode","getConfiguredWordAtPosition","preserveBOM","eolPreference","lineEnding","setModel","detachedModel","_attachModel","oldModelUrl","newModelUrl","decorationType","subTypes","subType","_removeDecorationType","modelData","_getVerticalOffsetForPosition","getVisibleColumnFromPosition","rawPosition","_sendRevealRange","validatedModelRange","revealLine","_revealLine","revealLineInCenter","revealLineInCenterIfOutsideViewport","revealLineNearTop","revealType","revealPosition","_revealPosition","revealPositionInCenter","revealPositionInCenterIfOutsideViewport","revealPositionNearTop","something","isSelection","isRange","_setSelectionImpl","sel","revealLines","_revealLines","revealLinesInCenter","revealLinesInCenterIfOutsideViewport","revealLinesNearTop","revealVerticalInCenter","_revealRange","revealRangeInCenter","revealRangeInCenterIfOutsideViewport","revealRangeNearTop","revealRangeNearTopIfOutsideViewport","revealRangeAtTop","getScrollLeft","setScrollLeft","saveViewState","contributionsState","restoreViewState","codeEditorState","reducedState","getContribution","getActions","getSupportedActions","isSupported","payload","_startComposition","_endComposition","_compositionType","replaceCharCnt","_paste","_cut","_triggerEditorCommand","_triggerCommand","popUndoStop","popStackElement","endCursorState","changeDecorations","getLineDecorations","oldDecorations","removeDecorations","decorationTypeKey","oldDecorationsIds","getLayoutInfo","hasWidgetFocus","getScrolledVisiblePosition","forceRedraw","setBanner","domNodeHeight","onBeforeAttached","onDidChangeContent","onWillDispose","secondarySelections","_createView","viewUserInputEvents","removeAllDecorationsWithOwnerId","removeDomNode","removeDecorationType","_onDidChangeToTrue","_onDidChangeToFalse","createKey","_editorSimpleInput","_editorFocus","_textInputFocus","_editorTabMovesFocus","_editorReadonly","_inDiffEditor","_editorColumnSelection","_hasMultipleSelections","_hasNonEmptySelection","_canUndo","_canRedo","_updateFromConfig","_updateFromSelection","_updateFromFocus","_updateFromModel","canUndo","canRedo","_languageFeaturesService","_langId","_hasCompletionItemProvider","_hasCodeActionsProvider","_hasCodeLensProvider","_hasDefinitionProvider","_hasDeclarationProvider","_hasImplementationProvider","_hasTypeDefinitionProvider","_hasHoverProvider","_hasDocumentHighlightProvider","_hasDocumentSymbolProvider","_hasReferenceProvider","_hasRenameProvider","_hasSignatureHelpProvider","_hasInlayHintsProvider","_hasDocumentFormattingProvider","_hasDocumentSelectionFormattingProvider","_hasMultipleDocumentFormattingProvider","_hasMultipleDocumentSelectionFormattingProvider","_isInWalkThrough","_update","completionProvider","codeActionProvider","codeLensProvider","definitionProvider","declarationProvider","implementationProvider","typeDefinitionProvider","hoverProvider","documentHighlightProvider","documentSymbolProvider","referenceProvider","renameProvider","documentFormattingEditProvider","documentRangeFormattingEditProvider","signatureHelpProvider","inlayHintsProvider","bufferChangeEvents","_domFocusTracker","squigglyStart","squigglyEnd","getSquigglySVGData","dotdotdotStart","dotdotdotEnd","getDotDotDotSVGData","errorBorderColor","errorForeground","errorBackground","warningBorderColor","warningForeground","warningBackground","infoBorderColor","infoForeground","infoBackground","hintBorderColor","hintForeground","unnecessaryForeground","unnecessaryBorder","deprecatedForeground","EmbeddedCodeEditorWidget","parentEditor","_parentEditor","_overwriteOptions","_onParentConfigurationChanged","getParentEditor","ReplaceCommand","_text","builder","helper","srcRange","ReplaceCommandThatSelectsText","ReplaceCommandWithoutChangingPosition","ReplaceCommandWithOffsetCursorState","lineNumberDeltaOffset","columnDeltaOffset","_columnDeltaOffset","_lineNumberDeltaOffset","ReplaceCommandThatPreservesSelection","editRange","initialSelection","_initialSelection","_forceMoveMarkers","_selectionId","repeatCache","cachedStringRepeat","ShiftCommand","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","insertSpaces","contentStartVisibleColumn","desiredTabStop","indentCount","_addEditOperation","startLine","endLine","shouldIndentEmptyLines","useTabStops","previousLineExtraSpaces","extraSpaces","desiredIndent","indentationEndIndex","isUnshift","isCheapToTokenize","enterAction","removeText","unshiftIndent","shiftIndent","oneIndent","lastOp","initialStartColumn","resultStartColumn","MINIMAP_GUTTER_WIDTH","ConfigurationChangedEvent","ComputeOptionsMemory","stableMinimapLayoutInput","stableFitMaxMinimapScale","stableFitRemainingWidth","BaseEditorOption","ApplyUpdateResult","arrayEquals","ComputedEditorOption","SimpleEditorOption","boolean","EditorBooleanOption","clampedInt","minimum","maximum","EditorIntOption","EditorFloatOption","validationFn","float","EditorStringOption","string","stringSet","allowedValues","EditorStringEnumOption","enum","_allowedValues","EditorEnumOption","defaultStringValue","convert","_convert","_autoIndentFromString","EditorAccessibilitySupport","enumDescriptions","EditorComments","defaults","insertSpace","ignoreEmptyLines","_input","_cursorBlinkingStyleFromString","cursorBlinkingStyle","TextEditorCursorStyle","_cursorStyleFromString","cursorStyle","Block","Underline","LineThin","BlockOutline","UnderlineThin","EditorClassName","EditorEmptySelectionClipboard","EditorFind","cursorMoveOnType","seedSearchStringFromSelection","autoFindInSelection","globalFindClipboard","addExtraSpaceOnTop","included","EditorFontLigatures","OFF","anyOf","ON","EditorFontInfo","EditorFontSize","EDITOR_FONT_DEFAULTS","EditorFontWeight","MINIMUM_VALUE","MAXIMUM_VALUE","errorMessage","SUGGESTION_VALUES","EditorGoToLocation","multiple","multipleDefinitions","multipleTypeDefinitions","multipleDeclarations","multipleImplementations","multipleReferences","alternativeDefinitionCommand","alternativeTypeDefinitionCommand","alternativeDeclarationCommand","alternativeImplementationCommand","alternativeReferenceCommand","jsonSubset","alternativeCommandOptions","deprecationMessage","EditorHover","above","EditorLayoutInfoComputer","computeLayout","typicalViewportLineCount","extraLinesBeyondLastLine","desiredRatio","couldUseMemory","renderCharacters","minimapRenderCharacters","minimapMaxColumn","minimapSize","minimapWidthMultiplier","computeContainedMinimapLineCount","fitBecomesFill","maxMinimapScale","effectiveMinimapHeight","configuredMinimapScale","minimapMaxWidth","wordWrapOverride2","wordWrapOverride1","wordWrapColumn","showGlyphMargin","showLineNumbers","lineNumbersMinChars","verticalScrollbarHasArrows","scrollbarArrowSize","rawLineDecorationsWidth","folding","lineDecorationsWidth","isWordWrapMinified","_computeMinimapLayout","viewportColumn","verticalArrowSize","EditorLightbulb","EditorInlayHints","markdownDescription","EditorLineHeight","EditorMinimap","_multiCursorModifierFromString","multiCursorModifier","EditorPadding","EditorParameterHints","cycle","EditorPixelRatio","EditorQuickSuggestions","comments","EditorRenderLineNumbersOption","filterValidationDecorations","renderValidationDecorations","EditorRulers","columnSchema","_scrollbarVisibilityFromString","inUntrustedWorkspace","unicodeHighlightConfigKeys","allowedCharacters","invisibleCharacters","nonBasicASCII","ambiguousCharacters","includeComments","includeStrings","allowedLocales","UnicodeHighlight","_os","_vscode","restricted","additionalProperties","primitiveSet","validateBooleanMap","InlineEditorSuggest","BracketPairColorization","GuideOptions","EditorSuggest","insertMode","filterGraceful","snippetsPreventQuickSuggestions","localityBonus","shareSuggestSelections","showIcons","showStatusBar","previewMode","showInlineDetails","showMethods","showFunctions","showConstructors","showDeprecated","showFields","showVariables","showClasses","showStructs","showInterfaces","showModules","showProperties","showEvents","showOperators","showUnits","showValues","showConstants","showEnums","showEnumMembers","showKeywords","showWords","showColors","showFiles","showReferences","showFolders","showTypeParameters","showSnippets","showUsers","showIssues","SmartSelect","selectLeadingAndTrailingWhitespace","EditorTabFocusMode","_wrappingIndentFromString","EditorWrappingInfoComputer","DEFAULT_WINDOWS_FONT_FAMILY","DEFAULT_MAC_FONT_FAMILY","DEFAULT_LINUX_FONT_FAMILY","editorOptionsRegistry","EditorOptions","acceptSuggestionOnCommitCharacter","markdownEnumDescriptions","autoClosingDelete","autoClosingOvertype","automaticLayout","bracketPairColorization","bracketPairGuides","codeLens","codeLensFontFamily","codeLensFontSize","colorDecorators","contextmenu","copyWithSyntaxHighlighting","cursorSmoothCaretAnimation","cursorSurroundingLines","cursorSurroundingLinesStyle","cursorWidth","disableLayerHinting","disableMonospaceOptimizations","domReadOnly","dragAndDrop","fixedOverflowWidgets","foldingStrategy","foldingHighlight","foldingImportsByDefault","foldingMaximumRegions","unfoldOnClickAfterEndOfLine","fontLigatures2","formatOnPaste","formatOnType","glyphMargin","gotoLocation","hideCursorInOverviewRuler","inDiffEditor","linkedEditing","links","mouseStyle","mouseWheelZoom","multiCursorPaste","occurrencesHighlight","overviewRulerBorder","peekWidgetDefaultFocus","definitionLinkOpensInPeek","quickSuggestions","quickSuggestionsDelay","renameOnType","markdownDeprecationMessage","renderFinalNewline","renderLineHighlightOnlyWhenFocus","revealHorizontalRightPadding","roundedSelection","scrollBeyondLastColumn","selectionClipboard","selectionHighlight","showFoldingControls","showUnused","inlayHints","snippetSuggestions","smartSelect","inlineSuggest","suggestFontSize","suggestLineHeight","suggestOnTriggerCharacters","suggestSelection","unicodeHighlight","unusualLineTerminators","useShadowDOM","wordWrapBreakAfterCharacters","wordWrapBreakBeforeCharacters","editorClassName","EditorZoom","_zoomLevel","_onDidChangeZoomLevel","onDidChangeZoomLevel","getZoomLevel","setZoomLevel","GOLDEN_LINE_HEIGHT_RATIO","MINIMUM_LINE_HEIGHT","BareFontInfo","_bareFontInfoBrand","ignoreEditorZoom","editorZoomLevelMultiplier","fallbackFontFamily","_wrapInQuotes","SERIALIZED_FONT_INFO_VERSION","FontInfo","_editorStylingBrand","CharacterClassifier","_createAsciiMap","asciiMap","CharacterSet","CursorColumns","nextRenderTabStop","textLen","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","beforeDelta","afterDelta","EditOperation","editorLineHighlight","dark","light","hc","editorLineHighlightBorder","editorRangeHighlight","editorRangeHighlightBorder","editorSymbolHighlight","editorSymbolHighlightBorder","editorCursorForeground","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorActiveLineNumber","editorRuler","editorBracketMatchBackground","editorBracketMatchBorder","editorOverviewRulerBorder","editorOverviewRulerBackground","editorGutter","editorUnnecessaryCodeBorder","editorUnnecessaryCodeOpacity","ghostTextBorder","ghostTextForeground","ghostTextBackground","rulerRangeDefault","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","overviewRulerInfo","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","gutter","rangeHighlight","rangeHighlightBorder","symbolHighlight","symbolHighlightBorder","invisibles","countEOL","eolCount","firstLineLength","lastLineStart","_normalizeIndentationFromWhitespace","spacesCnt","tabsCnt","normalizeIndentation","Position","newLineNumber","newColumn","deltaColumn","aLineNumber","bLineNumber","aColumn","bColumn","containsRange","otherRange","resultStartLineNumber","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","setEndPosition","setStartPosition","collapseToStart","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists","Selection","selectionsEqual","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","getUTF16BE_TextDecoder","getPlatformTextDecoder","hasTextDecoder","createStringBuilder","decodeUTF16LE","standardDecodeUTF16LE","compatDecodeUTF16LE","capacity","StringBuilder","CompatStringBuilder","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","_pieces","_piecesLen","escapeNewLine","TextChange","oldPosition","oldText","newText","oldEnd","newLength","newEnd","writeSize","_writeStringSize","_writeString","_readString","compressConsecutiveTextChanges","prevEdits","currEdits","compressor","TextChangeCompressor","compress","_prevEdits","_currEdits","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","cleaned","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","preText","postText","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","WordCharacterClassifier","getMapForWordSeparators","USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","_defaultConfig","timeBudget","getWordAtText","textOffset","prevRegexIndex","regexIndex","thisMatch","_findRegexMatchEnclosingPosition","stopPos","matchIndex","AtomicTabMoveOperations","prevTabStopPosition","prevTabStopVisibleColumn","whitespaceVisibleColumn","currentVisibleColumn","targetVisibleColumn","DeleteOperations","prevEditOperationType","deleteSelection","rightOfPosition","autoClosingPairsOpen","character","autoClosingPairCandidates","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","found","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","getDeleteRange","lastIndentationColumn","toColumn","getPositionAfterDeleteLeft","lastCutRange","CursorMoveCommands","useLogicalLine","_moveToLineStart","currentViewStateColumn","currentModelStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","isBeginningOfViewLine","_moveToLineStartByModel","_moveToLineStartByView","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","selectToLineNumber","selectToColumn","enteringLineNumber","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","_firstLineNumberInRange","_moveToModelPosition","_lastLineNumberInRange","findPositionInViewportIfOutside","newViewLineNumber","noOfColumns","halfLine","toViewColumn","toModelLineNumber","toModelColumn","_moveToViewPosition","isCursorMoveArgs","cursorMoveArg","Left","Right","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortBottom","ViewPortCenter","ViewPortIfOutside","Character","HalfLine","CursorPosition","_cursorPositionBrand","MoveOperations","leftPosition","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","down","allowMoveOnFirstLine","up","_isBlankLine","relevantColumnNumber","lastColumn","SurroundSelectionCommand","charBeforeSelection","charAfterSelection","_charBeforeSelection","_charAfterSelection","firstOperationRange","secondOperationRange","TypeOperations","typeSelection","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","expectedIndentAction","nonWhitespaceIdx","expectedEnterAction","Indent","typeText","goodIndent","_goodIndentForLine","possibleTypeText","_replaceJumpToNextIndent","shouldPushStackElementBetween","keepPosition","_typeCommand","indentAction","normalIndent","increasedIndent","actualIndentation","ir","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","afterEnter","currentIndentation","chIsQuote","beforeCharacter","lineAfter","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","isBeforeClosingBrace","candidates","candidateIsMatch","relevantText","pair","lastChar","autoClosingPairsCloseByEnd","includes","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","isBeforeCloseBrace","_isBeforeClosingBrace","characterBefore","forceTokenization","scopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","surroundingPairs","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","selectedText","selectionText","closeCharacter","electricChars","electricAction","onElectricCharacter","matchOpenBracket","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","selectionsWhenCompositionStarted","currentChar","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","WordOperations","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","possiblePosition","WordPartOperations","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","modelOptions","_cursorMoveConfigurationBrand","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","electricCharacter","getElectricCharacters","electricCharacterSupport","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","CursorState","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","SingleCursorState","fromModelState","fromModelSelection","_singleCursorStateBrand","_computeSelection","EditOperationResult","_editOperationResultBrand","isQuote","InternalEditorAction","_precondition","_run","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","editorTextFocus","textInputFocus","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","hoverVisible","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","TokenizationRegistry","_factories","_colorMap","changedLanguages","support","registerFactory","myData","TokenizationSupportFactoryData","tokenizationSupport","isResolved","setColorMap","getColorMap","getDefaultBackground","_registry","_factory","_resolvePromise","_isResolved","createTokenizationSupport","CompletionItemKinds","InlineCompletionTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","InlayHintKind","TokenMetadata","getFontStyle","Token","_tokenBrand","TokenizationResult","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","isLocationLink","originSelectionRange","targetSelectionRange","byKind","toIcon","strict","FoldingRangeKind","Comment","Imports","Region","ILanguageService","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","_inString","_inComment","_inRegEx","notIn","standardToken","getTokenCount","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","toCharCode","AutoClosingPairs","appendEntry","CharacterPairSupport","_autoClosingPairs","brackets","colorizedBracketPairs","_colorizedBracketPairs","filterValidBrackets","__electricCharacterSupport","docComment","_autoCloseBefore","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","_surroundingPairs","getColorizedBrackets","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","reversedBracketRegex","reversedRegex","bracketText","isOpen","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","resetGlobalRegex","reg","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","OnEnterSupport","_brackets","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","previousLineText","beforeEnterText","afterEnterText","regResult","beforeText","afterText","_safeRegExp","LanguageConfigurationServiceChangeEvent","affects","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","globalConfigChanged","localConfigChanged","overrides","overrideLangName","isRegisteredLanguageId","LanguageConfigurationRegistry","computeConfig","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","overrideIdentifier","validateBracketPairs","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","ComposedLanguageConfiguration","getResolvedConfiguration","getComments","getIndentRulesSupport","indentRulesSupport","getPrecedingValidLine","getLanguageIdAtPosition","resultLineNumber","getInheritIndentForLine","honorIntentialIndent","precedingUnIgnoredLine","precedingUnIgnoredLineContent","previousLine","previousLineIndentMetadata","stopLine","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","inheritLine","enterResult","getIndentForEnter","scopedLineText","embeddedLanguage","endScopedLineTokens","getScopedLineTokens","beforeEnterResult","beforeEnterIndent","currentLineIndent","afterEnterAction","beforeEnter","afterEnterIndent","getIndentActionForType","beforeTypeText","afterTypeText","getEnterAction","oneLineAboveScopedLineTokens","getIndentationAtPosition","columnNumber","_resolved","_order","LanguageConfigurationContribution","_resolve","configs","wordPattern","_electricCharacter","_onEnterSupport","_handleComments","characterPair","foldingRules","getWordDefinition","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","ModesRegistry","EditorModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","getLanguages","PLAINTEXT_LANGUAGE_ID","PLAINTEXT_EXTENSION","mimetypes","offSide","Configuration","registerDefaultConfigurations","NullState","nullTokenize","nullTokenizeEncoded","Uint32Array","createScopedLineTokens","tokenCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","lastCharOffset","_scopedLineTokensBrand","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","actualLineContent","ignoreBracketsInToken","RichEditBracket","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","isClose","groupFuzzyBrackets","N","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g2","newG","oldG","currentOpen","currentClose","RichEditBrackets","_richEditBracketsBrand","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","collectSuperstrings","currentIndex","lengthcmp","unique","pieces","createBracketOrRegExp","toReversedString","prepareBracketForRegExp","insertWordBoundaries","regexStr","lastInput","lastOutput","BracketsUtils","reversedText","matchOffset","matchLength","absoluteMatchOffset","reversedLineText","reversedSubstr","_findPrevBracketInText","bracketRegex","findNextBracketInText","fallback","tokenizeEncoded","hasEOL","tokenizeToString","_tokenizeToString","languageIdCodec","tokenizeLineToHTML","viewLineTokens","useNbsp","prevIsSpace","partContent","getInlineStyle","tokenizationResult","OverviewRulerLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","src","_textModelResolvedOptionsBrand","defaultEOL","createChangeEvent","FindMatch","_findMatchBrand","ValidAnnotatedEditOperation","SearchData","simpleSearch","ApplyEditsResult","reverseEdits","trimAutoWhitespaceLineNumbers","shouldSynchronizeModel","isTooLargeForSyncing","isForSimpleWidget","BaseAstNode","_length","PairAstNode","openingBracket","closingBracket","missingOpeningBracketIds","listHeight","childrenLength","getChild","canBeReused","openBracketIds","computeMinIndentation","textModel","ListAstNode","_missingOpeningBracketIds","cachedMinIndentation","item1","item2","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","throwIfImmutable","makeLastElementMutable","childCount","mutable","toMutable","setChild","makeFirstElementMutable","lastLength","handleChildrenChanged","unopenedBrackets","minIndentation","childOffset","_item1","_item2","_item3","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","columnCount","firstNonWsColumn","BracketAstNode","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds","TextEditInfo","BeforeEditPositionMapper","documentLength","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","hasRegExp","_regExpGlobal","denseKeyProvider","openingText","getKey","openingBrackets","closingText","openingTextId","getRegExpStr","regExpGlobal","regExpStr","getToken","findClosingTokenText","openingBracketIds","needsWordBoundaries","LanguageAgnosticBracketTokens","languageIdToBracketTokens","didLanguageChange","existing","newRegExpStr","createFromLanguage","getSingleLanguageBracketTokens","singleLanguageBracketTokens","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","zero","lengthZero","lengthIsZero","lengthToObj","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","lengthDiffNonNegative","length1","length2","lineCount1","lineCount2","colCount2","colCount1","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","lengthsToRange","lengthStart","lengthEnd","colCount","lengthOfString","concat23Trees","readNode","concat23TreesOfSameHeight","createImmutableLists","node1","node2","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","nodeToPrependOfCorrectHeight","NodeReader","lastOffset","nextNodes","offsets","idxs","readLongestNodeAt","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","parseDocument","tokenizer","oldNode","parser","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","parseChild","maxCacheableLength","cachedNode","skip","astNode","nextToken","bracketId","emptyArr","SmallImmutableSet","additionalItems","cached","keyProvider","newItem","identityKeyProvider","DenseKeyProvider","TextBufferTokenizer","bracketTokens","NonPeekableTextBufferTokenizer","didPeek","textBufferLineCount","textBufferLastLineLength","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","getMetadata","isOther","FastTokenizer","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","curOffset","uriGetComparisonKey","SingleModelEditStackData","beforeVersionId","afterVersionId","beforeEOL","afterEOL","beforeCursorState","afterCursorState","alternativeVersionId","getAlternativeVersionId","getModelEOL","textChanges","serialize","necessarySize","_writeSelectionsSize","_writeSelections","_readSelections","changeCount","SingleModelEditStackElement","deserialize","matchesResource","canAppend","_applyUndo","_applyRedo","heapSize","MultiModelEditStackElement","editStackElements","_isOpen","_editStackElementsArr","_editStackElementsMap","editStackElement","resources","prepareUndoRedo","isEditStackElement","EditStack","undoRedoService","_undoRedoService","lastElement","getLastElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","pushEOL","setEOL","pushEditOperation","editOperations","applyEdits","_computeCursorState","textChange","TextModelPart","assertNotDisposed","GuidesTextModelPart","_computeIndentLevel","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","getBracketPairsInRange","activeGuides","nextGuides","BracketPairGuidesClassNames","openingBracketRange","guideVisibleColumn","closingBracketRange","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","firstNonWsIndex","nestingLevel","bracketPair","lastVisibleColumnCount","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","PrefixSumComputer","prefixSumValidIndex","oldValues","oldPrefixSum","insertValuesLen","maxCount","_getPrefixSum","sum","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","_isValid","_validEndIndex","_prefixSum","_indexBySum","_ensureValid","viewLinesAbove","_invalidate","sumAbove","_prefixSumIndexOfResultBrand","BracketInfo","isInvalid","BracketPairInfo","BracketPairWithMinIndentationInfo","BracketPairsTree","didChangeEmitter","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","handleDidChangeBackgroundTokenizationState","wasUndefined","handleDidChangeTokens","handleContentChanged","previousAst","isPure","previousAstClone","getBracketsInRange","collectBrackets","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","nodeOffsetStart","nodeOffsetEnd","nodeOffset","openingBracketEnd","BracketPairsTextModelPart","bracketPairsTree","bracketsRequested","updateBracketPairsTree","isDocumentSupported","maxSupportedDocumentLength","getValueLength","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","createDisposableRef","_bracket","maxDuration","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","totalCallCount","searchPrevMatchingBracketInRange","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","findPrevBracket","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","savedCounts","counts","resetCounts","searchInRange","_searchCanceledBrand","ColorizedBracketPairsDecorationProvider","ColorProvider","colorizationOptions","bracketsInRange","getInlineClassName","getAllDecorations","unexpectedClosingBracketClassName","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aCharCode","bCharCode","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","MAX_ALLOWED_TAB_SIZE_GUESS","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeStickiness","_setNodeStickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","setOptions","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","requestNormalizeDelta","intervalSearch","filterOwnerId","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","nodesOfInterest","searchForEditing","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","nodeMaxEnd","editDelta","include","intervalStart","intervalEnd","treeInsert","recomputeMaxEndWalkToRoot","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","intervalCompare","leftest","resetSentinel","yWasRed","computeMaxEnd","leftMaxEnd","rightMaxEnd","TreeNode","piece","size_left","lf_left","righttest","calculateSize","calculateLF","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","LineStarts","lineStarts","cr","lf","crlf","createLineStartsFast","readonly","rLength","createLineStarts","Piece","bufferIndex","StringBuffer","PieceTreeSnapshot","BOM","_tree","_BOM","iterate","getPieceContent","PieceTreeSearchCache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","hasInvalidVal","PieceTreeBase","chunks","eolNormalized","_lastChangeBufferPos","_lineCnt","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","newEOL","createSnapshot","leftLen","accumualtedValInCurrentIndex","getAccumulatedValue","lfCnt","originalOffset","lineStartOffset","nodeAt2","getValueInRange2","offsetInBuffer","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","searchText","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","searchStringLen","lastMatchIndex","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","deleteNodes","insertContentToNodeRight","rbInsertLeft","cnt","startNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","secondNode","nPiece","adjustCarriageReturnFromNext","previousCharOffset","nodes","splitText","endPos","newPiece","prevAccumulatedValue","accumulatedValue","originalLineNumber","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","leftRet","currentContent","prevNode","PieceTreeTextBuffer","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","getBOM","getRangeAt","_getEndOfLine","getValueLengthInRange","getCharacterCountInRange","fromOffset","toOffset","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","validatedRange","textMightContainNonBasicASCII","validText","lastLineLength","strEOL","bufferEOL","expectedStrEOL","sortIndex","rangeOffset","rangeLength","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","contentChanges","_doApplyEdits","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","finish","_finish","lastChunk","newLineStarts","ContiguousMultilineTokens","_tokens","appendLineTokens","ContiguousMultilineTokensBuilder","ContiguousGrowingArray","_default","deleteIndex","TokenizationStateStore","initialState","_lineBeginState","_lineNeedsTokenization","_firstLineNeedsTokenization","invalidLineStartIndex","markMustBeTokenized","getBeginState","setEndState","previousEndState","TextModelTokenization","_textModel","_languageIdCodec","_isScheduled","_tokenizationStateStore","_resetTokenizationState","clearTokens","isFlush","_beginBackgroundTokenization","handleDidChangeAttached","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","deadline","_backgroundTokenizeWithDeadline","endTime","_backgroundTokenizeForAtLeast1ms","sw","tokenizedLineNumber","_tokenizeOneInvalidLine","setTokens","_tokenizeViewport","_updateTokensUntilLine","lineStartState","safeTokenize","tokenizeLineWithEdit","curLineContent","firstInvalidLineNumber","nonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","encodeLanguageId","EMPTY_LINE_TOKENS","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","fromTokenStartOffset","fromTokenEndOffset","lastEnd","_otherTokens","myTokens","otherTokens","otherTokensCount","ContiguousTokensStore","_lineTokens","getTokens","topLevelLanguageId","rawLineTokens","getDefaultMetadata","hasDifferentLanguageId","_ensureLine","_deleteLines","_insertLines","checkEquality","_massageTokens","oldTokens","_equals","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","deleteEnding","lastLineTokens","deleteBeginning","SparseTokensStore","_isComplete","isComplete","setPartial","_firstRange","getRange","_lastRange","insertPosition","removeTokens","addSparseTokens","aTokens","pieceIndex","_findFirstPieceWithLine","bTokens","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","firstCharCode","createTextBufferBuilder","createTextBufferFactory","createTextBuffer","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","_eos","resultCnt","resultLength","TextModel","creationOptions","associatedResource","_languageService","_languageConfigurationService","_onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","_onDidChangeLanguage","_onDidChangeLanguageConfiguration","_onDidChangeTokens","_onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeInjectedText","_eventEmitter","DidChangeContentEmitter","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","_associatedResource","_attachedEditorCount","_bufferDisposable","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposing","_languageRegistryListener","_lastDecorationId","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_semanticTokens","_tokenization","_bracketPairColorizer","_guidesTextModelPart","_decorationProvider","beginDeferredEmit","endDeferredEmit","guessedIndentation","slowEvent","contentChangedEvent","fastEvent","rawContentChangedEvent","handleTokenizationProgress","completed","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","_setValueFromTextBuffer","_createContentChanged2","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","_increaseVersionId","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","smallLineCharCount","longLineCharCount","getFormattingOptions","_newOpts","bracketColorizationOptions","removeUnusualLineTerminators","findMatches","getInitialUndoRedoSnapshot","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","rawSearchScope","searchRanges","searchScope","uniqueSearchRanges","matchMapper","searchParams","parseSearchRequest","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","currentEOL","_validateEditOperation","rawOperation","_validateEditOperations","_pushEditOperations","incomingEdits","editsAreNearCursors","foundEditNearSel","selIsAbove","selIsBelow","trimLineNumber","allowTrimLine","editText","trimRange","resultingAlternativeVersionId","rangeStart","_applyUndoRedoEdits","oldLineCount","newLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","affectedLines","lineChangeEvents","_getInjectedTextInLine","_changeDecorations","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","newStickiness","TRACKED_RANGE_OPTIONS","getDecorationOptions","decorationId","getNodeRange","getLinesDecorations","_getDecorationsInRange","getAllInjectedText","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","nodeIsInOverviewRuler","nodeRange","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","backgroundTokenizationCompleted","minChangedLineNumber","maxChangedLineNumber","hasChange","lineHasChange","_emitModelTokensChangedEvent","semanticTokensApplied","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","resetTokenization","tokenizeIfCheap","_getLineTokens","syntacticTokens","setMode","oldLanguage","newLanguage","getWordAtPosition","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","indentOfLine","isNodeInOverviewRuler","isNodeInjectedText","DEFAULT_CREATION_OPTIONS","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","_ensureNodesHaveRanges","_intervalSearch","r0","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","_resolveColor","ModelDecorationMinimapOptions","ModelDecorationInjectedTextOptions","attachedData","ModelDecorationOptions","hoverMessage","glyphMarginHoverMessage","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","createDynamic","handleBeforeFire","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","_fastEmitter","_slowEmitter","_deferredEvent","SearchParams","isMultilineRegexSource","canUseSimpleSearch","nextChCode","createFindMatch","rawMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","TextModelSearch","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","lfCounter","match0","lineFeedCountBeforeMatch","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","_getMultilineMatchRange","isValidMatch","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","_findFirstMatchInLine","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","leftIsWordBounday","matchStartIndex","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_searchRegex","_prevMatchStartIndex","_prevMatchLength","computeIndentLevel","ID_EDITOR_WORKER_SERVICE","IEditorWorkerService","reverseEndianness","b0","b1","b2","b3","toLittleEndianBuffer","uint8Arr","encodeSemanticTokensDto","semanticTokens","encodeSemanticTokensDtoSize","deltas","isSemanticTokens","isSemanticTokensEdits","DocumentSemanticTokensResult","provider","hasDocumentSemanticTokensProvider","getDocumentSemanticTokensProviders","orderedGroups","getDocumentSemanticTokens","lastProvider","lastResultId","providers","results","provideDocumentSemanticTokens","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","provideDocumentRangeSemanticTokens","documentSemanticTokensProvider","getLegend","resultId","releaseDocumentSemanticTokens","documentRangeSemanticTokensProvider","ILanguageFeatureDebounceService","IdentityHash","_hashes","WeakMap","pool","FeatureDebounceInformation","_logService","_max","_key","avg","_overall","LanguageFeatureDebounceService","for","feature","_overallAverage","ILanguageFeaturesService","IMarkerDecorationsService","IModelService","computeModelSha1","shaComputer","_modelEventListeners","_languageSelection","_languageSelectionListener","_disposeLanguageSelection","setLanguage","languageSelection","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","sha1","ModelService","_configurationService","_resourcePropertiesService","_languageFeatureDebounceService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","_semanticStyling","SemanticStyling","_updateModelOptions","SemanticColoringFeature","parsedTabSize","parsedIndentSize","newDefaultEOL","_shouldRestoreUndoStack","getCreationOptions","_readModelOptions","oldOptionsByLanguageAndResource","modelId","oldOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","sha1IsEqual","past","future","setElementsValidFlag","createModel","getModels","getSemanticTokensProviderStyling","_schemaShouldMaintainUndoRedoElements","getUriComparisonKey","maintainUndoRedoStack","maxMemory","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","oldLanguageId","newLanguageId","SEMANTIC_HIGHLIGHTING_SETTING_ID","isSemanticColoringEnabled","setting","semanticHighlighting","semanticStyling","modelService","languageFeatureDebounceService","_watchers","ModelSemanticColoring","deregister","modelSemanticColoring","handleSettingOrThemeChange","affectsConfiguration","_caches","SemanticTokensResponse","stylingProvider","_provider","_debounceInformation","REQUEST_MIN_DELAY","REQUEST_MAX_DELAY","_fetchDocumentSemanticTokens","_fetchDocumentSemanticTokensNow","_currentDocumentResponse","_currentDocumentRequestCancellationTokenSource","_documentProvidersChangeListeners","_setDocumentSemanticTokens","bindDocumentChangeListeners","cancellationTokenSource","pendingChanges","contentChangeListener","styling","isExpectedError","srcOffset","currentResponse","rescheduleIfNeeded","deltaLength","srcData","destData","srcLastStart","destLastStart","copyCount","_copy","area","singleChange","applyEdit","ITextModelService","SparseMultilineTokens","getMaxDeltaLine","SparseMultilineTokensStorage","_updateEndLineNumber","deltaRange","bDeltaLine","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","acceptDeleteRange","acceptInsertText","_tokenCount","_getDeltaLine","_getStartCharacter","_getEndCharacter","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","isInsertingPreciselyOneWordCharacter","tokenLength","SemanticTokensProviderStyling","_legend","_hashTable","HashTable","_hasWarnedOverlappingTokens","tokenTypeIndex","tokenModifierSet","encodedLanguageId","getLevel","tokenTypes","tokenModifiers","modifierSet","modifierIndex","tokenStyle","getTokenStyleMetadata","italicBit","boldBit","underlineBit","strikethroughBit","foregroundBits","warnOverlappingSemanticTokens","toMultilineTokens2","tokensPerArea","lastStartCharacter","tokenStartIndex","smallTokenEndIndex","bigTokenEndIndex","areaLine","prevLineNumber","prevStartCharacter","prevEndCharacter","deltaCharacter","HashTableEntry","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","_nullOutEntries","_hash2","n1","n2","_hashFunc","oldElements","oldNext","_add","ITextResourceConfigurationService","ITextResourcePropertiesService","UnicodeTextModelHighlighter","codePointHighlighter","CodePointHighlighter","getCandidateCodePoints","buildRegExpCharClassExpr","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","highlightReason","shouldHighlightNonBasicASCII","MAX_RESULT_LENGTH","primaryConfusable","notAmbiguousInLocales","confusableWith","allowedCodePoints","cp","isAllowedInvisibleCharacter","wordContext","hasBasicASCIICharacters","hasNonConfusableNonBasicAsciiCharacter","AccessibilityHelpNLS","InspectTokensNLS","GoToLineNLS","QuickHelpNLS","QuickCommandNLS","QuickOutlineNLS","StandaloneCodeEditorNLS","ToggleHighContrastNLS","StandaloneServicesNLS","noSelection","singleSelectionRange","singleSelection","multiSelectionRange","multiSelection","emergencyConfOn","openingDocs","readonlyDiffEditor","editableDiffEditor","readonlyEditor","editableEditor","changeConfigToOnMac","changeConfigToOnWinLinux","auto_on","auto_off","tabFocusModeOnMsg","tabFocusModeOnMsgNoKb","tabFocusModeOffMsg","tabFocusModeOffMsgNoKb","openDocMac","openDocWinLinux","outroMsg","showAccessibilityHelpAction","inspectTokensAction","gotoLineActionLabel","helpQuickAccessActionLabel","quickCommandActionLabel","quickCommandHelp","quickOutlineActionLabel","quickOutlineByCategoryActionLabel","editorViewAccessibleLabel","accessibilityHelpMessage","toggleHighContrast","bulkEditServiceSummary","ModelRawFlush","LineInjectedText","lastOriginalOffset","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","_mergeChangeEvents","HorizontalGuidesState","IndentGuide","IndentGuideHorizontalLine","LineTokens","decoder","_lineTokensBrand","_tokensCount","defaultMetadata","defaultTokenMetadata","slicedEquals","sliceFromTokenIndex","sliceTokenCount","decodeLanguageId","findIndexInTokensArray","SliceLineTokens","desiredIndex","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","_startOffset","_endOffset","_deltaOffset","LineDecoration","_lineDecorationBrand","lineDecorations","minLineColumn","ORDER","typeCmp","_typeCompare","DecorationSegment","Stack","stopOffsets","consumeLowerThan","maxStopOffset","nextStartOffset","_metadata","stopOffset","LineDecorationsNormalizer","currentStartOffset","currentEndOffset","LinePart","_linePartBrand","isPseudoAfter","LineRange","otherLineRange","RenderLineInput","fauxIndentLength","wsmiddotDiff","middotDiff","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","DomPosition","CharacterMapping","partCount","_absoluteOffsets","partData","setColumnInfo","partAbsoluteOffset","charOffsetToPartData","getPartIndex","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","_renderLineOutputBrand","renderViewLine","beforeCount","afterCount","lineDecoration","resolveRenderLineInput","RenderLineOutput2","renderViewLine2","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","onlyAtSpaces","lastTokenEndIndex","lastSpaceOffset","currTokenStart","piecesCount","pieceEndIndex","isControlCharacter","lastLinePart","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","wasInWhitespace","currentSelectionIndex","tmpIndent","isInWhitespace","lastEndIndex","generateWhitespace","isSingleTrailingSpace","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","charOffsetInPart","partDisplacement","prevPartContentCnt","partEndIndex","partType","partRendersWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","partContentCnt","_charIndex","_visibleColumn","to4CharHex","Viewport","_viewportBrand","MinimapLinesRenderingData","ViewLineData","_viewLineDataBrand","ViewLineRenderingData","InlineDecoration","SingleLineInlineDecoration","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","ColorZone","_colorZoneBrand","OverviewRulerZone","_overviewRulerZoneBrand","_colorZone","setColorZone","colorZone","getColorZones","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_colorZonesInvalid","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","_id2Color","newZones","colorZonesInvalid","halfMinimumHeight","allColorZones","offset1","offset2","ycenter","halfHeight","ViewModelDecorations","linesCollection","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","_getOrCreateViewModelDecoration","modelDecoration","cacheIsValid","_getDecorationsViewportData","viewportRange","modelDecorations","decorationsInViewport","decorationsInViewportLen","isModelDecorationVisible","viewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","isModelDecorationInComment","isModelDecorationInString","testTokensInRange","isFirstLine","isEndLine","tokenIdx","callbackResult","SelectionAnchorSet","SelectionAnchorController","selectionAnchorSetContextKey","bindTo","modelChangeListener","setSelectionAnchor","previousDecorations","newDecorationId","goToSelectionAnchor","anchorPosition","selectFromAnchorToCursor","cancelSelectionAnchor","SetSelectionAnchor","_accessor","GoToSelectionAnchor","SelectFromAnchorToCursor","CancelSelectionAnchor","overviewRulerBracketMatchForeground","JumpToBracketAction","BracketMatchingController","jumpToBracket","SelectToBracketAction","selectBrackets","selectToBracket","BracketsData","_lastBracketsData","_lastVersionId","_updateBracketsSoon","_updateBrackets","_matchBrackets","newCursorPosition","enclosingBrackets","nextBracket","selectFrom","selectTo","_recomputeBrackets","bracketData","previousData","positionsLen","newData","newDataLen","previousIndex","previousLen","_DECORATION_OPTIONS_WITH_OVERVIEW_RULER","_DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER","bracketMatchBackground","bracketMatchBorder","MoveCaretCommand","isMovingLeft","_isMovingLeft","rangeBefore","rangeAfter","MoveCaretAction","MoveCaretLeftAction","MoveCaretRightAction","TransposeLettersAction","middlePosition","beginPosition","leftChar","rightChar","replaceRange","CLIPBOARD_CONTEXT_MENU_GROUP","supportsCut","supportsCopy","supportsPaste","CutAction","CopyAction","submenu","PasteAction","ExecCommandCopyWithSyntaxHighlightingAction","registerExecCommandImpl","browserCommand","clipboardService","clipboardText","CodeLensModel","lenses","_disposables","symbol","getCodeLensModel","ordered","providerRanks","provideCodeLenses","itemResolveCount","resolveCodeLens","ICodeLensCache","CacheItem","CodeLensCache","storageService","_fakeProvider","oldkey","raw","_deserialize","onWillSaveState","_serialize","copyItems","copyModel","CodeLensViewZone","onHeight","_onHeight","_lastHeight","CodeLensContentWidget","_commands","_isEmpty","updatePosition","withCommands","hasSymbol","lens","getCommand","_widgetPosition","CodeLensHelper","_removeDecorations","_addDecorations","_addDecorationsCallbacks","resultingDecorations","CodeLensWidget","viewZoneChangeAccessor","updateCallback","_decorationIds","codeLensData","_viewZone","_viewZoneId","_createContentWidgetIfNecessary","_contentWidget","updateCodeLensSymbols","computeIfNecessary","updateCommands","symbols","getLineNumber","CodeLensContribution","debounceService","_codeLensCache","_localToDispose","_lenses","_oldCodeLensModels","_provideCodeLensDebounce","_resolveCodeLensesDebounce","salt","_resolveCodeLensesScheduler","_resolveCodeLensesInViewport","_onModelChange","_updateLensStyle","_styleClassName","_localDispose","_currentCodeLensModel","_getLayoutInfo","codeLensHeight","editorFontInfo","fontFamilyVar","fontFeaturesVar","newStyle","_getCodeLensModelPromise","_resolveCodeLensesPromise","cachedLenses","_renderCodeLensSymbols","cachedLensesNow","registration","scheduler","newDelay","_resolveCodeLensesInViewportSoon","decorationsAccessor","viewZonesAccessor","lastLensLineNumber","_disposeAllLenses","decChangeAccessor","lastGroup","viewZoneAccessor","codeLensIndex","groupsIndex","symbolsLineNumber","codeLensLineNumber","toResolve","resolvePromise","resolvedSymbols","quickInputService","codelensController","pick","canPickMany","BlockCommentCommand","_insertSpace","_usedEndToken","needleLength","haystackLength","_createOperationsForBlockComment","startToken","endToken","startLineText","endLineText","ops","lineBetweenTokens","startLineAfterStartToken","endLineBeforeEndToken","_createRemoveBlockCommentOperations","_createAddBlockCommentOperations","startTokenEditOperation","endTokenEditOperation","LineCommentCommand","ignoreFirstLine","_tabSize","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","commentStr","ignore","commentStrOffset","commentStrLength","shouldRemoveComments","onlyWhitespaceLines","lineContentStartOffset","_haystackHasNeedleAtOffset","commentStrEndOffset","supported","_gatherPreflightCommentStrings","_analyzeLines","_executeLineComments","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","_attemptRemoveBlockComment","startTokenAllowedBeforeColumn","_executeBlockComment","_gatherPreflightData","afterCommentStr","isTab","columnSize","minVisibleColumn","nextVisibleColumn","CommentLineAction","commentsOptions","ToggleCommentLineAction","AddLineCommentAction","RemoveLineCommentAction","BlockCommentAction","thisLen","otherLen","StackElement","CursorUndoRedoController","_isCursorUndoRedo","_undoStack","_redoStack","prevState","isEqualToLastUndoStack","cursorUndo","_applyState","cursorRedo","stackElement","CursorUndo","CursorRedo","DragAndDropCommand","targetPosition","targetSelection","hasTriggerModifier","DragAndDropController","_onEditorMouseDown","_onEditorMouseUp","_onEditorMouseDrag","_onEditorMouseDrop","_onEditorMouseDropCanceled","onEditorKeyDown","onEditorKeyUp","onEditorBlur","_dndDecorationIds","_mouseDown","_modifierPressed","_dragSelection","_removeDecoration","TRIGGER_KEY_VALUE","mouseEvent","possibleSelections","showAt","_hitContent","_hitMargin","primarySelection","_DECORATION_OPTIONS","outlineService","getTopLevelSymbols","TreeElement","OutlineElement","OutlineGroup","OutlineModel","_groups","cts","findId","displayName","provideDocumentSymbols","_makeOutlineElement","newProvider","_compact","childInfo","roots","asListOfDocumentSymbols","bucket","_flattenDocumentSymbols","overrideContainerLabel","tags","containerName","selectionRange","IOutlineModelService","OutlineModelService","debounces","promiseCnt","outlineModel","_err","IEditorCancellationTokens","ctxCancellableOperation","removeFn","EditorKeybindingCancellationTokenSource","_unregister","EditorState","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","FindDecorations","_overviewRulerApproximateDecorations","_findScopeDecorationIds","_rangeHighlightDecorationId","_highlightedDecorationId","_startPosition","_allDecorations","getFindScope","getFindScopes","findScopeDecorationId","newStartPosition","setCurrentFindMatch","_getDecorationIndex","getCurrentMatchesPosition","desiredRange","candidateOpts","_FIND_MATCH_DECORATION","_CURRENT_FIND_MATCH_DECORATION","nextMatch","newCurrentDecorationId","matchPosition","lineBeforeEnd","lineBeforeEndMaxColumn","_RANGE_HIGHLIGHT_DECORATION","findScopes","findMatchesOptions","newOverviewRulerApproximateDecorations","_FIND_MATCH_NO_OVERVIEW_DECORATION","approxPixelsPerLine","mergeLinesDelta","prevStartLineNumber","_FIND_MATCH_ONLY_OVERVIEW_DECORATION","newFindMatchesDecorations","findScope","_FIND_SCOPE_DECORATION","matchBeforePosition","matchAfterPosition","ReplaceAllCommand","editorSelection","replaceStrings","_editorSelection","_replaceStrings","_trackedEditorSelectionId","o1","o2","resultOps","buildReplaceStringWithCasePreserved","containsHyphens","validateSpecificSpecialCharacter","containsUnderscores","buildReplaceStringForSpecificSpecialCharacter","specialCharacter","doesContainSpecialCharacter","splitPatternAtSpecialCharacter","splitMatchAtSpecialCharacter","replaceString","splitValue","StaticValueReplacePattern","staticValue","DynamicPiecesReplacePattern","ReplacePattern","ReplacePiece","hasReplacementPatterns","buildReplaceString","_substitute","caseOps","lenOps","opIdx","ReplacePieceBuilder","_lastCharIndex","_currentStaticPiece","emitUnchanged","toCharIndex","_emitStatic","emitStatic","emitMatchIndex","parseReplaceString","nextNextChCode","CONTEXT_FIND_WIDGET_VISIBLE","CONTEXT_FIND_INPUT_FOCUSED","CONTEXT_REPLACE_INPUT_FOCUSED","ToggleCaseSensitiveKeybinding","ToggleWholeWordKeybinding","ToggleRegexKeybinding","ToggleSearchScopeKeybinding","TogglePreserveCaseKeybinding","FIND_IDS","StartFindAction","StartFindWithSelection","StartFindWithArgs","NextMatchFindAction","PreviousMatchFindAction","NextSelectionMatchFindAction","PreviousSelectionMatchFindAction","StartFindReplaceAction","CloseFindWidgetCommand","ToggleCaseSensitiveCommand","ToggleWholeWordCommand","ToggleRegexCommand","ToggleSearchScopeCommand","TogglePreserveCaseCommand","ReplaceOneAction","ReplaceAllAction","SelectAllMatchesAction","MATCHES_LIMIT","RESEARCH_DELAY","FindModelBoundToEditorModel","_startSearchingTimer","_updateDecorationsScheduler","research","_ignoreModelContentChanged","onFindReplaceStateChange","isReplaceRevealed","moveCursor","newFindScope","_findMatches","currentMatchesPosition","matchAfterSelection","changeMatchInfo","_moveToNextMatch","_hasMatches","matchesCount","_cannotFind","_setCurrentFindMatch","matchesPosition","_prevSearchPosition","isUsingLineStops","_moveToPrevMatch","isRecursed","canNavigateBack","nextMatchRange","prevMatchRange","_getSearchRange","prevMatch","moveToPrevMatch","_nextSearchPosition","canNavigateForward","_getNextMatch","forceMove","moveToNextMatch","_getReplacePattern","fromStaticValue","replacePattern","_executeEditorCommand","_largeReplaceAll","_regularReplaceAll","modelText","resultText","selectAllMatches","FindOptionsWidget","keybindingService","_hideSoon","_keybindingService","inputActiveOptionBorderColor","inputActiveOptionForegroundColor","inputActiveOptionBackgroundColor","_keybindingLabelFor","wholeWords","isRevealed","_revealTemporarily","_applyTheme","actionId","lookupKeybinding","getLabel","highlightFindOptions","inputStyles","widgetBackground","widgetForeground","widgetShadowColor","hcBorder","effectiveOptionValue","override","FindReplaceState","_onFindReplaceStateChange","_searchString","_replaceString","_isRevealed","_isReplaceRevealed","_isRegex","_isRegexOverride","_wholeWord","_wholeWordOverride","_matchCase","_matchCaseOverride","_preserveCase","_preserveCaseOverride","_searchScope","_matchesPosition","_matchesCount","_currentMatch","_loop","_isSearching","_filters","actualIsRegex","actualWholeWord","actualMatchCase","actualPreserveCase","currentMatch","updateHistory","isSearching","filters","oldEffectiveIsRegex","oldEffectiveWholeWords","oldEffectiveMatchCase","oldEffectivePreserveCase","newSearchScope","existingSearchScope","isRegexOverride","wholeWordOverride","matchCaseOverride","preserveCaseOverride","canNavigateInLoop","showHistoryKeybindingHint","getElectronAccelerator","findSelectionIcon","findCollapsedIcon","findExpandedIcon","findReplaceIcon","findReplaceAllIcon","findPreviousMatchIcon","findNextMatchIcon","NLS_FIND_INPUT_LABEL","NLS_FIND_INPUT_PLACEHOLDER","NLS_PREVIOUS_MATCH_BTN_LABEL","NLS_NEXT_MATCH_BTN_LABEL","NLS_TOGGLE_SELECTION_FIND_TITLE","NLS_CLOSE_BTN_LABEL","NLS_REPLACE_INPUT_LABEL","NLS_REPLACE_INPUT_PLACEHOLDER","NLS_REPLACE_BTN_LABEL","NLS_REPLACE_ALL_BTN_LABEL","NLS_TOGGLE_REPLACE_MODE_BTN_LABEL","NLS_MATCHES_COUNT_LIMIT_TITLE","NLS_MATCHES_LOCATION","NLS_NO_RESULTS","FIND_WIDGET_INITIAL_WIDTH","PART_WIDTH","FIND_INPUT_AREA_WIDTH","MAX_MATCHES_COUNT_WIDTH","FIND_INPUT_AREA_HEIGHT","ctrlEnterReplaceAllWarningPromptedKey","FindWidgetViewZone","stopPropagationForMultiLineUpwards","textarea","isMultiline","stopPropagationForMultiLineDownwards","FindWidget","codeEditor","_cachedHeight","_revealTimeouts","_codeEditor","_controller","_contextViewProvider","_storageService","_ctrlEnterReplaceAllWarningPrompted","getBoolean","_isReplaceVisible","_ignoreChangeEvent","_updateHistoryDelayer","_buildDomNode","_updateButtons","_tryUpdateWidgetWidth","_findInput","inputBox","updateAccessibilitySupport","_showViewZone","_removeViewZone","_updateToggleSelectionFindButton","globalBufferTerm","getGlobalBufferTerm","_findInputFocused","_findFocusTracker","_updateSearchScope","_replaceInputFocused","_replaceFocusTracker","_replaceInput","_layoutViewZone","_tryUpdateHeight","setRegex","setWholeWords","setCaseSensitive","setPreserveCase","_toggleSelectionFind","showRedOutline","_updateMatchesCount","_delayedUpdateHistory","_updateHistory","setEnabled","_closeBtn","findInputIsNonEmpty","_prevBtn","_nextBtn","_replaceBtn","_replaceAllBtn","_toggleReplaceBtn","setExpanded","canReplace","isSelectionMultipleLine","adjustEditorScrollTop","editorCoords","startCoords","startLeft","startTop","leftOfFindWidget","endCoords","endLeft","focusTheEditor","clearMessage","targetScrollTop","viewZone","_getHeight","adjustScroll","scrollAdjustment","editorContentWidth","editorWidth","collapsedFindWidget","reducedFindWidget","narrowFindWidget","_resized","widgetWidth","findInputWidth","totalheight","focusFindInput","focusReplaceInput","_onFindInputMouseDown","_onFindInputKeyDown","focusOnCaseSensitive","_onReplaceInputKeyDown","_sash","appendCaseSensitiveLabel","appendWholeWordsLabel","appendRegexLabel","getRegex","onDidOptionChange","getWholeWords","getCaseSensitive","onCaseSensitiveKeyDown","onRegexKeyDown","focusOnPreserve","SimpleButton","onTrigger","findPart","actionsContainer","appendPreserveCaseLabel","getPreserveCase","onPreserveCaseKeyDown","replacePart","replaceActionsContainer","_resizeSash","originalWidth","currentWidth","setFocusInputOnOptionClick","expanded","addBackgroundColorRule","findMatchHighlightBorder","findMatchBorder","findRangeHighlightBorder","resizeBorderBackground","toolbarHoverBackgroundColor","focusOutline","SEARCH_STRING_MAX_LENGTH","getSelectionSearchString","seedSearchStringFromNonEmptySelection","CommonFindController","_findWidgetVisible","_clipboardService","loadQueryState","shouldRestartFind","disposeModel","_start","forceRevealReplace","seedSearchStringFromGlobalClipboard","shouldFocus","shouldAnimate","updateSearchScope","saveQueryState","setGlobalBufferTerm","isFindInputFocused","getState","closeFindWidget","toggleCaseSensitive","toggleWholeWords","toggleRegex","togglePreserveCase","toggleSearchScope","setSearchString","ignoreWhenVisible","stateChanges","selectionSearchString","currentSelections","readFindText","writeFindText","FindController","_contextViewService","_findOptionsWidget","_super","_createFindWidget","findArgDescription","regexOverride","findInSelection","StartFindWithArgsAction","matchWholeWord","isCaseSensitive","StartFindWithSelectionAction","MatchFindAction","SelectionMatchFindAction","findInputFocused","FindCommand","MAX_FOLDING_REGIONS","MAX_LINE_NUMBER","MASK_INDENT","FoldingRegions","startIndexes","endIndexes","_startIndexes","_endIndexes","_collapseStates","_types","_parentsComputed","ensureParentIndices","parentIndexes","isInsideLast","parentIndex","getType","hasTypes","isCollapsed","arrayIndex","bit","setCollapsed","setCollapsedAllOfType","toRegion","FoldingRegion","getParentIndex","findRange","regionIndex","containedBy","containsLine","FoldingModel","decorationProvider","_updateEventEmitter","_regions","_editorDecorationIds","_isInitialized","regions","toggleCollapseState","toggledRegions","processed","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","getDecorationOption","region","editorDecorationId","newCollapseState","collapseStateChanged","newRegions","blockedLineNumers","newEditorDecorations","isBlocked","blockedLineNumber","initRange","nextCollapsed","collapsedIndex","decRange","collapsedStartLineNumber","getMemento","collapsedRanges","applyMemento","toToogle","getRegionAtLine","getAllRegionsAtLine","getRegionsInside","MAX_VALUE","levelStack","foldingModel","levels","toToggle","doCollapse","regionsInside","setCollapseStateLevelsDown","setCollapseStateLevelsUp","setCollapseStateUp","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","setCollapseStateForRest","filteredRegions","filteredRegion","setCollapseStateForMatchingLines","regExp","editorModel","setCollapseStateForType","getParentFoldLine","foldingRegion","parentFoldingIdx","getPreviousFoldLine","expectedParentIndex","getNextFoldLine","HiddenRangeModel","_hasLineChanges","_foldingModel","_foldingModelListener","updateHiddenRanges","_hiddenRanges","hiddenRanges","notifyChangeModelContent","updateHiddenAreas","newHiddenAreas","lastCollapsedStart","lastCollapsedEnd","applyHiddenRanges","hasRanges","adjustSelections","hasChanges","adjustLine","isInside","adjustedStartLine","adjustedEndLine","MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT","ID_INDENT_PROVIDER","IndentRangeProvider","maxFoldingRegions","cancelationToken","notifyTooManyRegions","markers","computeRanges","RangesCollector","foldingRangesLimit","_notifyTooManyRegions","_indentOccurrences","_foldingRangesLimit","insertFirst","toIndentRanges","maxIndent","previousRegions","endAbove","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","handleFoldingRangesChange","cancellationToken","collectSyntaxRanges","sanitizeRanges","rangeData","provideFoldingRanges","nLines","rank","_nestingLevels","_nestingLevelCounts","maxLevel","sorted","ID_INIT_PROVIDER","InitializingRangeProvider","initialRanges","timeoutTime","toDecorationRange","decorationIds","foldingRangeData","foldingExpandedIcon","foldingCollapsedIcon","FoldingDecorationProvider","autoHideFoldingControls","showFoldingHighlights","HIDDEN_RANGE_DECORATION","COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION","COLLAPSED_VISUAL_DECORATION","EXPANDED_AUTO_HIDE_VISUAL_DECORATION","EXPANDED_VISUAL_DECORATION","CONTEXT_FOLDING_ENABLED","FoldingController","_tooManyRegionsNotified","localToDispose","_isEnabled","_useFoldingProviders","_unfoldOnClickAfterEndOfLine","_restoringViewState","_currentModelHasFoldedImports","_foldingImportsByDefault","_maxFoldingRegions","updateDebounceInfo","foldingRangeProvider","hiddenRangeModel","rangeProvider","foldingRegionPromise","foldingStateMemento","foldingModelPromise","updateScheduler","cursorChangedScheduler","mouseDownInfo","foldingDecorationProvider","foldingEnabled","notify","onModelChanged","triggerFoldingModelChanged","onFoldingStrategyChanged","collapsedRegions","foldedImports","getFoldingModel","hr","onHiddenRangesChanges","onEditorMouseDown","onEditorMouseUp","getRangeProvider","foldingProviders","foldingRanges","selectionLineNumbers","iconClicked","offsetLeftInGutter","gutterOffsetX","surrounding","otherRegion","toMaybeToggle","recursive","FoldingAction","foldingController","getSelectedLines","getLineNumbers","selectionLines","foldingArgumentsConstraint","foldingArgs","UnfoldAction","_foldingController","UnFoldRecursivelyAction","_args","FoldAction","ToggleFoldAction","selectedLines","FoldRecursivelyAction","FoldAllBlockCommentsAction","FoldAllRegionsAction","UnfoldAllRegionsAction","FoldAllRegionsExceptAction","UnfoldAllRegionsExceptAction","FoldAllAction","UnfoldAllAction","FoldLevelAction","getFoldingLevel","ID_PREFIX","GotoParentFoldAction","GotoPreviousFoldAction","GotoNextFoldAction","foldBackgroundBackground","editorFoldForeground","foldBackground","editorFoldColor","EditorFontZoomIn","EditorFontZoomOut","EditorFontZoomReset","ExtensionIdentifier","_lower","alertFormattingEdits","getRealAndSyntheticDocumentFormattersOrdered","docFormatter","formatter","extensionId","rangeFormatter","provideDocumentFormattingEdits","provideDocumentRangeFormattingEdits","FormattingConflicts","_selectors","formatDocumentRangesWithSelectedProvider","editorOrModel","rangeOrRanges","progress","documentRangeFormattingEditProviderRegistry","selected","formatDocumentRangesWithProvider","workerService","computeEdits","hasIntersectingEdit","mergedA","acc","otherEdit","allEdits","rawEditsList","mergedRange","rawEdits","minimalEdits","computeMoreMinimalEdits","formatDocumentWithSelectedProvider","formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","onTypeFormattingEditProvider","autoFormatTriggerCharacters","provideOnTypeFormattingEdits","resolverService","FormatOnType","_workerService","_sessionDisposables","triggerChars","_trigger","unbind","FormatOnPaste","_callOnDispose","_callOnModel","FormatDocumentAction","progressService","showWhile","FormatSelectionAction","FormattingEdit","newEol","singleEdits","_edits","addUndoStops","_handleEolEdits","_isFullModelReplaceEdit","hasModifier","ClickLinkMouseEvent","triggerModifier","hasSideBySideModifier","triggerSideBySideModifier","isNoneOrSingleMouseDown","ClickLinkKeyboardEvent","keyCodeIsTriggerKey","triggerKey","keyCodeIsSideBySideKey","triggerSideBySideKey","ClickLinkOptions","createOptions","ClickLinkGesture","_onMouseMoveOrRelevantKeyDown","onMouseMoveOrRelevantKeyDown","_onExecute","onExecute","_onCancel","onCancel","_lastMouseMoveEvent","_hasTriggerKeyOnMouseDown","_lineNumberOnMouseDown","_onEditorMouseMove","_onEditorKeyDown","_onEditorKeyUp","_resetHandler","currentLineNumber","HoverProviderResult","executeProvider","provideHover","getHover","getHoverPromise","hasRange","hasHtmlContent","contents","HoverForeignElementAnchor","owner","canAdoptVisibleHover","lastAnchor","showAtPosition","HoverParticipantRegistry","_participants","MarkdownHover","isValidForHoverAnchor","MarkdownHoverParticipant","_openerService","hoverOrdinal","createLoadingMessage","computeSync","maxTokenizationLineLength","computeAsync","renderHoverParts","hoverParts","renderMarkdownHovers","openerService","hoverPart","markdownHoverElement","hoverContentsElement","onDidRenderAsync","onContentsChanged","renderedContents","InPlaceReplaceCommand","originalSelection","_editRange","_originalSelection","InPlaceReplaceController","editorWorkerService","currentRequest","modelURI","canNavigateValueSet","navigateValueSet","highlightRange","DECORATION","decorationRemover","InPlaceReplaceUp","InPlaceReplaceDown","getSpaceCnt","generateIndent","getReindentEditOperations","inheritedIndent","globalIndent","indentEdits","adjustedLineContent","oldIndentation","idealIndentForNextLine","IndentationToSpacesAction","modelOpts","IndentationToSpacesCommand","IndentationToTabsAction","IndentationToTabsCommand","ChangeIndentationSizeAction","creationOpts","picks","autoFocusIndex","activeItem","IndentUsingTabs","IndentUsingSpaces","DetectIndentation","ReindentLinesAction","ReindentSelectedLinesAction","AutoIndentOnPasteCommand","selectionIsSet","AutoIndentOnPaste","callOnDispose","callOnModel","textEdits","shouldIgnoreLine","firstLineText","indentOfFirstLine","newSpaceCnt","oldSpaceCnt","newIndent","indentMetadata","indentOfSecondLine","newSpaceCntOfSecondLine","oldSpaceCntOfSecondLine","spaceCntOffset","originalIndent","originalSpacesCnt","newSpacesCnt","cmd","firstNonWhitespaceTokenIndex","getIndentationEditOperations","tabsToSpaces","spacesRegExp","originalIndentationRange","originalIndentation","selectionId","InlayHintAnchor","InlayHintItem","hint","_currentResolve","resolveInlayHint","_doResolve","newHint","InlayHintsFragments","hints","wordRange","_getRangeAtPosition","provideInlayHints","flat","asCommandLink","defaultColor","defaultOptions","showArrow","showFrame","frameColor","arrowColor","keepEditorSelection","WIDGET_ID","ViewZoneDelegate","_onDomNodeTop","_onComputedHeight","OverlayWidgetDelegate","Arrow","_ruleName","_IdGenerator","_updateStyle","where","ZoneWidget","_arrow","_overlayWidget","_positionMarkerId","_isShowing","isAccessible","_getWidth","_getLeft","_onWidth","_fillContainer","_initSash","_applyStyles","borderTopColor","borderBottomColor","_onViewZoneTop","_onViewZoneHeight","containerHeight","_decoratingElementsHeight","_doLayout","rangeOrPos","_showImpl","arrowHeight","frameThickness","viewZoneDomNode","maxHeightInLines","frameWidth","borderTopWidth","borderBottomWidth","isLastLine","setCssClass","classToReplace","widthInPixel","heightInPixel","_relayout","newHeightInLines","isResizeable","roundedLineDelta","IPeekViewService","PeekContext","addExclusiveWidget","onDidClose","inPeekEditor","notInPeekEditor","PeekContextController","getOuterEditor","headerBackgroundColor","primaryHeadingColor","secondaryHeadingColor","PeekViewWidget","_onDidClose","_headElement","_primaryHeading","_secondaryHeading","_bodyElement","_fillHead","_fillBody","noCloseAction","titleElement","supportOnTitleClick","_onTitleClick","_fillTitleIcon","_metaHeading","actionBarOptions","_getActionBarOptions","_actionbarWidget","setTitle","primaryHeading","secondaryHeading","setMetaTitle","headHeight","bodyHeight","_doLayoutHead","_doLayoutBody","peekViewTitleBackground","peekViewTitleForeground","peekViewTitleInfoForeground","peekViewBorder","peekViewResultsBackground","peekViewEditorBackground","OneReference","isProviderFirst","_rangeCallback","ariaMessage","getPreview","FilePreview","_modelReference","beforeRange","afterRange","inside","FileReferences","_previews","textModelResolverService","ReferencesModel","_onDidChangeReferenceRange","onDidChangeReferenceRange","_links","_title","providersFirst","_compareReferences","oneRef","nextOrPreviousReference","nearestReference","nearest","prefixLen","offsetDist","referenceAt","firstReference","DataSource","_resolverService","hasChildren","getChildren","Delegate","FileReferencesRenderer","OneReferenceRenderer","StringRepresentationProvider","IdentityProvider","FileReferencesTemplate","_uriLabel","badge","getUriLabel","template","filterData","OneReferenceTemplate","AccessibilityProvider","DecorationsManager","_decorationIgnoreSet","_callOnModelChange","_onModelChanged","_onDecorationChanged","newDecorationsActualIndex","oneReference","newLineLength","LayoutData","ReferencesTree","ReferenceWidget","_defaultTreeKeyboardSupport","layoutData","_textModelResolverService","_peekViewService","_disposeOnNewModel","_onDidSelectReference","onDidSelectReference","_dim","_preview","_previewNotAvailableMessage","_previewModelReference","_splitView","focusOnReferenceTree","focusOnPreviewEditor","isPreviewEditorFocused","_getFocusedReference","containerElement","_messageContainer","_previewContainer","_treeContainer","treeOptions","openOnSingleClick","selectionNavigation","overrideStyles","_revealReference","onDidOpen","sideBySide","newModel","_onNewModel","_decorationsManager","setInput","revealReference","revealParent","_revealedReference","getInput","expand","ctxReferenceSearchVisible","ReferencesController","_editorService","_requestIdPool","_ignoreModelChangeEvent","_referenceSearchVisible","toggleWidget","modelPromise","peekMode","widgetPosition","closeWidget","_peekMode","storageKey","openReference","_gotoReference","requestId","changeFocusBetweenPreviewAndReferences","goToNextOrPreviousReference","fwd","currentPosition","editorFocus","previewEditorFocus","focusEditor","openCodeEditor","selectionSource","openedEditor","withController","outerEditor","listService","lastFocusedList","ctxHasSymbols","ISymbolNavigationService","SymbolNavigationService","_currentModel","_currentIdx","_ignoreEditorChange","_ctxHasSymbols","_currentState","_currentMessage","refModel","editorState","seenUri","seenPosition","revealNext","selectionRevealType","editorService","onCodeEditorRemove","_onDidRemoveEditor","onCodeEditorAdd","_onDidAddEditor","listCodeEditors","getLocationLinks","provide","getDefinitionsAtPosition","provideDefinition","getDeclarationsAtPosition","provideDeclaration","getImplementationsAtPosition","provideImplementation","getTypeDefinitionsAtPosition","provideTypeDefinition","getReferencesAtPosition","provideReferences","includeDeclaration","resultWithoutDeclaration","_sortedAndDeduped","rawLinks","modelLinks","_g","_h","_goToActionIds","registerGoToAction","SymbolNavigationAnchor","SymbolNavigationAction","symbolNavService","_getLocationModel","altAction","altActionId","_getAlternativeCommand","referenceCount","muteMessage","_getNoResultFoundMessage","_onResult","_getGoToPreference","openInPeek","targetEditor","_openReference","openToSide","_openInPeek","modelNow","DefinitionAction","goToDefinitionKb","GoToDefinitionAction","OpenDefinitionToSideAction","PeekDefinitionAction","DeclarationAction","GoToDeclarationAction","TypeDefinitionAction","GoToTypeDefinitionAction","PeekTypeDefinitionAction","ImplementationAction","GoToImplementationAction","PeekImplementationAction","ReferencesAction","GenericGoToLocationAction","_references","_gotoMultipleBehaviour","noResultsMessage","control","showGoToContextMenu","contextMenuService","menuActions","showContextMenu","domForShadowRoot","box","autoSelectFirstItem","goToDefinitionWithLocation","isInPeek","canPeek","InlayHintsCache","IInlayHintsCache","RenderedInlayHintLabelPart","ActiveInlayHintInfo","InlayHintsController","_featureDebounce","_inlayHintsCache","_instaService","_decorationsMetadata","_ruleFactory","_debounceInfo","_removeAllDecorations","_updateHintsDecorators","_cacheHintsForFastRestore","watchedProviders","myToken","_getHintsRanges","onDidChangeInlayHints","_installLinkGesture","_installDblClickGesture","_installContextMenu","gesture","sessionStore","labelPart","_getInlayHintLabelPart","_activeInlayHintPart","lineHints","_invokeCommand","extendedRange","newDecorationsData","addInjectedText","classNameRef","addInjectedWhitespace","isLast","marginRule","isFirst","cssProperties","verticalAlign","_fillInColors","borderRadius","fixSpace","_MAX_DECORATORS","decorationIdsToReplace","newDecorationIds","editorFontSize","noBreakWhitespace","InlayHintsHoverAnchor","InlayHintsHover","suggestHoverAnchor","itemTooltip","partTooltip","linkHint","useMetaKey","_resolveInlayHintLabelPartHover","inlineSuggestCommitId","GhostText","additionalReservedLineCount","renderForScreenReader","lastPart","cappedLineText","PositionOffsetTransformer","lineStartOffsetByLineIdx","getOffset","transformer","offsetEdits","GhostTextPart","BaseGhostTextWidgetModel","_expanded","normalizedInlineCompletionsEquals","inlineCompletionToGhostText","inlineCompletion","previewSuffixLength","sourceLine","sourceIndentationLength","suggestionTouchesIndentation","suggestionAddedIndentationLength","replacedIndentation","rangeThatDoesNotReplaceIndentation","suggestionWithoutIndentationChange","valueToBeReplaced","cachingDiff","filteredChanges","previewStartInCompletionText","insertColumn","nonPreviewTextEnd","nonPreviewText","italicText","lastRequest","originalValue","smartDiff","getMaxCharCode","maxCharCode","getUniqueCharCode","elements1","elements2","fixBracketsInLine","StaticTokenizerSource","processNode","singleLangBracketTokens","closingTokenText","InlineCompletionsModel","completionSession","active","debounceValue","inlineCompletionsProvider","onDidExecuteCommand","handleUserInput","session","startSessionIfTriggered","ghostText","minReservedLineCount","setActive","scheduleAutomaticUpdate","suggestOptions","triggerKind","ensureUpdateWithExplicitContext","InlineCompletionsSession","takeOwnership","commitCurrentSuggestion","commitCurrentCompletion","showNext","showNextInlineCompletion","showPrevious","showPreviousInlineCompletion","hasMultipleInlineCompletions","triggerPosition","shouldUpdate","initialTriggerKind","lastCompletionItem","updateOperation","updateSoon","currentlySelectedCompletionId","currentCompletion","sourceInlineCompletion","sourceProvider","handleItemDidShow","sourceInlineCompletions","fixAndGetIndexOfCurrentSelection","completions","semanticId","currentCachedCompletion","newIdx","toLiveInlineCompletion","provideInlineCompletions","selectedSuggestionInfo","UpdateOperation","SynchronizedInlineCompletionsCache","completionsSource","CachedInlineCompletion","synchronizedRange","getDefaultRange","defaultReplaceRange","freeInlineCompletions","itemsByHash","completeBracketPairs","closeBrackets","trackedItem","lineStart","slicedTokens","minimizeInlineCompletion","valueToReplace","commonPrefixLen","remainingValueToReplace","commonSuffixLen","SuggestWidgetInlineCompletionProvider","suggestControllerPreselector","isSuggestWidgetVisible","isShiftKeyPressed","_currentSuggestItemInfo","setInactiveDelayed","suggestController","SuggestController","registerSelector","suggestItems","normalizedItemToPreselect","suggestItem","inlineSuggestItem","suggestionToSuggestItemInfo","normalizedSuggestItem","normalizedInlineCompletion","valid","rangeStartsWith","isBoundToSuggestWidget","bindToSuggestWidget","onDidShow","onDidHide","onDidTrigger","selectedItem","newActive","newInlineCompletion","getSuggestItemInfo","shouldFire","suggestItemInfoEquals","getFocusedItem","stopForceRenderingAbove","forceRenderingAbove","rangeToTest","completionItemKind","isSnippetText","toggleMode","additionalTextEdits","insertText","insertTextRules","snippet","getOverwriteInfo","overwriteBefore","overwriteAfter","SuggestWidgetPreviewModel","suggestionInlineCompletionSource","updateCacheSoon","updateCache","suggestWidgetState","newGhostText","isSuggestionPreviewEnabled","completionKind","augmentedCompletion","suggestInlineCompletion","isAugmentedCompletionValid","finalCompletion","inlineCompletionPreviewLength","toGhostText","DelegatingModel","hasCachedGhostText","currentModelRef","targetModel","setTargetModel","cachedGhostText","GhostTextModel","sharedCache","SharedInlineCompletionCache","suggestWidgetAdapterModel","inlineCompletionsModel","updateModel","activeInlineCompletionsModel","shouldShowHoverAt","hoverRange","triggerInlineCompletion","commitInlineCompletion","hideInlineCompletion","GhostTextWidget","partsWidget","DecorationsWidget","additionalLinesWidget","AdditionalLinesWidget","viewMoreContentWidget","shouldShowHoverAtViewZone","inlineTexts","additionalLines","addToAdditionalLines","textBufferLine","hiddenTextStartColumn","setParts","updateLines","renderViewMoreLines","remainingLinesLength","spacer","newline","disposableStore","ViewMoreLinesContentWidget","hiddenText","hiddenTextDecorations","GhostTextController","triggeredExplicitly","activeController","activeModelDidChangeEmitter","updateModelController","activeModel","inlineSuggestOptions","ActiveGhostTextController","inlineSuggestionVisible","inlineSuggestionHasIndentation","inlineSuggestionHasIndentationLessThanTabSize","GhostTextContextKeys","inlineCompletionVisible","inlineCompletionSuggestsIndentation","inlineCompletionSuggestsIndentationLessThanTabSize","contextKeys","updateContextKeys","startsWithIndentation","startsWithIndentationLessThanTabSize","indentationEndColumn","inIndentation","firstNonWsIdx","visibleColumnIndentation","GhostTextCommand","commitInlineSuggestionAction","ShowNextInlineSuggestionAction","ShowPreviousInlineSuggestionAction","TriggerInlineSuggestionAction","InlineCompletionsHover","hasMultipleSuggestions","InlineCompletionsHoverParticipant","_menuService","renderScreenReaderText","createMenu","previousAction","statusBar","addAction","nextAction","inlineSuggestionAvailable","replaceChildren","ExpandLineSelectionAction","TrimTrailingWhitespaceCommand","trimTrailingWhitespace","cursorIndex","cursorLen","minEditColumn","CopyLinesCommand","isCopyingDown","noop","_isCopyingDown","_noop","_selectionDirection","_startLineNumberDelta","_endLineNumberDelta","sourceLines","sourceText","MoveLinesCommand","isMovingDown","_isMovingDown","_autoIndent","_moveEndLineSelectionShrink","buildIndentConverter","otherLineNumber","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","indentUtils","trimLeft","indentOfMovingLine","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","oldIndent","parseEnterResult","enter","enterPrefix","indentMetadataOfMovelingLine","futureAboveLineNumber","futureAboveLineText","validPrecedingLine","oneLineAbove","languageAtSelectionStart","languageAtSelectionEnd","SortLinesCommand","descending","_COLLATOR","Intl","Collator","sortLines","getSortData","linesToSort","getCollator","AbstractCopyLinesAction","CopyLinesUpAction","CopyLinesDownAction","DuplicateSelectionAction","insertSelection","AbstractMoveLinesAction","MoveLinesUpAction","MoveLinesDownAction","AbstractSortLinesAction","canRun","SortLinesAscendingAction","SortLinesDescendingAction","DeleteDuplicateLinesAction","linesDeleted","uniqueLines","selectionToReplace","adjustedSelectionStart","finalSelection","TrimTrailingWhitespaceAction","DeleteLinesAction","_getLinesToRemove","mergedOperations","previousOperation","IndentLinesAction","OutdentLinesAction","InsertLineBeforeAction","InsertLineAfterAction","AbstractDeleteAllToBoundaryAction","rangesToDelete","_getRangesToDelete","effectiveRanges","nextRange","_getEndCursorState","DeleteAllLeftAction","endPrimaryCursor","newStartLine","deleteFromLine","deleteFromColumn","DeleteAllRightAction","JoinLinesAction","reducedSelections","lastSelection","lineOffset","selectionEndPositionOffset","trimmedLinesContent","firstNonWhitespaceIdx","lineTextWithoutIndent","resultSelection","TransposeAction","AbstractCaseAction","_modifyText","UpperCaseAction","toLocaleUpperCase","LowerCaseAction","toLocaleLowerCase","BackwardsCompatibleRegExp","_pattern","_flags","_evaluated","TitleCaseAction","titleBoundary","SnakeCaseAction","caseBoundary","singleLetters","CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE","DECORATION_CLASS_NAME","LinkedEditingContribution","_providers","linkedEditingRangeProvider","_visibleContextKey","_currentDecorations","_languageWordPattern","_currentWordPattern","_rangeUpdateTriggerPromise","_rangeSyncTriggerPromise","_currentRequest","_currentRequestPosition","_currentRequestModelVersion","reinitialize","forceRefresh","clearRanges","rangeUpdateScheduler","triggerRangeUpdate","updateRanges","_debounceDuration","rangeSyncScheduler","triggerRangeSync","_syncRanges","referenceRange","referenceValue","mirrorRange","rangeStartColumn","rangeEndColumn","response","getLinkedEditingRanges","foundReferenceRange","LinkedEditingAction","LinkedEditingCommand","orderedByScore","provideLinkedEditingRanges","editorLinkedEditingBackground","editorLinkedEditingBackgroundColor","Link","_link","resolveLink","LinksList","tuples","newLinks","_union","oldLinks","oldLen","newLen","oldLink","newLink","comparisonResult","getLinks","lists","provideLinks","resolveCount","linkProvider","LinkDetector","debounceInformation","computeLinks","computeLinksNow","computePromise","activeLinksList","currentOccurrences","activeLinkDecorationId","clickLinkGesture","cleanUpActiveLinkDecoration","updateDecorations","occurence","LinkOccurrence","withKey","occurrence","getLinkOccurrence","activate","deactivate","openLinkOccurrence","fromUserGesture","modelUri","parsedUri","allowContributedOpeners","allowCommands","messageOrError","currentOccurrence","general","_getOptions","getHoverMessage","executeCmd","nativeLabel","nativeLabelText","OpenLinkAction","linkDetector","activeLinkForeground","_toConsumableArray","arr2","setPrototypeOf","seal","_ref","construct","fun","thisValue","Func","Function","arrayForEach","unapply","arrayPop","arrayPush","stringToLowerCase","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","unconstruct","_len2","_key2","addToSet","lcElement","newObject","lookupGetter","fallbackValue","svg","svgFilters","svgDisallowed","mathMl","mathMlDisallowed","html$1","svg$1","mathMl$1","xml","MUSTACHE_EXPR","ERB_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","_typeof","_toConsumableArray$1","getGlobal","_createTrustedTypesPolicy","ATTR_NAME","currentScript","policyName","html$$1","createDOMPurify","DOMPurify","removed","originalDocument","DocumentFragment","HTMLTemplateElement","Element","NodeFilter","_window$NamedNodeMap","NamedNodeMap","MozNamedAttrMap","Text","DOMParser","ElementPrototype","cloneNode","getNextSibling","getChildNodes","getParentNode","ownerDocument","trustedTypesPolicy","emptyHTML","RETURN_TRUSTED_TYPE","_document","createNodeIterator","createDocumentFragment","importNode","documentMode","hooks","createHTMLDocument","MUSTACHE_EXPR$$1","ERB_EXPR$$1","DATA_ATTR$$1","ARIA_ATTR$$1","IS_SCRIPT_OR_DATA$$1","ATTR_WHITESPACE$$1","IS_ALLOWED_URI$$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_DOM_IMPORT","SANITIZE_DOM","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","CONFIG","formElement","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","tbody","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","namespaceURI","parentTagName","commonSvgAndHTMLElements","_forceRemove","_removeAttribute","attribute","getAttributeNode","_initDocument","dirty","doc","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createIterator","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","_isClobbered","elm","attributes","_isNode","_executeHook","entryPoint","hook","_sanitizeElements","allowedTags","firstElementChild","_isValidAttribute","lcTag","lcName","_sanitizeAttributes","hookEvent","attrName","attrValue","keepAttr","allowedAttributes","_attr","forceKeepAttr","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","returnNode","toStaticHTML","nodeIterator","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","purify","__marked_exports","deps","amd","globalThis","marked","_defineProperties","_createClass","Constructor","protoProps","staticProps","_unsupportedIterableToArray","minLen","_arrayLikeToArray","_createForOfIteratorHelperLoose","allowArrayLike","it","getDefaults","baseUrl","breaks","gfm","headerIds","headerPrefix","langPrefix","mangle","pedantic","sanitizer","silent","smartLists","smartypants","walkTokens","xhtml","changeDefaults","newDefaults","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","escape","encode","unescapeTest","unescape","opt","nonWordAndColonTest","originIndependentUrl","cleanUrl","prot","resolveUrl","encodeURI","baseUrls","justDomain","domain","relativeBase","noopTest","splitCells","tableRow","cells","invert","suffLen","currChar","findClosingBracket","checkSanitizeDeprecation","repeatString","outputLink","cap","lexer","inLink","inlineTokens","indentCodeCompensation","matchIndentToCode","indentToCode","matchIndentInNode","indentInNode","Tokenizer","_proto","block","codeBlockStyle","fences","lang","heading","blockquote","blockTokens","istask","ischecked","blankLine","endsWithBlankLine","nextLine","rawLine","itemContents","endEarly","bull","isordered","loose","itemRegex","nextBulletRegex","trimRight","spacers","hasMultipleLineBreaks","_char","pre","header","align","lheading","paragraph","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","_escapes","reflink","nolink","emStrong","maskedSrc","prevChar","lDelim","punctuation","rDelim","lLength","delimTotal","midDelimTotal","endReg","rDelimAst","rDelimUnd","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","prevCapZero","_backpedal","inlineText","_paragraph","bullet","listItemStart","_tag","_comment","normal","reflinkSearch","_punctuation","blockSkip","escapedEmSt","_scheme","_email","_attribute","_href","strong","endAst","endUnd","em","_extended_email","Lexer","inlineQueue","lex","lexInline","lastToken","cutSrc","lastParagraphClipped","extTokenizer","startBlock","Infinity","tempSrc","tempStart","getStartIndex","errMsg","_this2","keepPrevChar","startInline","Renderer","_code","infostring","_html","slugger","slug","startatt","listitem","checkbox","tablerow","tablecell","image","TextRenderer","Slugger","getNextSafeSlug","originalSlug","isDryRun","occurenceAccumulator","dryrun","textRenderer","parseInline","l3","cell","itemBody","use","hasExtensions","childTokens","pack","prevRenderer","_len3","_key3","_loop2","prevTokenizer","_len4","_key4","_walkTokens","_loop3","_step2","_iterator2","_step3","_iterator3","_step4","_iterator4","_cell","renderMarkdown","markedOptions","_uriMassage","uris","isDomUri","signalInnerHTML","withInnerHTML","baseUri","resolveWithBaseUri","codeBlockRenderer","span","asyncRenderCallback","onAuxClick","dataset","renderedMarkdown","htmlParser","markdownHtmlDoc","sanitizeRenderedMarkdown","querySelectorAll","img","hasScheme","allowedSchemes","getSanitizerOptions","MarkdownRenderer","_onDidRenderAsync","_getRenderOptions","disposeables","languageAlias","getLanguageIdByLanguageName","_ttpTokenizer","codeBlockFontFamily","MessageController","_messageWidget","_messageListeners","_visible","MESSAGE_VISIBLE","_editorListener","bounds","MessageWidget","closeMessage","fadeOut","MessageCommand","anchorTop","anchorBottom","messageWidget","announceCursorChange","previousCursorState","cursorDiff","cs","pcs","cursorPositions","InsertCursorAbove","logicalLine","InsertCursorBelow","InsertCursorAtEndOfEachLineSelected","getCursorsForSelection","currentLineMaxColumn","InsertCursorAtEndOfLineSelected","InsertCursorAtTopOfLineSelected","MultiCursorSessionResult","revealScrollType","MultiCursorSession","findController","isDisconnectedFromFindController","findState","addSelectionToNextFindMatch","allSelections","moveSelectionToNextFindMatch","lastAddedSelection","addSelectionToPreviousFindMatch","previousMatch","_getPreviousMatch","moveSelectionToPreviousFindMatch","selectAll","MultiCursorSelectionController","_sessionDispose","_ignoreSelectionChange","_session","_endSession","_beginSessionIfNeeded","_setSelections","_expandEmptyToWord","_applySessionResult","getSession","selectionsContainSameText","modelRangesContainSameText","resultingSelections","inSelection","MultiCursorSelectionControllerAction","multiCursorController","AddSelectionToNextFindMatchAction","AddSelectionToPreviousFindMatchAction","MoveSelectionToNextFindMatchAction","MoveSelectionToPreviousFindMatchAction","SelectHighlightsAction","CompatChangeAll","SelectionHighlighterState","_searchText","_modelVersionId","_cachedFindMatches","SelectionHighlighter","_createState","findStateSearchString","mySearchString","allMatches","hasFindOccurrences","_SELECTION_HIGHLIGHT","_SELECTION_HIGHLIGHT_OVERVIEW","thisSelectedText","Context","Visible","MultipleSignatures","provideSignatureHelp","supports","triggerCharacter","isRetrigger","ParameterHintState","Pending","previouslyActiveHints","Active","ParameterHintsModel","DEFAULT_DELAY","_onChangedHints","onChangedHints","triggerOnType","_pendingTriggers","_lastSignatureHelpResult","retriggerChars","triggerId","throttledDelayer","onEditorConfigurationChange","onCursorChange","onModelContentChange","signatures","activeSignature","updateActiveSignature","activeSignatureHelp","getLastActiveHints","mergeTriggerContexts","triggerContext","signatureHelpTriggerCharacters","signatureHelpRetriggerCharacters","lastCharIndex","triggerCharCode","parameterHintsNextIcon","parameterHintsPreviousIcon","ParameterHintsWidget","renderDisposeables","announcedLabel","markdownRenderer","keyVisible","keyMultipleSignatures","newParameterHints","createParameterHintDOMNodes","controls","overloads","signature","docs","userSelect","domNodes","updateFont","updateMaxHeight","hasParameters","activeParameterIndex","activeParameter","renderParameters","documentation","renderMarkdownDocs","hasDocs","labelToAnnounce","param","getParameterLabelOffsets","beforeSpan","paramSpan","afterSpan","paramIdx","getElementsByClassName","editorHoverWidgetHighlightForeground","linkHover","codeBackground","parameterHighlightColor","ParameterHintsController","TriggerParameterHintsAction","ParameterHintsCommand","CONTEXT_RENAME_INPUT_VISIBLE","RenameInputField","_acceptKeybindings","_updateFont","_updateStyles","onDidUpdateKeybindings","cancelInput","acceptInput","wantsPreview","_currentAcceptInput","_currentCancelInput","supportPreview","disposeOnDone","newName","RenameSkeleton","_providerRenameIdx","hasProvider","resolveRenameLocation","rejects","rejectReason","provideRenameEdits","_provideRenameEdits","rename","skeleton","loc","RenameController","_bulkEditService","_progressService","_configService","_dispoableStore","_cts","_renameInputField","resolveLocationOperation","hasPreviewHandler","inputFieldResult","renameOperation","renameResult","showPreview","quotableLabel","ariaSummary","acceptRenameInput","cancelRenameInput","RenameAction","RenameCommand","registerConfiguration","BracketSelectionRangeProvider","provideSelectionRanges","_bracketsRightYield","_bracketsLeftYield","_maxRounds","_maxDuration","closing","innerBracket","outerBracket","_addBracketLeading","aboveLine","WordSelectionRangeProvider","_addInWordRanges","_addWordRanges","_addWhitespaceLine","lastCh","SelectionRanges","mov","SmartSelectController","_ignoreSelection","_selectionListener","forward","selectionRangeProvider","AbstractSmartSelect","_forward","GrowSelectionAction","ShrinkSelectionAction","work","allRawRanges","allProviderRanges","oneProviderRanges","oneRawRanges","oneRanges","oneRangesWithTrivia","rangeNoWhitespace","rangeFull","Scanner","tokenText","isDigitCharacter","isVariableCharacter","Marker","others","newChildren","_fixParent","TextmateSnippet","TransformableMarker","Placeholder","isFinalTabstop","choice","Choice","marker","Transform","didMatch","_replace","FormatString","elseValue","shorthandName","ifValue","_toPascalCase","_toCamelCase","Variable","resolver","walk","visitor","recurse","placeholderInfo","_placeholders","placeholders","fullLen","enclosingPlaceholders","resolveVariables","SnippetParser","_scanner","insertFinalTabstop","enforceFinalTabstop","placeholderDefaultValues","incompletePlaceholders","placeholderCount","defaultValues","_accept","_backTo","_until","_parseEscaped","_parseTabstopOrVariableName","_parseComplexPlaceholder","_parseComplexVariable","_parseAnything","_parseTransform","_parseChoiceElement","regexValue","regexOptions","_parseFormatString","complex","shorthand","_hex","_fillRandomValues","generateUuid","crypto","getRandomValues","CompositeSnippetVariableResolver","_delegates","SelectionBasedVariableResolver","_selectionIdx","_overtypingCapturer","getLastOvertypedInfo","lineLeadingWhitespace","varLeadingWhitespace","whitespaceCommonLength","rest","ModelBasedVariableResolver","_labelService","noPrefix","ClipboardBasedVariableResolver","_readClipboardText","_selectionCount","_spread","CommentBasedVariableResolver","TimeBasedVariableResolver","_date","getFullYear","getMonth","valueOf","getDate","getHours","getMinutes","getSeconds","dayNames","getDay","dayNamesShort","monthNames","monthNamesShort","WorkspaceBasedVariableResolver","_workspaceService","workspaceIdentifier","getWorkspace","_resolveWorkspaceName","_resoveWorkspacePath","configPath","folderpath","RandomBasedVariableResolver","OneSnippet","_snippet","_snippetLineLeadingWhitespace","_nestingLevel","_placeholderGroups","_placeholderGroupsIdx","_placeholderDecorations","_initDecorations","placeholderOffset","placeholderLen","_decor","inactiveFinal","inactive","transformedValueLines","couldSkipThisPlaceholder","activePlaceholders","_hasPlaceholderBeenCollapsed","activeFinal","enclosingPlaceholder","isAtFirstPlaceholder","isAtLastPlaceholder","hasPlaceholder","computePossibleSelections","placeholdersWithEqualIndex","nested","assert","indexLastPlaceholder","nestedPlaceholder","_defaultOptions","adjustWhitespace","overtypingCapturer","SnippetSession","_templateMerges","_snippets","_template","adjustIndentation","adjustNewlines","snippetTextString","positionColumnBefore","positionColumnAfter","snippets","workspaceService","modelBasedVariableResolver","readClipboardText","firstBeforeText","adjustSelection","firstAfterText","firstLineFirstNonWhitespace","indexedSelections","extensionBefore","extensionAfter","snippetSelection","snippetLineLeadingWhitespace","_logInfo","createEditsAndSnippets","oneSelection","isSelectionWithinPlaceholders","allPossibleSelections","DetailsVisible","MultipleSuggestions","MakesTextEdit","AcceptSuggestionsOnEnter","HasInsertAndReplaceRange","InsertMode","CanResolve","suggestWidgetStatusbarMenu","CompletionItem","textLabel","labelLow","sortTextLow","sortText","filterTextLow","filterText","editStart","editInsertEnd","editReplaceEnd","resolveCompletionItem","_resolveCache","sub","CompletionOptions","snippetSortOrder","kindFilter","providerFilter","_snippetSuggestSupport","getSnippetSuggestSupport","CompletionItemModel","needsClipboard","durations","provideSuggestionItems","defaultRange","onCompletionList","didAddResult","suggestion","suggestions","providerName","_debugDisplayName","elapsedProvider","elapsedOverall","snippetCompletions","provideCompletionItems","providerGroup","getSuggestionComparator","defaultComparator","snippetUpComparator","snippetDownComparator","_snippetComparators","snippetConfig","_onlyOnceProvider","maxItemsToResolve","incomplete","resolving","_onlyOnceSuggestions","showSimpleSuggestions","triggerSuggest","undoStopBefore","undoStopAfter","SnippetController2","_snippetListener","_inSnippet","InSnippetMode","_hasNextTabstop","HasNextTabstop","_hasPrevTabstop","HasPrevTabstop","_doInsert","_updateState","_handleChoice","_currentChoice","resetSelection","isInSnippet","CommandCtor","ctrl","Memory","topScore","preselect","NoMemory","memorize","LRUMemory","_seq","lineSuffix","indexPreselect","indexRecency","seq","PrefixMemory","_trie","SuggestMemoryService","_persistSoon","_saveState","_withStrategy","_strategy","_strategyCtors","share","_storagePrefix","ISuggestMemoryService","WordContextKey","_ckAtEnd","AtEnd","_configListener","checkForWordEnd","SuggestAlternatives","_ckOtherSuggestions","OtherSuggestions","_acceptNext","acceptNext","nextIndex","_moveIndex","CommitCharacterController","_onItem","_active","acceptCharacters","commitCharacters","WordDistance","service","canComputeWordRanges","wordRanges","computeWordRanges","wordUntilPos","wordLines","bestWordRange","blockDistance","CompletionModel","lineContext","wordDistance","_snippetCompareFn","_compareCompletionItems","_items","_wordDistance","_refilterKind","_lineContext","_compareCompletionItemsSnippetsUp","_compareCompletionItemsSnippetsDown","leadingLineContent","characterCountDelta","_filteredItems","_ensureCachedState","allProvider","_providerInfo","except","stats","_stats","_createCachedState","labelLengths","scoreFn","pLabelLen","auto","shy","leadingWord","canShowQuickSuggest","getContextKeyValue","allowQuickSuggestions","canShowSuggestOnTriggerCharacters","SuggestModel","_editorWorkerService","_telemetryService","_quickSuggestDelay","_triggerCharacterListener","_triggerQuickSuggest","_completionDisposables","_onDidTrigger","_onDidSuggest","onDidSuggest","_telemetryGate","_updateTriggerCharacters","_updateQuickSuggest","_updateActiveSuggestSession","editorIsComposing","_onCursorChange","_refilterCompletionItems","supportsByTriggerCharacter","triggerCharacters","checkTriggerCharacter","shouldAutoTrigger","_completionModel","retrigger","_requestToken","prevSelection","_doTriggerQuickSuggest","inValidScope","_onNewContext","onlyFrom","suggestCtx","itemKind","itemKindFilter","_createSuggestFilter","cmpFn","_reportDurationsTelemetry","inactiveProvider","oldLineContext","completionModel","OvertypingCapturer","suggestModel","_lastOvertyped","selectionsLength","willOvertype","_maxSelectionLength","StatusBarViewItem","symbolPrintEnter","SuggestWidgetStatus","_menuDisposables","_leftActions","_rightActions","renderMenu","ResizableHTMLElement","_onDidWillResize","onDidWillResize","_onDidResize","onDidResize","_sashListener","_minSize","_maxSize","_eastSash","_westSash","_northSash","_southSash","east","west","north","south","_preferredSize","enableSashes","minHeight","maxSize","minSize","preferredSize","canExpandCompletionItem","SuggestDetailsWidget","_onDidChangeContents","onDidChangeContents","_renderDisposeable","_borderWidth","_markdownRenderer","_body","_header","_close","_docs","_configureFont","fontSizePx","lineHeightPx","borderHeight","verticalPadding","renderLoading","renderItem","explainMode","md","cappedDetail","clearContents","scrollDown","scrollUp","pageDown","pageUp","SuggestDetailsOverlay","topLeftNow","sizeNow","_added","_preferAlignAtTop","_resizable","_topLeft","updateTopLeft","_applyTopLeft","_userSize","_anchorBox","_placeAtAnchor","sessionEnded","placeAtAnchor","preferAlignAtTop","anchorBox","bodyBox","defaultMinSize","defaultTop","eastPlacement","maxSizeTop","maxSizeBottom","fit","westPlacement","southPacement","placements","alignAtTop","FileKind","fileIconDirectoryRegex","getIconClasses","fileKind","ROOT_FOLDER","FOLDER","cssEscape","dotSegments","detectedLanguageId","detectLanguageId","getLanguageIdByMimeType","guessLanguageIdByFilepathOrFirstLine","getAriaId","suggestMoreInfoIcon","_completionItemColor","ColorExtractor","extract","_regexStrict","_regexRelaxed","ItemRenderer","_modelService","_onDidToggleDetails","onDidToggleDetails","colorspan","main","iconContainer","iconLabel","parametersLabel","qualifierLabel","detailsLabel","readMore","configureFont","labelOptions","getFileIconTheme","hasFileIcons","labelClasses","FILE","detailClasses","hasFolderIcons","stripNewLines","editorSuggestWidgetForeground","editorSuggestWidgetSelectedBackground","PersistedWidgetSize","_service","SuggestWidget","_isAuto","_ignoreFocusEvents","_forceRenderingAbove","_explainMode","_showTimeout","_onDidSelect","_onDidHide","_onDidShow","onDidSelect","_onDetailsKeydown","onDetailsKeyDown","SuggestContentWidget","_persistedSize","ResizeState","persistedSize","persistHeight","persistWidth","lockPreference","_resize","itemHeight","defaultSize","unlockPreference","_messageElement","_listElement","details","toggleDetails","_details","applyIconStyle","_list","_isDetailsVisible","_status","applyStatusBarStyle","_onThemeChange","_onListMouseDownOrTap","_onListSelection","_onListFocus","_onCursorSelectionChanged","_ctxSuggestWidgetVisible","_ctxSuggestWidgetDetailsVisible","_ctxSuggestWidgetMultipleSuggestions","_loadingTimeout","_select","_currentSuggestionDetails","_focusedItem","showDetails","_cappedHeight","LOADING_MESSAGE","NO_SUGGESTIONS_MESSAGE","_layout","showTriggered","showSuggestions","selectionIndex","isAuto","visibleCount","selectNextPage","selectNext","selectLast","selectPreviousPage","selectPrevious","toggleDetailsFocus","_setDetailsVisible","_positionDetails","toggleExplainMode","resetPersistedSize","hideWidget","dim","minPersistedHeight","_afterRender","setPreference","preferredWidth","fullHeight","statusBarHeight","editorBox","cursorBox","cursorBottom","maxHeightBelow","availableSpaceAbove","maxHeightAbove","capped","wanted","forceRenderingAboveRequiredSpace","_preferenceLocked","_hidden","_sticky","LineSuffix","_marker","_memoryService","_lineSuffix","PriorityRegistry","ctxInsertMode","_insertSuggestion","commitCharacterController","ctxMakesTextEdit","ctxHasInsertAndReplace","ctxCanResolve","_alternatives","itemsOrderedByPriorityDesc","acceptSuggestionsOnEnter","updateFromConfig","snippetController","modelVersionNow","tasks","docListener","thisPosition","oldFlags","didType","typeListener","applied","TriggerSuggestAction","_alertCompletionItem","_reportSuggestionAcceptedTelemetry","acceptedSuggestion","providerId","basenameHash","fileExtension","suffixDelta","triggerSuggestAndAcceptBest","positionNow","makesTextEdit","textNow","acceptSelectedSuggestion","keepAlternativeSuggestions","alternativeOverwriteConfig","acceptNextSuggestion","acceptPrevSuggestion","cancelSuggestWidget","selectNextSuggestion","selectNextPageSuggestion","selectLastSuggestion","selectPrevSuggestion","selectPrevPageSuggestion","selectFirstSuggestion","toggleSuggestionDetails","toggleSuggestionFocus","resetWidgetSize","prioritySelector","s1","s2","SuggestCommand","SYMBOL_ICON_ARRAY_FOREGROUND","SYMBOL_ICON_BOOLEAN_FOREGROUND","SYMBOL_ICON_CLASS_FOREGROUND","SYMBOL_ICON_COLOR_FOREGROUND","SYMBOL_ICON_CONSTANT_FOREGROUND","SYMBOL_ICON_CONSTRUCTOR_FOREGROUND","SYMBOL_ICON_ENUMERATOR_FOREGROUND","SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND","SYMBOL_ICON_EVENT_FOREGROUND","SYMBOL_ICON_FIELD_FOREGROUND","SYMBOL_ICON_FILE_FOREGROUND","SYMBOL_ICON_FOLDER_FOREGROUND","SYMBOL_ICON_FUNCTION_FOREGROUND","SYMBOL_ICON_INTERFACE_FOREGROUND","SYMBOL_ICON_KEY_FOREGROUND","SYMBOL_ICON_KEYWORD_FOREGROUND","SYMBOL_ICON_METHOD_FOREGROUND","SYMBOL_ICON_MODULE_FOREGROUND","SYMBOL_ICON_NAMESPACE_FOREGROUND","SYMBOL_ICON_NULL_FOREGROUND","SYMBOL_ICON_NUMBER_FOREGROUND","SYMBOL_ICON_OBJECT_FOREGROUND","SYMBOL_ICON_OPERATOR_FOREGROUND","SYMBOL_ICON_PACKAGE_FOREGROUND","SYMBOL_ICON_PROPERTY_FOREGROUND","SYMBOL_ICON_REFERENCE_FOREGROUND","SYMBOL_ICON_SNIPPET_FOREGROUND","SYMBOL_ICON_STRING_FOREGROUND","SYMBOL_ICON_STRUCT_FOREGROUND","SYMBOL_ICON_TEXT_FOREGROUND","SYMBOL_ICON_TYPEPARAMETER_FOREGROUND","SYMBOL_ICON_UNIT_FOREGROUND","SYMBOL_ICON_VARIABLE_FOREGROUND","symbolIconArrayColor","symbolIconBooleanColor","symbolIconClassColor","symbolIconMethodColor","symbolIconColorColor","symbolIconConstantColor","symbolIconConstructorColor","symbolIconEnumeratorColor","symbolIconEnumeratorMemberColor","symbolIconEventColor","symbolIconFieldColor","symbolIconFileColor","symbolIconFolderColor","symbolIconFunctionColor","symbolIconInterfaceColor","symbolIconKeyColor","symbolIconKeywordColor","symbolIconModuleColor","outlineNamespaceColor","symbolIconNullColor","symbolIconNumberColor","symbolIconObjectColor","symbolIconOperatorColor","symbolIconPackageColor","symbolIconPropertyColor","symbolIconReferenceColor","symbolIconSnippetColor","symbolIconStringColor","symbolIconStructColor","symbolIconTextColor","symbolIconTypeParameterColor","symbolIconUnitColor","symbolIconVariableColor","ToggleTabFocusModeAction","ForceRetokenizeAction","onClickEmitter","onKeyPress","onEnterPress","onOpen","opener","opacity","textLinkForegroundColor","textLinkActiveForegroundColor","BANNER_ELEMENT_HEIGHT","BannerController","banner","Banner","onClose","getBannerMessage","messageContainer","messageActionsContainer","actionBarContainer","actionBar","warningIcon","UnicodeHighlighter","_workspaceTrustService","_highlighter","_bannerClosed","DisableHighlightingOfNonBasicAsciiCharactersAction","DisableHighlightingOfAmbiguousCharactersAction","DisableHighlightingOfInvisibleCharactersAction","_bannerController","shortLabel","_updateHighlighter","onDidChangeTrust","isWorkspaceTrusted","highlightOptions","osLocale","NumberFormat","resolvedOptions","canComputeUnicodeHighlights","DocumentUnicodeHighlighter","ViewportUnicodeHighlighter","getDecorationInfo","trusted","_updateSoon","computedUnicodeHighlights","Decorations","getDecorationFromOptions","computeReason","inComment","inString","totalResult","UnicodeHighlighterHoverParticipant","unicodeHighlighter","highlightInfo","codePointStr","formatCodePointMarkdown","adjustSettingsArgs","adjustSettings","ShowExcludeOptions","codePointToHex","renderCodePointAsInlineCode","getDecoration","hideInComments","hideInStrings","DisableHighlightingInCommentsAction","updateValue","DisableHighlightingInStringsAction","quickPickService","getExcludeCharFromBeingHighlightedLabel","excludeLocaleFromBeingHighlighted","excludeCharFromBeingHighlighted","expectNever","charCodes","existingValue","ignoreUnusualLineTerminators","writeIgnoreState","setModelProperty","readIgnoreState","getModelProperty","UnusualLineTerminatorsDetector","_dialogService","_config","_checkForUnusualLineTerminators","ignoreState","confirm","primaryButton","secondaryButton","confirmed","ViewportSemanticTokensContribution","_tokenizeViewportNow","_outstandingRequests","scheduleTokenizeViewport","_cancelAll","_removeOutstandingRequest","req","_requestRange","requestVersionId","editorWordHighlight","editorWordHighlightStrong","editorWordHighlightBorder","editorWordHighlightStrongBorder","overviewRulerWordHighlightForeground","overviewRulerWordHighlightStrongForeground","ctxHasWordHighlights","getOccurrencesAtPosition","provideDocumentHighlights","OccurenceAtPositionRequest","_wordRange","_getCurrentWordRange","_compute","currentWordRange","requestIsValid","SemanticOccurenceAtPositionRequest","TextualOccurenceAtPositionRequest","currentSelectionIsEmpty","computeOccurencesAtPosition","WordHighlighter","toUnhook","workerRequestTokenId","workerRequestCompleted","workerRequestValue","lastCursorPositionChangeTime","renderDecorationsTimer","_hasWordHighlights","_ignorePositionChangeEvent","_onPositionChanged","_stopAll","workerRequest","hasDecorations","_getSortedHighlights","moveNext","_getWord","moveBack","workerRequestIsValid","_beginRenderDecorations","myRequestId","minimumRenderTime","_getDecorationOptions","_WRITE_OPTIONS","_TEXT_OPTIONS","_REGULAR_OPTIONS","WordHighlighterContribution","wordHighlighter","createWordHighlighterIfPossible","WordHighlightNavigationAction","_isNext","NextWordHighlightAction","PrevWordHighlightAction","TriggerWordHighlightAction","wordHighlight","wordHighlightStrong","selectionHighlightBorder","wordHighlightBorder","wordHighlightStrongBorder","MoveWordCommand","_wordNavigationType","inPosition","outPosition","_moveTo","WordLeftCommand","WordRightCommand","CursorWordStartLeft","CursorWordEndLeft","CursorWordLeft","negate","CursorWordStartLeftSelect","CursorWordEndLeftSelect","CursorWordLeftSelect","CursorWordAccessibilityLeft","CursorWordAccessibilityLeftSelect","CursorWordStartRight","CursorWordEndRight","CursorWordRight","CursorWordStartRightSelect","CursorWordEndRightSelect","CursorWordRightSelect","CursorWordAccessibilityRight","CursorWordAccessibilityRightSelect","DeleteWordCommand","_whitespaceHeuristics","DeleteWordLeftCommand","DeleteWordRightCommand","DeleteWordStartLeft","DeleteWordEndLeft","DeleteWordLeft","DeleteWordStartRight","DeleteWordEndRight","DeleteWordRight","DeleteInsideWord","DeleteWordPartLeft","DeleteWordPartRight","WordPartLeftCommand","CursorWordPartLeft","CursorWordPartLeftSelect","WordPartRightCommand","CursorWordPartRight","CursorWordPartRightSelect","AccessibilitySupport","CompletionItemInsertTextRule","CompletionItemKind","CompletionItemTag","CompletionTriggerKind","ContentWidgetPositionPreference","CursorChangeReason","DefaultEndOfLine","EditorAutoIndentStrategy","EditorOption","EndOfLinePreference","EndOfLineSequence","KeyCode","MarkerSeverity","MarkerTag","MouseTargetType","OverlayWidgetPositionPreference","PositionAffinity","RenderLineNumbersType","RenderMinimap","ScrollType","ScrollbarVisibility","SelectionDirection","SymbolKind","SymbolTag","TextEditorCursorBlinkingStyle","TrackedRangeStickiness","WrappingIndent","KeyMod","createMonacoBaseAPI","CtrlCmd","Shift","Alt","WinCtrl","followsCaret","ignoreCharChanges","alwaysRevealFirst","DiffNavigator","_onDidUpdate","nextIdx","ignoreSelectionChange","revealFirst","onDidUpdateDiff","_onDiffUpdated","_init","getLineChanges","lineChanges","lineChange","charChanges","charChange","rhs","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","_initIdx","canNavigate","INITIALIZE","webWorkerWarningLogged","logOnceWebWorkerWarning","RequestMessage","vsWorker","ReplyMessage","SubscribeEventMessage","EventMessage","UnsubscribeEventMessage","SimpleWorkerProtocol","_workerId","_lastSentReq","_pendingReplies","_pendingEmitters","_pendingEvents","setWorkerId","workerId","sendMessage","_send","listen","handleMessage","_handleMessage","_handleReplyMessage","_handleRequestMessage","_handleSubscribeEventMessage","_handleEventMessage","_handleUnsubscribeEventMessage","replyMessage","requestMessage","handleEvent","transfer","SimpleWorkerClient","workerFactory","lazyProxyReject","_worker","_protocol","propertyIsDynamicEvent","propertyIsEvent","loaderConfiguration","hostMethods","_onModuleLoaded","proxyMethodRequest","_request","proxyListen","_lazyProxy","availableMethods","_onError","getProxyObject","createProxyDynamicEvent","createScriptURL","getWorker","workerUrl","Worker","isPromiseLike","WebWorker","onMessageCallback","onErrorCallback","workerOrPromise","worker","onmessage","onmessageerror","terminate","DefaultWorkerFactory","_webWorkerFailedBeforeError","LAST_WORKER_ID","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","diffAlgo","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","createCharSequence","shouldIgnoreTrimWhitespace","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndColumn","diffChange","originalCharSequence","modifiedCharSequence","postProcessCharChanges","rawChanges","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","createFromDiffChange","DiffComputer","originalLines","modifiedLines","shouldMakePrettyDiff","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","diffResult","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","MirrorTextModel","_uri","_eol","_lineStarts","_cachedTextValue","getText","onEvents","_ensureLineStarts","eolLength","lineStartValues","_setLineText","newLengths","Uint8Matrix","cols","StateMachine","edges","maxState","_maxCharCode","nextState","_stateMachine","getStateMachine","_classifier","getClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","LinkComputer","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","stateMachine","linkBeginChCode","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","_createLink","BasicInplaceReplace","_defaultValueSet","range1","text1","range2","text2","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","valueSetsReplace","valueSets","valueSetReplace","valueSet","MirrorModel","wordAtText","words","wordenize","_wordenize","wordRangesIdx","getLineWords","_validateRange","resultLines","offsetAt","maxCharacter","EditorSimpleWorker","foreignModuleFactory","_foreignModuleFactory","_foreignModule","_getModel","_getModels","acceptNewModel","EOL","acceptModelChanged","strURL","acceptRemovedModel","computeUnicodeHighlights","originalUrl","modifiedUrl","ignoreTrimWhitespace","diffComputer","identical","_modelsAreIdentical","originalLineCount","modifiedLineCount","modelUrl","lastEol","aRng","bRng","_diffLimit","editOffset","newEdit","textualSuggest","modelUrls","wordDef","wordDefFlags","wordDefRegExp","outer","_suggestionsLimit","loadForeignModule","createData","foreignHostMethods","fhr","foreignHost","getMirrorModels","fmr","STOP_SYNC_MODEL_DELTA_TIME_MS","STOP_WORKER_DELTA_TIME_MS","canSyncModel","EditorWorkerService","_workerManager","WorkerManager","hasAccessToAllModels","withWorker","client","WordBasedCompletionItemProvider","race","workerManager","wordBasedSuggestions","models","wordBasedSuggestionsMode","_editorWorkerClient","_lastWorkerUsedTime","stopWorkerInterval","_checkStopIdleWorker","_checkStopEmptyWorker","timeSinceLastWorkerUsedTime","EditorWorkerClient","EditorModelManager","proxy","keepIdleModels","_syncedModels","_syncedModelsLastUsedTime","_proxy","_checkStopModelSync","ensureSyncedResources","forceLargeModels","resourceStr","_beginModelSync","_stopModelSync","SynchronousWorkerClient","_instance","_proxyObj","EditorWorkerHost","workerClient","_workerClient","_keepIdleModels","_workerFactory","_modelManager","_getOrCreateWorker","_getProxy","_getOrCreateModelManager","_withSyncedResources","createWebWorker","MonacoWebWorkerImpl","_foreignModuleId","_foreignModuleCreateData","_foreignModuleHost","_foreignProxy","_getForeignProxy","foreignMethods","foreignProxy","foreignMethod","getProxy","withSyncedResources","isFuzzyActionArr","what","isFuzzyAction","isIAction","fixCase","createError","substituteMatches","re","stateMatches","full","dollar","ofs","findRules","inState","stateExists","exist","stateNames","CACHE_STACK_DEPTH","MonarchStackElementFactory","maxCacheDepth","_maxCacheDepth","MonarchStackElement","stackElementId","getStackElementId","popall","switchTo","EmbeddedLanguageData","stateClone","MonarchLineStateFactory","embeddedLanguageData","MonarchLineState","embeddedlanguageDataClone","MonarchClassicTokensCollector","_lastTokenType","_lastTokenLanguage","enterLanguage","nestedLanguageTokenize","embeddedLanguageLine","offsetDelta","nestedLanguageId","embeddedModeState","nestedLanguageTokenizationSupport","nestedResult","MonarchModernTokensCollector","_prependTokens","_currentLanguageId","_lastTokenMetadata","cLen","MonarchTokenizer","standaloneThemeService","_standaloneThemeService","_lexer","_embeddedLanguages","embeddedLoaded","emitting","_tokenizationRegistryListener","isOneOfMyEmbeddedModes","getLoadStatus","nestedModeStatus","loaded","rootState","lineState","tokensCollector","endLineState","_tokenize","tokenTheme","_nestedTokenize","_myTokenize","_findLeavingNestedLanguageOffset","popOffset","hasEmbeddedPopRule","nextEmbedded","regexSource","matchOnlyAtLineStart","nestedEndState","nestedLanguageLine","restOfTheLine","_safeRuleName","lineWithoutLF","lineWithoutLFLength","includeLF","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","enteringEmbeddedLanguage","groupEntry","restOfLine","defaultToken","tokenSubst","goBack","maxStack","computeNewStateForEmbeddedLanguage","_getNestedEmbeddedLanguageData","totalLen","findBracket","tokenPostfix","bracketType","Colorizer","mimeType","setTheme","nodeValue","colorize","_fakeColorize","_colorize","inflatedTokens","colorizeLine","_actualColorize","tokenizeResult","DIFF_LINES_PADDING","DiffEntry","originalLineStart","originalLineEnd","modifiedLineStart","modifiedLineEnd","Diff","diffReviewInsertIcon","diffReviewRemoveIcon","diffReviewCloseIcon","DiffReview","diffEditor","_diffEditor","_actionBar","_content","_diffs","_goToRow","_getNextRow","_getPrevRow","_currentDiff","_findDiffIndex","doLayout","jumpToLineNumber","_getCurrentFocusedRow","previousElementSibling","_getFirstRow","nextElementSibling","originalModel","getOriginalEditor","modifiedModel","_mergeAdjacent","diffs","diffsLength","originalEqualAbove","modifiedEqualAbove","minOriginal","minModified","prevLineChange","fromOriginal","fromModified","originalEqualBelow","modifiedEqualBelow","maxOriginal","maxModified","nextLineChange","toOriginal","toModified","thisDiff","currLast","thisFirst","lastModifiedLine","originalOptions","modifiedOptions","originalModelOpts","modifiedModelOpts","diffIndex","minOriginalLine","maxOriginalLine","minModifiedLine","maxModifiedLine","diffEntry","originalChangedLinesCnt","modifiedChangedLinesCnt","getAriaLines","originalChangedLinesCntAria","modifiedChangedLinesCntAria","modLine","_renderSection","rowClassName","lineNumbersExtraClassName","spacerClassName","spacerIcon","originalLayoutInfo","originalLineNumbersWidth","modifiedLayoutInfo","modifiedLineNumbersWidth","spacerCodicon","DiffReviewNext","findFocusedDiffEditor","diffReviewNext","DiffReviewPrev","diffReviewPrev","diffEditors","listDiffEditors","activeCodeEditor","InlineDiffMargin","_marginDomNode","_contextMenuService","_diffActions","lineFeed","isDeletion","deletedText","copyLineAction","currentLineNumberOffset","eof","_updateLightBulbPosition","lineNumberOffset","viewLineCounts","VisualEditorState","_inlineDiffMargins","_zonesMap","getForeignViewZones","allViewZones","clean","viewChangeAccessor","zoneId","restoreScrollState","inlineDiffMargin","overviewZones","DIFF_EDITOR_ID","diffInsertIcon","diffRemoveIcon","DiffEditorWidget","_editorProgressService","_onDidUpdateDiff","_lastOriginalWarning","_lastModifiedWarning","_updatingDiffProgress","validateDiffEditorOptions","enableSplitViewResizing","renderSideBySide","maxFileSize","renderIndicators","originalEditable","diffCodeLens","renderOverviewRuler","diffWordWrap","isInEmbeddedEditor","_updateDecorationsRunner","_updateDecorations","_containerDomElement","_overviewViewportDomElement","_overviewDomElement","_modifiedEditor","_originalDomNode","_modifiedDomNode","_beginUpdateDecorationsTimeout","_currentlyChangingViewZones","_diffComputationToken","_originalEditorState","_modifiedEditorState","_isHandlingScrollEvent","_elementSizeObserver","_onDidContainerSizeChanged","_diffComputationResult","_originalEditor","_createLeftHandSideEditor","originalEditor","_createRightHandSideEditor","modifiedEditor","_originalOverviewRuler","_modifiedOverviewRuler","_reviewPane","_setStrategy","DiffEditorWidgetSideBySide","_createDataSource","DiffEditorWidgetInline","applyColors","addDiffEditor","_recreateOverviewRulers","_layoutOverviewRulers","_createInnerEditor","_adjustOptionsForLeftHandSide","_layoutOverviewViewport","_onViewZonesChanged","_beginUpdateDecorationsSoon","isInDiffLeftEditorKey","ONE_OVERVIEW_WIDTH","_adjustOptionsForRightHandSide","isInDiffRightEditorKey","editorWidgetOptions","removeDiffEditor","_cleanViewZonesAndDecorations","changedDiffEditorOptions","beginUpdateDecorations","beginUpdateDecorationsSoon","_beginUpdateDecorations","setEnableSplitViewResizing","originalViewState","modifiedViewState","diffEditorState","_getReviewHeight","reviewHeight","freeSpace","ENTIRE_DIFF_OVERVIEW_WIDTH","UPDATE_DIFF_DECORATIONS_DELAY","currentOriginalModel","currentModifiedModel","currentToken","diffLimit","canSyncModelForDiff","foreignOriginal","foreignModified","diffDecorations","getEditorsDiffDecorations","_adjustOptionsForSubEditor","clonedOptions","originalAriaLabel","modifiedAriaLabel","splitPoint","_computeOverviewViewport","computedRatio","relayoutEditors","newStrategy","_getLineChangeAtOrBeforeLineNumber","startLineNumberExtractor","midEnd","_getEquivalentLineForOriginalLineNumber","originalEquivalentLineNumber","modifiedEquivalentLineNumber","lineChangeOriginalLength","lineChangeModifiedLength","_getEquivalentLineForModifiedLineNumber","getDiffLineInformationForOriginal","equivalentLineNumber","getDiffLineInformationForModified","DiffEditorWidgetStyle","dataSource","_dataSource","_insertColor","_removeColor","newInsertColor","newRemoveColor","originalWhitespaces","modifiedWhitespaces","_getViewZones","originalDecorations","_getOriginalEditorDecorations","modifiedDecorations","_getModifiedEditorDecorations","ForeignViewZonesIterator","ViewZonesComputer","_lineChanges","_originalForeignVZ","_modifiedForeignVZ","getViewRange","getViewZones","originalLineHeight","modifiedLineHeight","originalHasWrapping","modifiedHasWrapping","hasWrapping","originalCoordinatesConverter","modifiedCoordinatesConverter","originalEndEquivalentLineNumber","modifiedEndEquivalentLineNumber","sortMyViewZones","addAndCombineIfPossible","lastItem","modifiedForeignVZ","originalForeignVZ","lastOriginalLineNumber","lastModifiedLineNumber","_getViewLineCount","stepOriginal","stepModified","originalViewLineCount","modifiedViewLineCount","viewZoneLineNumber","_createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion","isChangeOrInsert","_produceOriginalFromDiff","isChangeOrDelete","_produceModifiedFromDiff","stepOriginalIndex","stepModifiedIndex","originalDelta","modifiedDelta","shouldNotShrink","_ensureDomNodes","createFakeLinesDiv","createDecoration","DECORATIONS","charDelete","charDeleteWholeLine","charInsert","charInsertWholeLine","lineInsert","lineInsertWithSign","lineDelete","lineDeleteWithSign","lineDeleteMargin","_disableSash","_sashRatio","_sashPosition","_startSashPosition","_onSashDragStart","_onSashDrag","_onSashDragEnd","_onSashReset","newDisableSash","sashRatio","sashPosition","midPoint","MINIMUM_EDITOR_WIDTH","SideBySideViewZonesComputer","overviewZoneColor","originalViewModel","modifiedViewModel","computer","InlineViewZonesComputer","zoneIndex","zoneHeightInLines","_originalModel","_renderIndicators","_pendingLineChange","_pendingViewZones","_lineBreaksComputer","_finalize","modifiedEditorOptions","lineBreakIndex","hasCharChanges","maxCharsPerLine","renderedLineCount","actualDecorations","lastBreakOffset","viewLineContent","_renderOriginalLine","marginDomNode2","marginElement","validateDiffWordWrap","added","lineAdded","gutterAdded","lineRemoved","gutterRemoved","addedOutline","removedOutline","diffDiagonalFillColor","AbstractCodeEditorService","_onCodeEditorAdd","_onCodeEditorRemove","_onDiffEditorAdd","onDiffEditorAdd","_onDiffEditorRemove","onDiffEditorRemove","_decorationOptionProviders","_modelProperties","_codeEditors","_diffEditors","_globalStyleSheet","editorWithWidgetFocus","editors","refCount","ed","key1","innerMap","StandaloneCodeEditorService","_checkContextKey","_editorIsOpen","_activeCodeEditor","hasCodeEditor","setActiveCodeEditor","doOpenEditor","findModel","ILayoutService","StandaloneLayoutService","onDidLayout","_dimension","hasContainer","EditorScopedLayoutService","getResourceLabel","stackElementCounter","ResourceStackElement","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","confirmBeforeUndo","resourceLabels","strResources","setValid","ResourceReasonPair","RemovedResources","createMessage","externalRemoval","noParallelUniverses","messages","WorkspaceStackElement","removedResources","invalidatedResources","canSplit","removeResource","ResourceEditStack","_past","_future","locked","flushAllElements","_setElementValidFlag","futureElement","snapshotLength","snapshotIndex","removePastAfter","removeFutureBefore","getClosestPastElement","getSecondClosestPastElement","getClosestFutureElement","hasPastElements","hasFutureElements","splitPastWorkspaceElement","individualMap","splitFutureWorkspaceElement","moveBackward","moveForward","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_editStacks","_uriComparisonKeyComputers","uriComparisonKeyComputer","_print","_pushElement","nextOrder","editStack","closestPastElement","_splitPastWorkspaceElement","ignoreResources","individualArr","_splitFutureWorkspaceElement","_findClosestUndoElementWithSource","matchedElement","matchedStrResource","resourceOrSource","_acquireLocks","editStackSnapshot","_safeInvokeWithLocks","cleanup","continuation","releaseLocks","_invokeWorkspacePrepare","_invokeResourcePrepare","_getAffectedEditStacks","affectedEditStacks","_tryToSplitAndUndo","WorkspaceVerificationError","_undo","_checkWorkspaceUndo","checkInvalidatedResources","cannotUndoDueToResources","cannotLockDueToResources","_workspaceUndo","undoConfirmed","verificationError","_confirmAndExecuteWorkspaceUndo","_isPartOfUndoGroup","pastElement","secondPastElement","cancelId","verificationError1","verificationError2","_continueUndoInGroup","_resourceUndo","_findClosestUndoElementInGroup","shouldPromptForConfirmation","_confirmAndContinueUndo","_findClosestRedoElementWithSource","_tryToSplitAndRedo","_redo","_checkWorkspaceRedo","cannotRedoDueToResources","_workspaceRedo","_executeWorkspaceRedo","_continueRedoInGroup","_resourceRedo","_findClosestRedoElementInGroup","editorConfigurationBaseNode","editorConfiguration","isConfigurationPropertySchema","cachedEditorConfigurationKeys","getEditorConfigurationKeys","isEditorConfigurationKey","editorConfigurationKeys","isDiffEditorConfigurationKey","ConfigurationModel","_contents","_overrides","overrideConfigurations","checkAndFreeze","section","getOverrideValue","overrideContents","getContentsForOverrideIdentifer","overrideConfigurationModel","createOverrideConfigurationModel","mergeContents","otherOverride","identifiers","contentsForKey","overrideContentsForKey","contentsForIdentifierOnly","contentsToMerge","addKey","removeValue","removeKey","DefaultConfigurationModel","configurationDefaultsOverrides","getConfigurationProperties","defaultOverrideValue","_defaultConfiguration","_localUserConfiguration","_remoteUserConfiguration","_workspaceConfiguration","_folderConfigurations","_memoryConfiguration","_memoryConfigurationByResource","_freeze","_workspaceConsolidatedConfiguration","_foldersConsolidatedConfigurations","_userConfiguration","workspace","consolidateConfigurationModel","getConsolidateConfigurationModel","memoryConfiguration","folderConfigurationModel","getFolderConfigurationModelForResource","memoryConfigurationModel","userValue","userConfiguration","userLocalValue","localUserConfiguration","userRemoteValue","remoteUserConfiguration","workspaceValue","workspaceFolderValue","memoryValue","overrideIdentifiers","userLocal","userRemote","workspaceFolder","configurationModel","getConsolidatedConfigurationModelForResource","consolidateConfiguration","getWorkspaceConsolidatedConfiguration","getFolder","getFolderConsolidatedConfiguration","memoryConfigurationForResource","folderConsolidatedConfiguration","workspaceConsolidateConfiguration","folderConfiguration","toData","folders","defaultConfiguration","parseConfigurationModel","workspaceConfiguration","ConfigurationChangeEvent","currentConfiguraiton","currentWorkspace","_previousConfiguration","keysSet","affectedKeys","affectedKeysTree","previousConfiguration","doesAffectedKeysTreeContains","value1","value2","requestedTree","HIGH_FREQ_COMMANDS","AbstractKeybindingService","_onDidUpdateKeybindings","_currentChord","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","_currentSingleModifier","_currentSingleModifierClearTimeout","_logging","_log","getKeybindings","_getResolver","lookupPrimaryKeybinding","resolvedKeybinding","_dispatch","softDispatch","resolveKeyboardEvent","isChord","getDispatchParts","contextValue","currentChord","keypress","_enterChordMode","keypressLabel","chordEnterTime","_documentHasFocus","_leaveChordMode","_doDispatch","_singleModifierDispatch","singleModifier","getSingleModifierDispatchParts","getParts","isSingleModiferChord","shouldPreventDefault","dispatchKeyname","resolveResult","enterChord","hideAfter","bubble","commandArgs","KeybindingResolver","defaultKeybindings","_defaultKeybindings","_defaultBoundCommands","defaultKeybinding","_lookupMap","_keybindings","handleRemovals","keypressParts","_addKeyPress","defaultKb","keypressFirstPart","keypressChordPart","removals","commandRemovals","isRemoved","commandRemoval","_isTargetedForRemoval","conflicts","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","lookupMap","_findCommand","printWhenExplanation","printSourceExplanation","leaveChord","_contextMatchesRules","evaluate","isBuiltinExtension","ResolvedKeybindingItem","_resolvedKeybindingItemBrand","removeElementsAfterNulls","BaseResolvedKeybinding","os","_parts","_getLabel","_getElectronAccelerator","_getPart","_getDispatchPart","_getSingleModifierDispatchPart","USLayoutResolvedKeybinding","_keyCodeToUILabel","getDispatchStr","immutableKeyCode","binding","_scanCodeToKeyCode","_resolveSimpleUserBinding","LayoutAnchorMode","layoutAfterAnchorBoundary","ALIGN","layoutBeforeAnchorBoundary","ContextView","toDisposeOnClean","toDisposeOnSetContainer","shadowRootHostElement","useFixedPosition","setContainer","attachShadow","SHADOW_ROOT_CSS","BUBBLE_UP_EVENTS","onDOMEvent","BUBBLE_DOWN_EVENTS","getViewElement","canRelayout","around","elementPosition","viewSizeWidth","viewSizeHeight","anchorAxisAlignment","verticalAnchor","pageYOffset","horizontalAnchor","AVOID","containerPosition","onCapture","ContextViewService","layoutService","currentViewDisposable","contextView","getContextViewElement","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","splitChar","inBraces","inBrackets","curVal","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","choices","braceRegExp","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","patternKey","trimForExclusions","parsedPattern","wrapRelativePattern","trivia2","trivia3","trivia4and5","toRegExp","arg2","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","withBasenames","allPaths","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","testPath","hasSibling","isRelativePattern","resultPattern","parsedExpression","rp","expression","parseExpressionPattern","requiresSiblings","resultExpression","clausePattern","basenamePatterns","aggregate","aggregatedPatterns","registeredAssociations","nonUserRegisteredAssociations","userRegisteredAssociations","registerPlatformLanguageAssociation","association","warnOnOverwrite","_registerLanguageAssociation","userConfigured","associationItem","toLanguageAssociationItem","filepattern","firstline","filenameLowercase","extensionLowercase","filepatternLowercase","filepatternOnPath","clearPlatformLanguageAssociations","getMimeTypes","configuredLanguage","getMimeByPath","registeredLanguage","firstlineLanguage","getMimeByFirstline","associations","filenameMatch","patternMatch","extensionMatch","NULL_LANGUAGE_ID","LanguageIdCodec","_languageIdToLanguage","_languageToLanguageId","_nextLanguageId","LanguagesRegistry","useModesRegistry","instanceCount","_warnOnOverwrite","_dynamicLanguages","_mimeTypesMap","_nameMap","_lowercaseNameMap","_initializeFromRegistry","_registerLanguages","_registerLanguage","mimetype","registerOverrideIdentifiers","getRegisteredLanguageIds","resolvedLanguage","filenames","configurationFiles","icons","_mergeLanguage","primaryMime","filenamePatterns","filenamePattern","firstLineRegexStr","firstLineRegex","langAliases","langAlias","containsAliases","bestName","languageName","languageNameLower","mimeTypes","LanguageService","_onDidEncounterLanguage","onDidEncounterLanguage","_encounteredLanguages","languageIds","createById","LanguageSelection","_createAndGetLanguageIdentifier","createByFilepathOrFirstLine","_selector","_dispose","_evaluate","MENU_MNEMONIC_REGEX","MENU_ESCAPED_MNEMONIC_REGEX","Direction","Menu","menuElement","doGetActionViewItem","parentData","menuDisposables","initializeOrUpdateStyleSheet","enableMnemonics","mnemonics","SubmenuMenuActionViewItem","focusItemByElement","relatedTarget","lastFocusedItem","setFocusedItem","scrollElement","submenuIds","MenuSeparatorActionViewItem","updatePositionInSet","styleSheet","globalStyleSheet","getMenuWidgetCSS","fgColor","foregroundColor","bgColor","shadowColor","BaseMenuActionViewItem","menuActionViewItem","mnemonic","getMnemonic","actionViewItems","menuItemOptions","getKeyBinding","keybindingLabel","runOnceToEnableMouseUp","applyStyle","setSize","cleanLabel","cleanMnemonic","escMatch","replaceDoubleEscapes","menuStyle","isSelected","selectionForegroundColor","selectionBackgroundColor","selectionBorderColor","submenuActions","submenuOptions","mysubmenu","submenuDisposables","mouseOver","expandDirection","showScheduler","cleanupExistingSubmenu","createSubmenu","hideScheduler","updateAriaExpanded","submenuIndicator","submenuContainer","calculateSubmenuMenuLayout","windowDimensions","selectFirstItem","computedStyles","entryBox","entryBoxUpdated","viewBox","separatorColor","mnemonicInText","isForShadowDom","scrollbarShadow","scrollbarSliderBackground","scrollbarSliderHoverBackground","scrollbarSliderActiveBackground","ContextMenuHandler","contextViewService","telemetryService","focusToReturn","blockMouse","configure","shadowRootElement","getMenuClassName","onActionRun","onDidActionRun","getActionViewItem","getActionsContext","didCancel","ContextMenuService","_onDidShowContextMenu","_onDidHideContextMenu","contextMenuHandler","EditorOpenSource","CommandOpener","EditorOpener","USER","API","OpenerService","_openers","_validators","_resolvers","_resolvedUriTargets","_externalOpeners","_defaultExternalOpener","openExternal","_doOpenExternal","registerOpener","registerValidator","validator","registerExternalUriResolver","setDefaultExternalOpener","externalOpener","registerExternalOpener","targetURI","validationTarget","shouldOpen","handled","resolveExternalUri","externalUri","preferredOpenerId","didOpen","sourceUri","IMarkerData","_displayStrings","fromSeverity","Hint","toSeverity","emptyString","makeKey","markerData","makeKeyOptionalMessage","useMessage","IMarkerService","MarkerDecorations","_markersData","oldIds","getMarker","MarkerDecorationsService","_markerService","_onDidChangeMarker","_markerDecorations","onMarkerChanged","_handleMarkerChange","markerDecorations","changedResources","take","newModelDecorations","_createDecorationRange","_createDecorationOption","rawMarker","_hasMarkerTag","buttonBackground","buttonHoverBackground","buttonForeground","Button","_onDidClick","buttonSecondaryForeground","buttonSecondaryBackground","buttonSecondaryHoverBackground","buttonBorder","eventType","setHoverBackground","onDidClick","hoverBackground","CSS_DONE","CSS_ACTIVE","CSS_INFINITE","CSS_INFINITE_LONG_RUNNING","CSS_DISCRETE","progressBarBackground","ProgressBar","workedVal","showDelayedScheduler","longRunningScheduler","infiniteLongRunning","LONG_RUNNING_INFINITE_THRESHOLD","off","totalWork","doDone","delayed","infinite","iconPathToClass","iconClassGenerator","getIconClass","iconPath","iconClass","QuickInputBox","password","showDecoration","KeybindingLabel","keyElements","labelBackground","keybindingLabelBackground","labelForeground","keybindingLabelForeground","labelBorder","keybindingLabelBorder","labelBottomBorder","keybindingLabelBottomBorder","labelShadow","keybindingLabelShadow","areSame","renderPart","renderUnboundKeybindings","renderUnbound","renderKey","createKeyElement","extraClass","keyElement","intlFileNameCollatorBaseNumeric","collator","sensitivity","collatorIsNumeric","compareFileNames","compareAnything","lookFor","elementAName","elementBName","prefixCompare","compareByPrefix","elementASuffixMatch","elementBSuffixMatch","localeCompare","elementAPrefixMatch","elementBPrefixMatch","ListElement","init","hidden","_onChecked","onChecked","ListElementRenderer","toDisposeElement","toDisposeTemplate","row1","row2","keybindingContainer","detailContainer","labelHighlights","descriptionHighlights","detailHighlights","saneDescription","iconClasses","saneLabel","saneDetail","cssClasses","alwaysVisible","fireButtonTriggered","ListElementDelegate","QuickInputListFocus","QuickInputList","inputElements","elementsToIndexes","matchOnDescription","matchOnDetail","matchOnLabel","matchOnMeta","sortByLabel","_onChangedAllVisibleChecked","onChangedAllVisibleChecked","_onChangedCheckedCount","onChangedCheckedCount","_onChangedVisibleCount","onChangedVisibleCount","_onChangedCheckedElements","onChangedCheckedElements","_onButtonTriggered","onButtonTriggered","_onLeave","onLeave","_fireCheckedEvents","elementDisposables","QuickInputAccessibilityProvider","createList","toggleCheckbox","focus1","focus2","getAllVisibleChecked","allVisibleChecked","whenNoneVisible","getCheckedCount","getVisibleCount","setAllVisibleChecked","fireCheckedEvents","setElements","saneMeta","saneAriaLabel","hasCheckbox","setFocusedElements","getActiveDescendant","setSelectedElements","getCheckedElements","setCheckedElements","Next","First","Previous","Last","Second","NextPage","PreviousPage","clearFocus","currentSeparator","metaHighlights","alwaysShow","shownElements","normalizedSearchValue","compareEntries","allChecked","isDisplayed","elementA","elementB","labelHighlightsA","labelHighlightsB","backButton","QuickInput","ui","_busy","_ignoreFocusOut","_buttons","noValidationMessage","noPromptMessage","_severity","buttonsUpdated","onDidTriggerButtonEmitter","onDidHideEmitter","onDisposeEmitter","visibleDisposables","_steps","totalSteps","_totalSteps","contextKey","_contextKey","busy","ignoreFocusOut","validationMessage","_validationMessage","onDidTriggerButton","_lastValidationMessage","_lastSeverity","didHide","getTitle","getDescription","description1","description2","busyDelay","progressBar","leftActionBar","leftButtons","rightActionBar","rightButtons","setContextKey","showMessageDecoration","getSteps","marginBottom","QuickPick","onDidChangeValueEmitter","onWillAcceptEmitter","onDidAcceptEmitter","onDidCustomEmitter","itemsUpdated","_canSelectMany","_canAcceptInBackground","_matchOnDescription","_matchOnDetail","_matchOnLabel","_sortByLabel","_autoFocusOnList","_keepScrollPosition","_itemActivation","_activeItems","activeItemsUpdated","activeItemsToConfirm","onDidChangeActiveEmitter","_selectedItems","selectedItemsUpdated","selectedItemsToConfirm","onDidChangeSelectionEmitter","onDidTriggerItemButtonEmitter","valueSelectionUpdated","_ok","_customButton","filterValue","onDidChangeValue","onWillAccept","onDidAccept","onDidChangeActive","onDidTriggerItemButton","quickNavigate","_quickNavigate","doSetValue","skipUpdate","didFilter","trySelectFirst","_placeholder","canSelectMany","canAcceptInBackground","autoFocusOnList","keepScrollPosition","itemActivation","activeItems","selectedItems","keyMods","valueSelection","_valueSelection","customButton","showCustomButton","customLabel","_customButtonLabel","customHover","_customButtonHover","showOkButton","hideInput","_hideInput","handleAccept","onDidCustom","focusedItems","checkedItems","registerQuickNavigation","inBackground","veto","quickNavKeys","keybindings","wasTriggerKeyPressed","scrollTopBefore","visibilities","_hideCheckAll","checkBox","setVisibilities","DEFAULT_ARIA_LABEL","setComboboxAccessibility","QuickInputController","comboboxAccessibility","onShowEmitter","onShow","onHideEmitter","idPrefix","registerKeyModsListeners","getUI","titleBar","headerContainer","extraContainer","filterContainer","visibleCountContainer","countContainer","okContainer","customButtonContainer","previousFocusElement","selectors","stops","updateStyles","onKeyMods","createQuickPick","keepScrollPositionBefore","ignoreFocusLost","_activeItem","picked","oldController","backKeybindingLabel","updateLayout","focusChanged","returnFocus","titleBarOffset","MAX_WIDTH","quickInputTitleBackground","quickInputBackground","quickInputForeground","contrastBorder","widgetShadow","countBadge","pickerGroupBorder","pickerGroupForeground","newStyles","QuickAccessController","mapProviderToDescriptor","lastAcceptedPickerValues","visibleQuickAccess","doShowOrPick","getOrInstantiateProvider","visibleDescriptor","preserveValue","picker","adjustValueSelection","newValueCandidateWithoutPrefix","defaultFilterValue","pickPromise","quickNavigateConfiguration","registerPickerListeners","providerForValue","providerDescriptor","getQuickAccessProvider","QuickInputService","contexts","createController","quickAccess","_quickAccess","computeStyles","resetContextKeys","EditorScopedQuickInputService","QuickInputEditorContribution","_serviceBrand","StandaloneQuickInputService","mapEditorToService","activeService","newQuickInputService","QuickInputEditorWidget","ParsedTokenThemeRule","_parsedThemeRuleBrand","parseTokenTheme","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","incomingDefaults","ColorMap","foregroundColorId","backgroundColorId","ThemeTrieElementRule","ThemeTrieElement","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","createFromParsedTokenTheme","toStandardTokenType","STANDARD_TOKEN_TYPE_REGEXP","_themeTrieElementRuleBrand","_background","acceptOverwrite","mainRule","_themeTrieElementBrand","_mainRule","dotIndex","generateTokensCSSForColorMap","vs","inherit","vs_dark","hc_black","getIconsStyleSheet","onDidChangeEmmiter","iconRegistry","onDidProductIconThemeChange","getCSS","productIconTheme","getProductIconTheme","UnthemedProductIconTheme","usedFontIds","formatIconRule","getIcon","fontContribution","getIcons","VS_THEME_NAME","VS_DARK_THEME_NAME","HC_BLACK_THEME_NAME","themingRegistry","StandaloneTheme","standaloneThemeData","themeData","isBuiltinTheme","themeName","defaultColors","notifyBaseUpdated","getColors","baseData","getBuiltinRules","useDefault","getDefault","resolveDefaultColor","encodedTokensColors","editorForeground","editorBackground","createFromRawTokenTheme","modelLanguage","builtinTheme","newBuiltInTheme","StandaloneThemeService","_onColorThemeChange","_onProductIconThemeChange","_environment","_builtInProductIconTheme","_autoDetectHighContrast","_knownThemes","iconsStyleSheet","_codiconCSS","_themeCSS","_allCSS","_globalStyleElement","_styleElements","_colorMapOverride","_updateCSS","_updateActualTheme","registerEditorContainer","_registerShadowDomContainer","_registerRegularEditorContainer","defineTheme","setColorMapOverride","colorMapOverride","_updateThemeOrColorMap","_desiredTheme","setAutoDetectHighContrast","autoDetectHighContrast","hasRule","ruleCollector","getThemingParticipants","colorVariables","hidesExplorerArrows","AccessibilityService","_onDidChangeScreenReaderOptimized","_accessibilityModeEnabledContext","updateContextKey","MenuService","emitEventsForSubmenuChanges","eventDebounceDelay","_menuGroups","_contextKeys","_build","rebuildMenuSoon","contextKeyListener","startContextKeyListener","fireChangeSoon","onDidChangeContext","affectsSome","menuItems","_compareMenuItems","groupName","_collectContextKeys","_fillInKbExprKeys","toggled","toggledExpression","activeActions","exp","aGroup","bGroup","aPrio","bPrio","_compareTitles","aStr","bStr","BrowserClipboardService","mapTextToType","findText","installWebKitWriteTextWorkaround","currentWritePromise","webKitPendingClipboardWritePromise","ClipboardItem","KEYBINDING_CONTEXT_ATTR","_parent","NullContext","ConfigAwareContextValuesContainer","allKeys","ArrayContextKeyChangeEvent","changedKeys","configKey","cachedItems","_keyPrefix","configValue","ContextKey","setContext","removeContext","SimpleContextKeyChangeEvent","CompositeContextKeyChangeEvent","AbstractContextKeyService","myContextId","_onDidChangeContext","_myContextId","ScopedContextKeyService","getContextValuesContainer","myContext","findContextAttr","ContextKeyService","_contexts","_lastContextId","contextId","createChildContext","parentContextId","disposeContext","_parentChangeListener","_updateParentChangeListener","extraInfo","NaN","incoming","outgoing","Graph","_hashFn","_nodes","insertEdge","fromNode","lookupOrInsertNode","toNode","removeNode","findCycleSlow","_findCycle","_enableTracing","CyclicDependencyError","InstantiationService","services","_activeInstantiations","_services","_trace","Trace","traceInvocation","_done","_getOrCreateServiceInstance","ctorOrDescriptor","traceCreation","_createInstance","staticArguments","serviceDependencies","serviceArgs","dependency","_throwIfStrict","firstServiceArgPos","_setServiceInstance","_getServiceInstanceOrDescriptor","instanceOrDesc","_safeCreateAndCacheServiceInstance","branch","_createAndCacheServiceInstance","cycleCount","_createServiceInstanceWithOwner","supportsDelayedInstantiation","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","printWarning","_dep","_None","dur","_totals","causedCreation","printChild","DoubleResourceMap","_byResource","_byOwner","ownerMap","resourceMap","removedA","removedB","MarkerStats","infos","warnings","unknowns","_subscription","oldStats","_substract","newStats","_resourceStats","MarkerService","_onMarkerChanged","changeOne","_toMarker","relatedInformation","severities","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookType","notebookType","normalizedPattern","isExclusive","exclusive","LanguageFeatureRegistry","_notebookTypeResolver","_clock","_score","_time","_lastCandidate","_updateScores","_orderedForEach","lastBucket","lastBucketScore","_compareByScoreAndTime","LanguageFeaturesService","SimpleModel","StandaloneTextModelService","StandaloneEditorProgressService","NULL_PROGRESS_RUNNER","worked","StandaloneDialogService","confirmation","doConfirm","checkboxChecked","messageText","StandaloneNotificationService","notification","NO_OP","StandaloneCommandService","_onWillExecuteCommand","_onDidExecuteCommand","onWillExecuteCommand","StandaloneKeybindingService","_cachedResolver","_dynamicKeybindings","_domNodeListeners","addContainer","keyEvent","DomNodeListeners","removeContainer","domNodeListeners","addDynamicKeybinding","_keybinding","weight1","weight2","updateResolver","_toNormalizedKeybindingItems","resolvedKeybindings","resolveUserBinding","isConfigurationOverrides","StandaloneConfigurationService","updateValues","configurationChangeEvent","sourceConfig","arg3","arg4","StandaloneResourceConfigurationService","StandaloneResourcePropertiesService","StandaloneTelemetryService","publicLog","StandaloneWorkspaceContextService","SCHEME","updateConfigurationService","toUpdate","StandaloneBulkEditService","totalEdits","totalFiles","StandaloneUriLabelService","StandaloneContextViewService","StandaloneWorkspaceTrustManagementService","_neverEmitter","StandaloneLanguageService","StandaloneLogService","StandaloneContextMenuService","StandaloneServices","serviceCollection","serviceId","initialized","initialize","serviceIdentifier","LAST_GENERATED_COMMAND_ID","ariaDomNodeCreated","createAriaDomNode","StandaloneCodeEditor","_standaloneKeybindingService","ariaContainerElement","addCommand","whenExpression","createContextKey","_descriptor","keybindingsWhen","keybindingContext","contextMenuGroupId","contextMenuOrder","uniqueId","menuItem","StandaloneEditor","themeDomRegistration","createTextModel","_ownsModel","StandaloneDiffEditor","editorProgressService","firstLF","doCreateModel","onDidCreateEditor","createDiffEditor","createDiffNavigator","setModelLanguage","setModelMarkers","markerService","getModelMarkers","onDidChangeMarkers","onDidCreateModel","onWillDisposeModel","colorizeElement","colorizeModelLine","getSafeTokenizationSupport","remeasureFonts","createMonacoEditorAPI","isArrayOf","elemType","bool","defValue","arrayToHash","createKeywordMatcher","caseInsensitive","compileRegExp","hadExpansion","selectScrutinee","num","createGuard","tkey","scrut","oppat","tester","pat","inWords","patx","patexp","scrutinee","compileAction","newAction","usesEmbedded","cases","_case","didmatch","Rule","sregex","setAction","act","compile","noThrow","lexerMin","addRules","newrules","newrule","rule1","matchOnlyAtStart","getEncodedLanguageId","encounteredLanguageId","EncodedTokenizationSupportAdapter","TokenizationSupportAdapter","adaptTokenize","previousStartIndex","actualResult","_toClassicTokens","_toBinaryTokens","isATokensProvider","isEncodedTokensProvider","createTokenizationSupportAdapter","adaptedFactory","setMonarchTokensProvider","languageDef","registerReferenceProvider","languageSelector","registerRenameProvider","registerSignatureHelpProvider","registerHoverProvider","registerDocumentSymbolProvider","registerDocumentHighlightProvider","registerLinkedEditingRangeProvider","registerDefinitionProvider","registerImplementationProvider","registerTypeDefinitionProvider","registerCodeLensProvider","registerCodeActionProvider","providedCodeActionKinds","provideCodeActions","only","resolveCodeAction","registerDocumentFormattingEditProvider","registerDocumentRangeFormattingEditProvider","registerOnTypeFormattingEditProvider","registerLinkProvider","registerCompletionItemProvider","registerColorProvider","registerFoldingRangeProvider","registerDeclarationProvider","registerSelectionRangeProvider","registerDocumentSemanticTokensProvider","registerDocumentRangeSemanticTokensProvider","registerInlineCompletionsProvider","registerInlayHintsProvider","createMonacoLanguagesAPI","api","require","ignoreDuplicateModules","CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE","AccessibilityHelpController","AccessibilityHelpWidget","getSelectionLabel","charactersSelected","_isVisibleKey","_contentDomNode","_buildContent","accessibilityHelpUrl","_descriptionForCommand","noKbMsg","turnOnMessage","openDocMessage","ShowAccessibilityHelpAction","AccessibilityHelpCommand","IPadShowKeyboard","shouldHaveWidget","ShowKeyboardWidget","InspectTokensController","standaloneColorService","launch","InspectTokensWidget","InspectTokens","renderTokenText","_tokenizationSupport","_ID","_getTokensAtLine","token1Index","tokens1","token2Index","tokens2","_decodeMetadata","_tokenTypeToString","_fontStyleToString","stateBeforeLine","_getStateBeforeLine","tokenizationResult1","tokenizationResult2","startState","exceptionToErrorMessage","exception","verbose","detectSystemErrorMessage","stackToString","errno","syscall","toErrorMessage","TriggerAction","isPicksWithActive","isFastAndSlowPicks","additionalPicks","PickerQuickAccessProvider","picksCts","picksDisposable","updatePickerItems","picksDisposables","picksToken","picksFilter","providedPicks","_getPicks","applyPicks","skipEmpty","noResultsPick","fastPicksApplied","slowPicksApplied","FAST_PICKS_RACE_DELAY","awaitedAdditionalPicks","activePick","additionalActivePick","fallbackActivePick","fallbackActivePickCandidate","awaitedPicks","buttonIndex","NO_ACTION","CLOSE_PICKER","REFRESH_PICKER","REMOVE_ITEM","AbstractCommandsQuickAccessProvider","dialogService","PREFIX","commandsHistory","CommandsHistory","allCommandPicks","getCommandPicks","filteredCommandPicks","commandPick","WORD_FILTER","aliasHighlights","commandAlias","showAlias","mapLabelToCommand","existingCommandForLabel","commandPickA","commandPickB","commandACounter","commandBCounter","commandPicks","addSeparator","configuredCommandsHistoryLength","registerListeners","getConfiguredCommandHistoryLength","PREF_KEY_CACHE","serializedCache","usesLRU","getNumber","PREF_KEY_COUNTER","configuredCommandHistoryLength","workbench","commandPalette","DEFAULT_COMMANDS_HISTORY_LENGTH","AbstractEditorCommandsQuickAccessProvider","getCodeEditorCommandPicks","activeTextEditorControl","editorCommandPicks","StandaloneCommandsQuickAccessProvider","registerQuickAccessProvider","helpEntries","needsEditor","GotoLineAction","NO_SCORE2","scoreFuzzy2","preparedQuery","doScoreFuzzy2Multiple","doScoreFuzzy2Single","totalScore","totalMatches","queryPiece","normalizeMatches","originalLowercase","sortedMatches","matchA","matchB","normalizedMatches","matchOverlaps","queryExpectsExactMatch","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","normalized","normalizedLowercase","normalizeQuery","containsPathSeparator","expectExactMatch","originalSplit","originalPiece","expectExactMatchPiece","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","expectContiguousMatch","pieceToQuery","AbstractEditorNavigationQuickAccessProvider","rangeHighlightDecorationId","pickerDisposable","doProvide","onDidActiveTextEditorControlChange","canProvideWithTextEditor","lastKnownEditorViewState","clearDecorations","provideWithTextEditor","provideWithoutTextEditor","addDecorations","deleteDecorations","overviewRulerDecorationId","rangeHighlightId","AbstractGotoSymbolQuickAccessProvider","_outlineModelService","provideLabelPick","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","waitForLanguageSymbolRegistry","symbolProviderRegistryPromise","symbolProviderListener","forceSideBySide","symbolsPromise","getDocumentSymbols","doGetSymbolPicks","ignoreFirstActiveEvent","filterBySymbolKind","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","filteredSymbolPicks","symbolLabel","symbolLabelWithIcon","symbolLabelIconOffset","symbolScore","symbolMatches","containerScore","containerMatches","containerLabel","extraContainerLabel","skipContainerQuery","deprecated","openSideBySideDirection","sortedFilteredSymbolPicks","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","PREFIX_BY_CATEGORY","StandaloneGotoSymbolQuickAccessProvider","outlineModelService","ToggleHighContrast","_originalThemeName","IStandaloneThemeService","localize","IAccessibilityService","CONTEXT_ACCESSIBILITY_MODE_ENABLED","BaseDropdown","_onDidChangeVisibility","onDidChangeVisibility","labelRenderer","cleanupFn","boxContainer","DropdownMenu","_contextMenuProvider","contextMenuProvider","actionProvider","menuClassName","menuAsChild","menuOptions","_menuOptions","DropdownMenuActionViewItem","menuActionsOrProvider","actionItem","isActionsArray","dropdownMenu","keybindingProvider","anchorAlignmentProvider","that","MenuEntryActionViewItem","_wantsAltCommand","_itemClassDispose","_menuItemAction","_commandAction","_updateItemClass","alternativeKeyDown","updateAltState","wantsAltCommand","altTooltip","altKeybinding","altKeybindingLabel","altTitleSection","SubmenuEntryActionViewItem","dropdownOptions","DropdownWithDefaultActionViewItem","submenuAction","defaultAction","_storageKey","_debugName","defaultActionId","_defaultAction","_dropdown","lastAction","primaryContainer","dropdownContainer","createActionViewItem","rememberDefaultAction","isIMenuItem","MenuId","debugName","CommandPalette","DebugBreakpointsContext","DebugCallStackContext","DebugConsoleContext","DebugVariablesContext","DebugWatchContext","DebugToolBar","EditorContext","SimpleEditorContext","EditorContextCopy","EditorContextPeek","EditorTitle","EditorTitleRun","EditorTitleContext","EmptyEditorGroup","EmptyEditorGroupContext","ExplorerContext","ExtensionContext","GlobalActivity","LayoutControlMenuSubmenu","LayoutControlMenu","MenubarMainMenu","MenubarAppearanceMenu","MenubarDebugMenu","MenubarEditMenu","MenubarCopy","MenubarFileMenu","MenubarGoMenu","MenubarHelpMenu","MenubarLayoutMenu","MenubarNewBreakpointMenu","MenubarPanelAlignmentMenu","MenubarPanelPositionMenu","MenubarPreferencesMenu","MenubarRecentMenu","MenubarSelectionMenu","MenubarSwitchEditorMenu","MenubarSwitchGroupMenu","MenubarTerminalMenu","MenubarViewMenu","MenubarHomeMenu","OpenEditorsContext","ProblemsPanelContext","SCMChangeContext","SCMResourceContext","SCMResourceFolderContext","SCMResourceGroupContext","SCMSourceControl","SCMTitle","SearchContext","StatusBarWindowIndicatorMenu","StatusBarRemoteIndicatorMenu","TestItem","TestItemGutter","TestPeekElement","TestPeekTitle","TouchBarContext","TitleBarContext","TunnelContext","TunnelPrivacy","TunnelProtocol","TunnelPortInline","TunnelTitle","TunnelLocalAddressInline","TunnelOriginInline","ViewItemContext","ViewContainerTitle","ViewContainerTitleContext","ViewTitle","ViewTitleContext","CommentThreadTitle","CommentThreadActions","CommentTitle","CommentActions","InteractiveToolbar","InteractiveCellTitle","InteractiveCellExecute","InteractiveInputExecute","NotebookToolbar","NotebookCellTitle","NotebookCellInsert","NotebookCellBetween","NotebookCellListTop","NotebookCellExecute","NotebookCellExecutePrimary","NotebookDiffCellInputTitle","NotebookDiffCellMetadataTitle","NotebookDiffCellOutputsTitle","NotebookOutputToolbar","NotebookEditorLayoutConfigure","BulkEditTitle","BulkEditContext","TimelineItemContext","TimelineTitle","TimelineTitleContext","AccountsContext","PanelTitle","AuxiliaryBarTitle","TerminalInstanceContext","TerminalEditorInstanceContext","TerminalNewDropdownContext","TerminalTabContext","TerminalTabEmptyAreaContext","TerminalInlineTabContext","WebviewContext","InlineCompletionsActions","NewFile","IMenuService","MenuRegistry","_menuItems","_onDidChangeMenu","onDidChangeMenu","_commandPaletteChangeEvent","addCommands","getCommands","appendMenuItem","appendMenuItems","changedIds","getMenuItems","_appendImplicitItems","SubmenuItemAction","MenuItemAction","renderShortTitle","shortTitle","runArgs","shouldForwardArgs","IClipboardService","ICommandService","CommandsRegistry","_onDidRegisterCommand","onDidRegisterCommand","idOrCommand","actualHandler","registerCommandAlias","oldId","newId","IConfigurationService","toValuesTree","conflictReporter","addToValueTree","settingsTreeRoot","removeFromValueTree","valueTree","doRemoveFromValueTree","getConfigurationValue","settingPath","accessSetting","component","allSettings","patternProperties","applicationSettings","machineSettings","machineOverridableSettings","windowSettings","resourceSettings","resourceLanguageSettingsSchemaId","contributionRegistry","ConfigurationRegistry","_onDidSchemaChange","_onDidUpdateConfiguration","defaultLanguageConfigurationOverridesNode","configurationContributors","resourceLanguageSettingsSchema","allowTrailingCommas","allowComments","configurationProperties","excludedConfigurationProperties","registerSchema","registerOverridePropertyPatternKey","registerConfigurations","doRegisterConfigurations","configurationDefaults","OVERRIDE_PROPERTY_REGEX","$ref","defaultDefaultValue","overrideIdentifiersFromKey","updatePropertyDefaultValue","updateSchema","defaultsOverrides","updateOverridePropertyPatternKey","validateAndRegisterProperties","extensionInfo","restrictedProperties","registerJSONConfiguration","propertyKeys","validateProperty","subNodes","allOf","overrideIdentifierProperty","resourceLanguagePropertiesSchema","OVERRIDE_PROPERTY_PATTERN","configurationdefaultOverride","defaultSource","getDefaultValue","defaultValueSource","OVERRIDE_IDENTIFIER_PATTERN","OVERRIDE_IDENTIFIER_REGEX","configurationRegistry","CONSTANT_VALUES","ContextKeyExpr","ContextKeyDefinedExpr","ContextKeyEqualsExpr","ContextKeyRegexExpr","ContextKeyNotExpr","expr","ContextKeyAndExpr","ContextKeyOrExpr","serialized","_deserializeOrExpression","_deserializeAndExpression","_deserializeOne","serializedOne","ContextKeyNotEqualsExpr","_deserializeValue","_deserializeRegexValue","ContextKeyInExpr","ContextKeyGreaterEqualsExpr","ContextKeyGreaterExpr","ContextKeySmallerEqualsExpr","ContextKeySmallerExpr","serializedValue","caseIgnoreFlag","expressionsAreEqualWithConstantSubstitution","aExpr","substituteConstants","bExpr","ContextKeyFalseExpr","ContextKeyTrueExpr","negated","constantValue","cmp1","trueValue","cmp2","valueKey","ContextKeyNotInExpr","falseValue","withFloatOrStr","thisSource","otherSource","ContextKeyNotRegexExpr","eliminateConstantsInArray","newExpr","_expr","_normalizeArr","exprArr","hasTrue","secondToLastElement","isFinished","resultElement","extraRedundantCheck","hasFalse","implies","LEFT","RIGHT","getTerminals","RawContextKey","metaOrHide","isEqualTo","IContextKeyService","SET_CONTEXT_COMMAND_ID","key2","qTerm","notP","notA","IsWindowsContext","InputFocusedContextKey","IContextViewService","IContextMenuService","IDialogService","NLS_DEFAULT_LABEL","FindInput","_showOptionButtons","fixFocusOnOptionClickEnabled","imeSessionInProgress","_onDidOptionChange","_onInput","_onCaseSensitiveKeyDown","_onRegexKeyDown","_lastHighlightFindOptions","viaKeyboard","checkBoxStyles","inputBoxStyles","NLS_PRESERVE_CASE_LABEL","PreserveCaseCheckbox","ReplaceInput","cachedOptionsWidth","_onPreserveCaseKeyDown","newWidth","historyNavigationVisible","HistoryNavigationWidgetContext","HistoryNavigationForwardsEnablementContext","HistoryNavigationBackwardsEnablementContext","bindContextScopedWidget","createWidgetScopedContextKeyService","getContextScopedWidget","createAndBindHistoryNavigationWidgetScopedContextKeyService","scopedContextKeyService","historyNavigationForwardsEnablement","historyNavigationBackwardsEnablement","ContextScopedFindInput","showFindOptions","historyNavigator","ContextScopedReplaceInput","showReplaceOptions","historyInputBox","SyncDescriptor","registerSingleton","getSingletonServiceDescriptors","_util","getServiceDependencies","DI_DEPENDENCIES","serviceIds","DI_TARGET","IInstantiationService","createDecorator","storeServiceDependency","ServiceCollection","instanceOrDescriptor","JSONContribution","normalizeId","JSONContributionRegistry","_onDidChangeSchema","schemasById","unresolvedSchemaContent","notifySchemaChanged","jsonContributionRegistry","IKeybindingService","KeybindingsRegistryImpl","_coreKeybindings","_extensionKeybindings","_cachedMergedKeybindings","registerKeybindingRule","actualKb","bindToCurrentPlatform","kk","_registerDefaultKeybinding","registerCommandAndKeybindingRule","_assertNoCtrlAlt","_mightProduceChar","getDefaultKeybindings","sorter","KeybindingsRegistry","EditorModes","ILabelService","PagedRenderer","modelProvider","renderPlaceholder","PagedAccessibilityProvider","fromPagedListOptions","PagedList","pagedRenderers","TableListRenderer","getColumnSize","TemplateId","renderedTemplates","rendererMap","rowContainer","cellContainers","cellTemplateData","cellContainer","layoutColumn","asListVirtualDelegate","ColumnHeader","_onDidLayout","minimumWidth","maximumWidth","onDidChangeWidthConstraints","Table","cachedWidth","headers","splitview","headerRowHeight","totalWeight","TreeMouseEventTarget","TreeError","WeakMapper","isFilterResult","getVisibleState","isCollapsibleStateUpdate","collapsible","IndexTreeModel","rootElement","rootRef","_onDidChangeCollapseState","onDidChangeCollapseState","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","refilterDelayer","collapseByDefault","autoExpandSingleChildren","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","toInsert","diffIdentityProvider","spliceSmart","spliceSimple","identity","toInsertIterable","recurseLevels","diffDepth","getParentNodeWithListIndex","lastDiffIds","locationPrefix","recurseSplice","lastStartO","lastStartM","onDidCreateNode","onDidDeleteNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","createTreeNode","lastHadChildren","visibleChildStartIndex","nodesToInsert","insertedVisibleChildrenCount","deletedNodes","deletedVisibleChildrenCount","visibleDeleteCount","_updateAncestorsRenderNodeCount","visit","insertedNodes","currentlyHasChildren","setCollapsible","refilter","getTreeNodeWithListIndex","hasTreeNode","getListIndex","getListRenderCount","getTreeNode","isCollapsible","_setCollapseState","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","deep","expandTo","updateNodeAfterFilterChange","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","getNode","getNodeLocation","indexTreeNode","getParentNodeLocation","getFirstElementChild","RenderIndentGuides","TreeElementsDragAndDropData","asTreeDragAndDropData","TreeNodeListDragAndDrop","autoExpandDisposable","didChangeAutoExpandNode","autoExpandNode","autoExpand","parentRef","asListOptions","simpleKeyboardNavigation","ComposedTreeDelegate","EventCollection","TreeRenderer","activeNodes","renderedNodes","DefaultIndent","hideTwistiesOfChildlessElements","shouldRenderIndentGuides","renderedIndentGuides","activeIndentNodes","indentGuidesDisposable","onDidChangeNodeTwistieState","onDidChangeTwistieState","_onDidChangeActiveNodes","twistie","renderTwistie","twistieRendered","childElementCount","TypeFilter","_filter","_totalCount","_matchCount","_lowercasePattern","onWillRefilter","totalCount","matchCount","filterOnType","TypeFilterController","_onDidChangeEmptyState","positionClassName","_onDidChangePattern","messageDomNode","labelDomNode","_filterOnType","filterOnTypeDomNode","updateFilterOnTypeTitleAndIcon","onDidChangeFilterOnType","clearDomNode","keyboardNavigationEventFilter","onDidSpliceModel","onEventOrInput","onRawKeyDown","onClearClick","containerWidth","midContainerWidth","noMatches","shouldAllowFocus","asTreeMouseEvent","Unknown","Twistie","dfs","getFirstViewElementWithTrait","nodeSet","_nodeSet","createNodeSet","__forceEvent","getNodes","onDidModelSplice","deletedNodesIdSet","deletedNodesVisitor","insertedNodesMap","insertedNodesVisitor","wasDeleted","insertedNode","TreeNodeListMouseController","onTwistie","expandOnlyOnTwistieClick","expandOnDoubleClick","TreeNodeList","focusTrait","selectionTrait","anchorTrait","additionalFocus","additionalSelection","fromAPI","AbstractTree","_user","_onWillRefilter","_onDidUpdateOptions","treeDelegate","onDidChangeCollapseStateRelay","onDidChangeActiveNodes","onLeftArrow","onRightArrow","onSpace","typeFilterController","focusNavigationFilter","Always","getParentElement","collapse","parentListIndex","focusedIndex","firstChildIndex","ObjectTreeModel","nodesByIdentity","setChildren","getElementLocation","_setChildren","preserveCollapseState","insertedElements","insertedElementIds","tnode","noCompress","incompressible","childrenIterator","_decompress","decompress","wrapIdentityProvider","CompressedObjectTreeModel","compressionEnabled","compressedChildren","compressedNode","compressedParentNode","decompressedElement","splicedElement","recompressedElement","parentChildren","setCompressionEnabled","rootChildren","decompressedRootChildren","recompressedRootChildren","getCompressedNode","DefaultElementMapper","CompressedTreeNodeWrapper","unwrapper","mapList","nodeMapper","updateElementHeight","mapOptions","compressedNodeUnwrapper","otherNode","CompressibleObjectTreeModel","elementMapper","getCompressedTreeNode","ObjectTree","hasElement","CompressibleRenderer","_compressedTreeNodeProvider","compressedTreeNodeProvider","compressedTreeNode","renderCompressedElements","disposeCompressedElements","twistieElement","asObjectTreeOptions","getCompressedNodeKeyboardNavigationLabel","CompressibleObjectTree","compressibleRenderers","createAsyncDataTreeNode","refreshPromise","stale","slow","collapsedByDefault","ancestor","descendant","AsyncDataTreeNodeWrapper","AsyncDataTreeRenderer","asTreeEvent","AsyncDataTreeElementsDragAndDropData","asAsyncDataTreeDragAndDropData","AsyncDataTreeNodeListDragAndDrop","AsyncDataTree","subTreeRefreshPromises","refreshPromises","_onDidRender","_onDidChangeNodeSlowState","createTree","objectTreeDelegate","objectTreeRenderers","objectTreeOptions","viewStateContext","_updateChildren","getDataNode","refreshAndRenderNode","dataNode","refreshNode","doRefreshSubTree","childrenToRefresh","doRefreshNode","childrenPromise","doGetChildren","slowTimeout","processChildren","childrenElementsIterable","childrenElements","nodesToForget","childrenTreeNodesById","asyncDataTreeNode","childAsyncDataTreeNode","asTreeElement","CompressibleAsyncDataTreeNodeWrapper","CompressibleAsyncDataTreeRenderer","compressibleNodeMapperProvider","asCompressibleObjectTreeOptions","els","CompressibleAsyncDataTree","compressionDelegate","compressibleNodeMapper","isIncompressible","getUncompressedIds","oldSelection","oldFocus","didChangeSelection","didChangeFocus","getVisibility","filterResult","DataTree","IListService","ListService","_lastFocusedWidget","_hasCreatedStyleController","setLastFocusedList","extraContextKeys","registeredList","RawWorkbenchListFocusContextKey","WorkbenchListSupportsMultiSelectContextKey","WorkbenchListFocusContextKey","WorkbenchListHasSelectionOrFocus","WorkbenchListDoubleSelection","WorkbenchListMultiSelection","WorkbenchListSelectionNavigation","WorkbenchTreeElementCanCollapse","WorkbenchTreeElementHasParent","WorkbenchTreeElementCanExpand","WorkbenchTreeElementHasChild","WorkbenchListAutomaticKeyboardNavigationKey","createScopedContextKeyService","multiSelectModifierSettingKey","openModeSettingKey","horizontalScrollingKey","keyboardNavigationSettingKey","automaticKeyboardNavigationSettingKey","treeIndentKey","treeRenderIndentGuidesKey","listSmoothScrolling","mouseWheelScrollSensitivityKey","fastScrollSensitivityKey","treeExpandMode","useAltAsMultipleSelectionModifier","MultipleSelectionController","toWorkbenchListOptions","WorkbenchList","workbenchListOptions","workbenchListOptionsDisposable","listSupportsMultiSelect","listSelectionNavigation","listHasSelectionOrFocus","listDoubleSelection","listMultiSelection","_useAltAsMultipleSelectionModifier","ListResourceNavigator","_styler","WorkbenchPagedList","WorkbenchTable","TableResourceNavigator","ResourceNavigator","_onDidOpen","onSelectionFromKeyboard","selectionKeyboardEvent","_open","getSelectedElement","isDoubleClick","isMiddleClick","revealIfVisible","TreeResourceNavigator","createKeyboardNavigationEventFilter","inChord","WorkbenchObjectTree","getAutomaticKeyboardNavigation","workbenchTreeDataPreamble","internals","WorkbenchTreeInternals","WorkbenchCompressibleObjectTree","updateStyleOverrides","WorkbenchDataTree","WorkbenchAsyncDataTree","WorkbenchCompressibleAsyncDataTree","accessibilityOn","keyboardNavigation","hasSelectionOrFocus","hasDoubleSelection","hasMultiSelection","treeElementCanCollapse","treeElementHasParent","treeElementCanExpand","treeElementHasChild","interestingContextKeys","updateKeyboardNavigation","updateCollapseContextKeys","styler","ILogService","LogLevel","DEFAULT_LOG_LEVEL","AbstractLogger","_onDidChangeLogLevel","setLevel","ConsoleLogger","logLevel","LogService","logger","INotificationService","NoOpNotification","IOpenerService","matchesScheme","matchesSomeScheme","schemes","extractSelection","Progress","IEditorProgressService","DefaultQuickAccessFilterValue","Quickaccess","QuickAccessRegistry","defaultProvider","providerA","providerB","getQuickAccessProviders","IQuickInputService","RegistryImpl","as","Registry","StorageState","Storage","_onDidChangeStorage","onDidChangeStorage","flushDelayer","DEFAULT_FLUSH_DELAY","pendingDeletes","pendingInserts","whenFlushedCallbacks","onDidChangeItemsExternal","Closed","valueStr","doFlush","hasPending","flushPending","updateRequest","updateItems","InMemoryStorageDatabase","TARGET_KEY","IStorageService","WillSaveStateReason","AbstractStorageService","flushInterval","DEFAULT_FLUSH_INTERVAL","_onDidChangeValue","_onDidChangeTarget","_onWillSaveState","_workspaceKeyTargets","_globalKeyTargets","emitDidChangeValue","getKeyTargets","getStorage","withPausedEmitters","updateKeyTarget","keyTargets","workspaceKeyTargets","loadKeyTargets","globalKeyTargets","keysRaw","InMemoryStorageService","globalStorage","workspaceStorage","ITelemetryService","asCssVariableName","colorIdent","ColorContribution","ColorRegistry","onDidChangeSchema","colorSchema","colorReferenceSchema","colorsById","registerColor","needsTransparency","colorContribution","propertySchema","defaultSnippets","colorDesc","colorValue","resolveColorValue","getColorSchema","cat1","cat2","colorRegistry","iconForeground","focusBorder","activeContrastBorder","textLinkForeground","textLinkActiveForeground","textCodeBlockBackground","selectBackground","selectForeground","selectBorder","editorErrorBackground","editorErrorForeground","editorErrorBorder","editorWarningBackground","editorWarningForeground","editorWarningBorder","editorInfoBackground","editorInfoForeground","editorInfoBorder","editorHintForeground","editorHintBorder","editorWidgetBackground","editorWidgetForeground","editorWidgetBorder","editorWidgetResizeBorder","editorSelectionBackground","editorSelectionForeground","editorInactiveSelection","editorSelectionHighlight","lessProminent","editorSelectionHighlightBorder","editorFindMatch","editorFindMatchHighlight","editorFindRangeHighlight","editorFindMatchBorder","editorFindMatchHighlightBorder","editorFindRangeHighlightBorder","editorHoverBackground","editorHoverForeground","editorHoverBorder","editorActiveLinkForeground","editorInlayHintForeground","editorInlayHintBackground","editorInlayHintTypeForeground","editorInlayHintTypeBackground","editorInlayHintParameterForeground","editorInlayHintParameterBackground","defaultInsertColor","defaultRemoveColor","diffInserted","diffInsertedLine","diffRemovedLine","diffInsertedLineGutter","diffRemovedLineGutter","diffOverviewRulerInserted","diffOverviewRulerRemoved","diffInsertedOutline","diffRemovedOutline","diffBorder","diffDiagonalFill","listHighlightForeground","listFocusHighlightForeground","ifDefinedThenElse","_deprecatedQuickInputListFocusBackground","quickInputListFocusForeground","quickInputListFocusIconForeground","quickInputListFocusBackground","oneOf","menuBorder","menuForeground","menuBackground","menuSelectionForeground","menuSelectionBackground","menuSelectionBorder","menuSeparatorBackground","toolbarHoverBackground","headerTransparency","currentBaseColor","incomingBaseColor","commonBaseColor","contentTransparency","rulerTransparency","mergeCurrentHeaderBackground","mergeIncomingHeaderBackground","mergeCommonHeaderBackground","mergeBorder","overviewRulerFindMatchForeground","overviewRulerSelectionHighlightForeground","minimapFindMatch","minimapSelectionOccurrenceHighlight","minimapSelection","minimapError","minimapWarning","minimapBackground","minimapForegroundOpacity","minimapSliderBackground","minimapSliderHoverBackground","minimapSliderActiveBackground","executeTransform","if","else","transparency","ifArg","thenArg","elseArg","backgroundColorValue","workbenchColorsSchemaId","schemaRegistry","IconContribution","getDefinition","IconRegistry","iconSchema","definitions","fontId","iconReferenceSchema","iconsById","iconFontsById","registerIcon","enumIndex","iconContribution","getIconSchema","i1","getIconRegistry","iconsSchemaId","widgetClose","styleMap","attachStyler","widgetOrCallback","attachBadgeStyler","attachListStyler","defaultListStyles","defaultMenuStyles","attachMenuStyler","ColorScheme","IThemeService","ThemeColor","ThemeIcon","themeColorFromId","getThemeTypeSelector","isThemeColor","isThemeIcon","_regexFromString","fromId","modify","tildeIndex","getModifier","ti1","ti2","asThemeIcon","ThemingContribution","ThemingRegistry","themingParticipants","onThemingParticipantAddedEmitter","onColorThemeChange","participant","registerThemingParticipant","Themable","onThemeChange","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","IWorkspaceContextService","isSingleFolderWorkspaceIdentifier","singleFolderIdentifier","toWorkspaceIdentifier","WorkspaceFolder","WORKSPACE_EXTENSION","IWorkspaceTrustManagementService","CAPTURE_METADATA","IN_DEBUG_MODE","utils_1","rule_1","matcher_1","debug_1","createGrammar","initialLanguage","embeddedLanguages","grammarRepository","Grammar","_extractIncludedScopesInPatterns","sharpIndex","_extractIncludedScopesInRepository","repository","collectIncludedScopes","scopesAreMatching","thisScopeName","nameMatcher","identifers","collectInjections","ruleFactoryHelper","matchers","createMatchers","ruleId","RuleFactory","getCompiledRuleId","matchers_1","matcher","ScopeMetadata","ScopeMetadataProvider","themeProvider","_initialLanguage","_themeProvider","onDidChangeTheme","escapedScopes","_escapeRegExpCharacters","_embeddedLanguagesRegex","_defaultMetaData","getMetadataForScope","_NULL_SCOPE_METADATA","_doGetMetadataForScope","_scopeToLanguage","_toStandardTokenType","themeMatch","_scopeMetadataProvider","_rootId","_lastRuleId","_ruleId2desc","_includedGrammars","_grammarRepository","_grammar","initGrammar","_tokenTypeMatchers","matchers_2","getInjections","_injections","rawInjections","injections","injectionScopeNames","injectionScopeName","injectionGrammar","getExternalGrammar","injectionSelector","registerRule","getRule","patternId","rawIncludedGrammar","lookup","$base","getResult","tokenizeLine2","getBinaryResult","emitBinaryTokens","$self","rawDefaultMetadata","defaultTheme","StackElementMetadata","rootScopeName","getName","rawRootMetadata","rootMetadata","ScopeListElement","mergeMetadata","scopeList","onigLineText","createOnigString","getString","_tokenizeString","$vscodeTextmateLocation","handleCaptures","captures","captureIndices","localStack","captureRule","captureIndex","produceFromScopes","produce","retokenizeCapturedWithRuleId","nameScopesList","contentNameScopesList","contentName","getContentName","stackClone","captureRuleScopeName","captureRuleScopesList","LocalStackElement","debugCompiledRuleToString","ruleScanner","debugRegExps","matchInjections","linePos","bestMatchRuleId","bestMatchRating","bestMatchCaptureIndices","bestMatchResultPriority","generateScopes","injection","matchResult","scanner","findNextMatchSync","matchRating","priorityMatch","matchedRuleId","matchRule","endRule","matchRuleOrInjections","injectionResult","matchResultScore","injectionResultScore","_checkWhileConditions","whileRules","nodeRule","BeginWhileRule","whileRule","compileWhile","whileCaptures","STOP","whileCheckResult","scanNext","hasAdvanced","poppedRule","debugEndRegExp","setContentNameScopesList","endCaptures","popped","getEnterPos","_rule","beforePush","BeginEndRule","pushedRule","debugBeginRegExp","beginCaptures","endHasBackReferences","setEndRule","getEndWithResolvedBackReferences","hasSameRuleAs","whileHasBackReferences","getWhileWithResolvedBackReferences","matchingRule","debugMatchRegExp","safePop","toBinaryStr","printMetadata","getTokenType","getBackground","_tokenType","_matchesScope","selectorWithDot","_matches","parentScopes","scopesList","rawMetadata","_generateScopes","enterPos","_enterPos","_structuralEquals","_reset","outIndex","tokenTypeOverrides","_emitBinaryTokens","_tokenTypeOverrides","_binaryTokens","_lastTokenEndIndex","toTemporaryType","standardType","plist","json_1","parseJSONGrammar","parsePLISTGrammar","doFail","streamState","withMetadata","JSONStreamState","JSONToken","nextJSONToken","toLocation","keyValue","_out","__generator","sent","trys","registry_1","grammarReader_1","theme_1","grammar_1","DEFAULT_OPTIONS","getGrammarDefinition","locator","_locator","_syncRegistry","SyncRegistry","Theme","createFromRawTheme","installationQueue","loadGrammarWithEmbeddedLanguages","initialScopeName","loadGrammarWithConfiguration","_loadGrammar","grammarForScopeName","dependentScope","prom","grammarDefinition","rawGrammar","addGrammar","scopeNameD","matchesName","newTokenizer","parseConjunction","parseOperand","expressionToNegate","matcherInput","expressionInParents","parseInnerExpression","isIdentifier","_grammars","_rawGrammars","_injectionGrammars","includedScopes","targetScope","__extends","extendStatics","__proto__","__","onigasm_1","HAS_BACK_REFERENCES","BACK_REFERENCING_END","$location","_nameIsCapturing","RegexSource","hasCaptures","_contentName","_contentNameIsCapturing","replaceCaptures","collectPatternsRecursive","endRegexSource","allowA","allowG","CaptureRule","RegExpSource","regExpSource","handleAnchors","_handleAnchors","hasAnchor","_anchorCache","_buildAnchorCache","hasBackReferences","setSource","newSource","nextCh","lastPushedPos","resolveBackReferences","capturedValues","A0_G0_result","A0_G1_result","A1_G0_result","A1_G1_result","A0_G0","A0_G1","A1_G0","A1_G1","resolveAnchors","createOnigScanner","sources","OnigScanner","OnigString","$str","RegExpSourceList","_hasAnchors","_cached","_cachedSources","_resolveAnchors","regExps","MatchRule","_cachedCompiledPatterns","IncludeOnlyRule","hasMissingPatterns","begin","applyEndPatternLast","_begin","_end","precompiled","_precompile","_while","_cachedCompiledWhilePatterns","_precompileWhile","createCaptureRule","_compileCaptures","while","_compilePatterns","mergeObjects","numericCaptureId","maximumCaptureId","captureId","externalGrammar","skipRule","localIncludedRule","externalGrammarName","externalGrammarInclude","externalIncludedRule","ParsedThemeRule","isValidHexColor","parseTheme","_scope","resolveParsedThemeRules","strArrCmp","_defaults","createFromParsedTheme","len1","len2","scopeDepth","cloneArr","rulesWithParentScopes","_rulesWithParentScopes","_sortBySpecificity","_cmpBySpecificity","aParentScopes","bParentScopes","aParentScopesLen","bParentScopesLen","_doInsertHere","doClone","cloneArray","cloneObj","CAPTURING_REGEX_SOURCE","captureSource","commandIndex","OnigScanner_1","OnigRegExp","searchSync","captureIndicesForMatch","testSync","convertToString","onigasmH_1","OnigString_1","mallocAndWriteString","ptr","onigasmH","_malloc","utf8Bytes","HEAPU8","convertUTF8BytesFromPtrToString","regexTPtrsPtr","regexTPtrs","_disposeCompiledPatterns","errMessage","_getLastError","_free","convertToNumber","onigNativeInfo","regexTAddrRecieverPtr","patternStrPtr","_compilePattern","regexTAddress","HEAP32","onigString","strPtr","resultInfoReceiverPtr","_findBestMatch","convertUtf16OffsetToUtf8","bestPatternIdx","encodedResultBeginAddress","encodedResultLength","HEAPU32","encodedResult","captureIdx","hasMultiByteCharacters","convertUtf8OffsetToUtf16","_utf8Bytes","_utf8Indexes","utf8Indexes","utf8Offset","utf8Array","utf8OffsetMap","_mappingTableStartOffset","utf16Offset","utf16OffsetToUtf8","mappingTableStartOffset","createOffsetTable","maxUtf8Len","u8view","ptrHead","codepoint","bytesRequiredToEncode","utf8","loadWASM","OnigRegExp_1","Onigasm","Module","moduleOverrides","readBinary","arguments_","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_SHELL","scriptDirectory","locateFile","readbuffer","scriptArgs","quit","printErr","wasmBinary","wasmMemory","setTempRet0","WebAssembly","wasmTable","abort","getCFunc","ident","ccall","returnType","argTypes","toC","stackAlloc","stringToUTF8","writeArrayToMemory","convertReturnValue","UTF8ToString","cArgs","converter","stackSave","stackRestore","UTF8Decoder","UTF8ArrayToString","u8Array","maxBytesToRead","endPtr","u0","u1","u2","stringToUTF8Array","outU8Array","outIdx","maxBytesToWrite","u","outPtr","HEAP8","WASM_PAGE_SIZE","alignUp","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Float64Array","DYNAMIC_BASE","DYNAMICTOP_PTR","INITIAL_TOTAL_MEMORY","callRuntimeCallbacks","callbacks","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","preRun","addOnPreRun","initRuntime","preMain","postRun","addOnPostRun","runDependencies","runDependencyWatcher","dependenciesFulfilled","addRunDependency","removeRunDependency","RuntimeError","dataURIPrefix","isDataURI","wasmBinaryFile","getBinary","getBinaryPromise","fetch","credentials","createWasm","asmLibraryArg","receiveInstance","receiveInstantiatedSource","instantiateArrayBuffer","receiver","instantiate","instantiateAsync","instantiateStreaming","_abort","_emscripten_get_heap_size","_emscripten_get_sbrk_ptr","_emscripten_memcpy_big","emscripten_realloc_buffer","grow","_emscripten_resize_heap","requestedSize","oldSize","PAGE_MULTIPLE","LIMIT","MIN_TOTAL_MEMORY","replacement","___wasm_call_ctors","SYSCALLS","printChar","varargs","getStr","get64","getZero","_fd_close","fd","FS","ErrnoError","_fd_seek","offset_low","offset_high","whence","_fd_write","iov","iovcnt","pnum","_setTempRet0","$i","asm","calledRun","old","runCaller","OnigasmModuleFactory","initModule","bytes","instantiateWasm","imports","successCallback","moduleH","arrayBuffer","Yallist","MAX","LENGTH","LENGTH_CALCULATOR","ALLOW_STALE","MAX_AGE","DISPOSE","NO_DISPOSE_ON_SET","LRU_LIST","UPDATE_AGE_ON_GET","naiveLength","lc","maxAge","noDisposeOnSet","updateAgeOnGet","mL","allowStale","mA","lengthCalculator","lC","hit","itemCount","rforEach","thisp","walker","forEachStep","toArray","dump","isStale","dumpLru","Entry","expiresAt","prune","doUse","unshiftNode","pushNode","forEachReverse","getReverse","mapReverse","reduceReverse","toArrayReverse","sliceReverse","er","assertPath","normalizeStringPosix","toCode","_makeLong","getVueApp","__vue__","isCodeLensSupportedService","getDocsSection","sectionName","setupMonaco","wasm","fileName","grammars","app","serviceKey","$t","$store","getters","sections","referenceSection","sectionBlocks","isSection","isNotComment","commentBlocks","isComment","lastCommentBlock","themeDark","themeLight","webpackAsyncContext","__webpack_require__"],"sourceRoot":""}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/kiauh/resources/moonraker-telegram-bot.service
14:ExecStart=%ENV%/bin/python $TELEGRAM_BOT_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/kiauh/resources/klipper.service
16:ExecStart=%ENV%/bin/python $KLIPPER_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/kiauh/resources/mjpg-streamer/webcamd.service
14:ExecStart=/usr/local/bin/webcamd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/kiauh/resources/moonraker.service
17:ExecStart=%ENV%/bin/python $MOONRAKER_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/kiauh/scripts/octoprint.sh
272:ExecStart=${octo_env}/venv/bin/octoprint --basedir ${basedir} --config ${config_yaml} --port=${port} serve
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-centos.sh
58:ExecStart=${PYTHONDIR}/bin/python ${SRCDIR}/klippy/klippy.py ${HOME}/printer.cfg -l /var/log/klippy.log
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-debian.sh
65:ExecStart=${PYTHONDIR}/bin/python ${SRCDIR}/klippy/klippy.py ${HOME}/printer.cfg -l ${KLIPPER_LOG}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-ubuntu-22.04.sh
64:ExecStart=${PYTHONDIR}/bin/python ${SRCDIR}/klippy/klippy.py ${HOME}/printer.cfg -l ${KLIPPER_LOG}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-beaglebone.sh
36:KERNEL=="rpmsg_pru30", GROUP="tty", MODE="0660"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-arch.sh
63:ExecStart=${PYTHONDIR}/bin/python ${SRCDIR}/klippy/klippy.py ${HOME}/printer.cfg -l ${KLIPPER_LOG}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/klipper-mcu.service
16:ExecStart=/usr/local/bin/klipper_mcu -r -I ${KLIPPER_HOST_MCU_SERIAL}
17:ExecStop=sh -c 'echo "FORCE_SHUTDOWN" > ${KLIPPER_HOST_MCU_SERIAL}'
18:ExecStop=sleep 1
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/scripts/install-ubuntu-18.04.sh
64:ExecStart=${PYTHONDIR}/bin/python ${SRCDIR}/klippy/klippy.py ${HOME}/printer.cfg -l ${KLIPPER_LOG}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/include/boost/serialization/singleton.hpp
116:    // include this to provoke instantiation at pre-execution time
136:        // construct the instance at pre-execution time.  This would prevent
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/include/boost/spirit/home/qi/nonterminal/error_handler.hpp
91:                  (action == retry || action == fail)> on_exit_type;
128:                                    action == retry || action == fail);
133:                                    action == retry || action == fail);
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/armbian-config/jobs.sh
666:						ExecStart=/sbin/iptables-restore /etc/iptables.ipv4.nat
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/armbian-config/functions-network.sh
64:SUBSYSTEM=="tty", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="15c1", SYMLINK+="ttyWWAN%E{ID_USB_INTERFACE_NUM}"
65:SUBSYSTEM=="net", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="15c1", NAME="lte0"
68:SUBSYSTEM=="tty", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1c25", SYMLINK+="ttyWWAN%E{ID_USB_INTERFACE_NUM}"
69:SUBSYSTEM=="net", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1c25", NAME="umts0"
72:SUBSYSTEM=="tty", ATTRS{idVendor}=="03f0", ATTRS{idProduct}=="251d", SYMLINK+="ttyWWAN%E{ID_USB_INTERFACE_NUM}"
75:SUBSYSTEM=="tty", ATTRS{idVendor}=="03f0", ATTRS{idProduct}=="1e1d", SYMLINK+="ttyWWAN%E{.ID_PORT}"
78:SUBSYSTEM=="tty", ATTRS{idVendor}=="413c", ATTRS{idProduct}=="819b", SYMLINK+="ttyWWAN%E{ID_USB_INTERFACE_NUM}"
81:SUBSYSTEM=="tty", ATTRS{idVendor}=="1e0e", ATTRS{idProduct}=="9001", SYMLINK+="ttyWWAN%E{ID_USB_INTERFACE_NUM}"
82:SUBSYSTEM=="net", ATTRS{idVendor}=="1e0e", ATTRS{idProduct}=="9001", NAME="lte0"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/pexpect/popen_spawn.py
23:                 codec_errors='strict', preexec_fn=None):
42:                      cwd=cwd, preexec_fn=preexec_fn, env=env)
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/pexpect/pty_spawn.py
38:                 ignore_sighup=False, echo=True, preexec_fn=None,
178:        If preexec_fn is given, it will be called in the child process before
204:            self._spawn(command, args, preexec_fn, dimensions)
239:    def _spawn(self, command, args=[], preexec_fn=None, dimensions=None):
285:        kwargs = {'echo': self.echo, 'preexec_fn': preexec_fn}
287:            def preexec_wrapper():
288:                "Set SIGHUP to be ignored, then call the real preexec_fn"
290:                if preexec_fn is not None:
291:                    preexec_fn()
292:            kwargs['preexec_fn'] = preexec_wrapper
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/ptyprocess/ptyprocess.py
180:            cls, argv, cwd=None, env=None, echo=True, preexec_fn=None,
187:        If preexec_fn is supplied, it will be called with no arguments in the
268:            if preexec_fn is not None:
270:                    preexec_fn()
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/debian/debfile.py
117:                            preexec_fn=lambda:
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/orca/speechdispatcherfactory.py
335:            if action == punctuation_settings.PUNCTUATION_INSERT:
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/xdg/Menu.py
337:            if run == 2 and ( menuentry.MatchedInclude == True \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/blueman/main/applet/BluezAgent.py
209:            if action == "confirm":
235:            if action == "always":
238:            if action == "always" or action == "accept":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/blueman/plugins/applet/SerialManager.py
110:                p = Popen(args, preexec_fn=lambda: os.setpgid(0, 0))
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/blueman/plugins/applet/GameControllerWakelock.py
49:        if action == "resume":
55:        elif action == "suspend" and self.wake_lock >= 1:
68:            if action == "suspend":
70:            elif action == "resume":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/blueman/plugins/applet/TransferService.py
51:        if action == "accept":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3/dist-packages/virtualenv.py
629:        help="Download preinstalled packages from PyPI.",
637:        help="Do not download preinstalled packages from PyPI.",
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/aarch64-linux-gnu/perl/5.28.1/CORE/regexp.h
443:/* post-execution: $1 et al are tainted */
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-persistent-storage-tape.rules
5:ACTION=="remove", GOTO="persistent_storage_tape_end"
9:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="8", IMPORT{program}="scsi_id --sg-version=3 --export --whitelisted -d $devnode", \
14:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="8", ENV{ID_SCSI_SERIAL}=="?*", \
17:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="8", IMPORT{builtin}="path_id", \
22:KERNEL=="st*[0-9]|nst*[0-9]", ATTRS{ieee1394_id}=="?*", ENV{ID_SERIAL}="$attr{ieee1394_id}", ENV{ID_BUS}="ieee1394"
23:KERNEL=="st*[0-9]|nst*[0-9]", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="usb", IMPORT{builtin}="usb_id"
24:KERNEL=="st*[0-9]|nst*[0-9]", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="scsi", KERNELS=="[0-9]*:*[0-9]", ENV{.BSG_DEV}="$root/bsg/$id"
25:KERNEL=="st*[0-9]|nst*[0-9]", ENV{ID_SERIAL}!="?*", IMPORT{program}="scsi_id --whitelisted --export --device=$env{.BSG_DEV}", ENV{ID_BUS}="scsi"
26:KERNEL=="st*[0-9]",  ENV{ID_SERIAL}=="?*",      SYMLINK+="tape/by-id/$env{ID_BUS}-$env{ID_SERIAL}"
27:KERNEL=="st*[0-9]",  ENV{ID_SCSI_SERIAL}=="?*", SYMLINK+="tape/by-id/$env{ID_BUS}-$env{ID_SCSI_SERIAL}"
28:KERNEL=="nst*[0-9]", ENV{ID_SERIAL}=="?*",      SYMLINK+="tape/by-id/$env{ID_BUS}-$env{ID_SERIAL}-nst"
29:KERNEL=="nst*[0-9]", ENV{ID_SCSI_SERIAL}=="?*", SYMLINK+="tape/by-id/$env{ID_BUS}-$env{ID_SCSI_SERIAL}-nst"
32:KERNEL=="st*[0-9]|nst*[0-9]", IMPORT{builtin}="path_id"
33:KERNEL=="st*[0-9]", ENV{ID_PATH}=="?*", SYMLINK+="tape/by-path/$env{ID_PATH}"
34:KERNEL=="nst*[0-9]", ENV{ID_PATH}=="?*", SYMLINK+="tape/by-path/$env{ID_PATH}-nst"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-uaccess.rules
10:ACTION=="remove", GOTO="uaccess_end"
14:SUBSYSTEM=="usb", ENV{ID_USB_INTERFACES}=="*:060101:*", TAG+="uaccess"
26:SUBSYSTEM=="block", ENV{ID_CDROM}=="1", TAG+="uaccess"
27:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="4|5", TAG+="uaccess"
30:SUBSYSTEM=="sound", TAG+="uaccess", \
34:SUBSYSTEM=="firewire", ENV{ID_FFADO}=="1", TAG+="uaccess"
37:SUBSYSTEM=="video4linux", TAG+="uaccess"
38:SUBSYSTEM=="dvb", TAG+="uaccess"
41:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x00010*",  TAG+="uaccess"
42:SUBSYSTEM=="firewire", ATTR{units}=="*0x00b09d:0x00010*",  TAG+="uaccess"
44:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x010001*", TAG+="uaccess"
45:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x014001*", TAG+="uaccess"
48:SUBSYSTEM=="drm", KERNEL=="card*", TAG+="uaccess"
51:SUBSYSTEM=="drm", KERNEL=="renderD*", TAG+="uaccess"
54:SUBSYSTEM=="misc", KERNEL=="kvm", TAG+="uaccess"
69:SUBSYSTEM=="input", ENV{ID_INPUT_JOYSTICK}=="?*", TAG+="uaccess"
78:SUBSYSTEM=="usb", ENV{ID_MEDIA_PLAYER}=="?*", TAG+="uaccess"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-sunxi-tools.rules
1:SUBSYSTEM=="usb", ATTR{idVendor}=="1f3a", ATTR{idProduct}=="efe8", GROUP="sunxi-fel"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/80-udisks2.rules
20:SUBSYSTEM=="block", ENV{ID_FS_USAGE}=="raid", ENV{ID_FS_TYPE}=="linux_raid_member", ENV{UDISKS_MD_MEMBER_LEVEL}=="", IMPORT{program}="/bin/sh -c '/sbin/mdadm --examine --export $tempnode | /bin/sed s/^MD_/UDISKS_MD_MEMBER_/g'"
22:SUBSYSTEM=="block", KERNEL=="md*", ENV{DEVTYPE}!="partition", IMPORT{program}="/bin/sh -c '/sbin/mdadm --detail --export $tempnode | /bin/sed s/^MD_/UDISKS_MD_/g'"
31:KERNEL=="fd*", ENV{ID_DRIVE_FLOPPY}="1"
43:KERNEL=="mmcblk[0-9]", SUBSYSTEMS=="mmc", ENV{DEVTYPE}=="disk", ENV{ID_DRIVE_FLASH_SD}="1", ENV{ID_DRIVE_MEDIA_FLASH_SD}="1"
45:KERNEL=="msblk[0-9]|mspblk[0-9]", SUBSYSTEMS=="memstick", ENV{DEVTYPE}=="disk", ENV{ID_DRIVE_FLASH_MS}="1", ENV{ID_DRIVE_MEDIA_FLASH_MS}="1"
71:DRIVERS=="rts_pstor", ENV{ID_DRIVE_FLASH_SD}="1"
72:DRIVERS=="rts5229", ENV{ID_DRIVE_FLASH_SD}="1"
151:KERNEL=="sr*", ENV{ID_VENDOR}=="SanDisk", ENV{ID_MODEL}=="Cruzer", ENV{ID_FS_LABEL}=="U3_System", ENV{UDISKS_IGNORE}="1"
154:KERNEL=="sr*", ENV{ID_VENDOR}=="ASMT",ENV{ID_MODEL}=="VirtualCDROM", ENV{ID_FS_LABEL}=="ASUS_+Speed_ZENDISK*", ENV{UDISKS_IGNORE}="1"
157:KERNEL=="sr*", ENV{ID_VENDOR}=="Linux", ENV{ID_MODEL}=="File-CD_Gadget*", ENV{ID_FS_LABEL}=="CDROM*", ATTRS{manufacturer}=="HMD Global", ENV{UDISKS_IGNORE}="1"
172:KERNEL=="zram[0-9]", ENV{SYSTEMD_WANTS}="zram-setup@zram%n.service", TAG+="systemd"
175:KERNEL=="ram*", ENV{UDISKS_IGNORE}="1"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-persistent-alsa.rules
3:ACTION=="remove", GOTO="persistent_alsa_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-usbmount.rules
1:# KERNEL=="sd[a-z]", NAME="%k", SYMLINK+="%k", GROUP="users"
3:# ACTION=="add", KERNEL=="sd[a-z][0-9]", SYMLINK+="%k", GROUP="users", NAME="%k"
5:# ACTION=="add", KERNEL=="sd[a-z][0-9]", RUN+="/bin/mkdir -p /home/mks/gcode_files/%k"
7:# ACTION=="add", KERNEL=="sd[a-z][0-9]", RUN+="/bin/systemd-mount --no-block --collect /dev/%k /home/mks/gcode_files/%k"
9:# ACTION=="remove", KERNEL=="sd[a-z][0-9]", RUN+="/bin/systemd-umount /home/mks/gcode_files/%k"
11:# ACTION=="remove", KERNEL=="sd[a-z][0-9]", RUN+="/bin/rm -rf /home/mks/gcode_files/%k"
14:KERNEL=="sd[a-z]*", ACTION=="add",  	RUN+="/usr/bin/systemctl --no-block restart makerbase-automount@%k.service"
17:KERNEL=="sd[a-z]*", ACTION=="remove",	RUN+="/usr/bin/systemctl --no-block restart makerbase-automount@%k.service"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-evdev.rules
3:ACTION=="remove", GOTO="evdev_end"
11:DRIVERS=="atkbd", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/99-systemd.rules
10:ACTION=="remove", GOTO="systemd_end"
12:SUBSYSTEM=="tty", KERNEL=="tty[a-zA-Z]*|hvc*|xvc*|hvsi*|ttysclp*|sclp_line*|3270/tty[0-9]*", TAG+="systemd"
13:KERNEL=="vport*", TAG+="systemd"
15:SUBSYSTEM=="ubi", TAG+="systemd"
17:SUBSYSTEM=="block", TAG+="systemd"
18:SUBSYSTEM=="block", ACTION=="add", ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}=="1", ENV{SYSTEMD_READY}="0"
22:SUBSYSTEM=="block", ENV{DM_UUID}=="CRYPT-*", ENV{ID_PART_TABLE_TYPE}=="", ENV{ID_FS_USAGE}=="", ENV{SYSTEMD_READY}="0"
25:SUBSYSTEM=="block", ENV{ID_PART_GPT_AUTO_ROOT}=="1", ENV{ID_FS_TYPE}!="crypto_LUKS", SYMLINK+="gpt-auto-root"
26:SUBSYSTEM=="block", ENV{ID_PART_GPT_AUTO_ROOT}=="1", ENV{ID_FS_TYPE}=="crypto_LUKS", SYMLINK+="gpt-auto-root-luks"
27:SUBSYSTEM=="block", ENV{DM_UUID}=="CRYPT-*", ENV{DM_NAME}=="root", SYMLINK+="gpt-auto-root"
30:SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="md*", TEST!="md/array_state", ENV{SYSTEMD_READY}="0"
31:SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="md*", ATTR{md/array_state}=="|clear|inactive", ENV{SYSTEMD_READY}="0"
34:SUBSYSTEM=="block", KERNEL=="loop[0-9]*", ENV{DEVTYPE}=="disk", TEST!="loop/backing_file", ENV{SYSTEMD_READY}="0"
37:SUBSYSTEM=="block", KERNEL=="nbd*", ENV{DEVTYPE}=="disk", TEST!="pid", ENV{SYSTEMD_READY}="0"
48:SUBSYSTEM=="net", KERNEL!="lo", TAG+="systemd", ENV{SYSTEMD_ALIAS}+="/sys/subsystem/net/devices/$name"
49:SUBSYSTEM=="bluetooth", TAG+="systemd", ENV{SYSTEMD_ALIAS}+="/sys/subsystem/bluetooth/devices/%k"
51:SUBSYSTEM=="bluetooth", TAG+="systemd", ENV{SYSTEMD_WANTS}+="bluetooth.target"
53:SUBSYSTEM=="sound", KERNEL=="card*", TAG+="systemd", ENV{SYSTEMD_WANTS}+="sound.target"
55:SUBSYSTEM=="printer", TAG+="systemd", ENV{SYSTEMD_WANTS}+="printer.target"
56:SUBSYSTEM=="usb", KERNEL=="lp*", TAG+="systemd", ENV{SYSTEMD_WANTS}+="printer.target"
57:SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{ID_USB_INTERFACES}=="*:0701??:*", TAG+="systemd", ENV{SYSTEMD_WANTS}+="printer.target"
60:ACTION=="add", SUBSYSTEM=="net", KERNEL!="lo", RUN+="/lib/systemd/systemd-sysctl --prefix=/net/ipv4/conf/$name --prefix=/net/ipv4/neigh/$name --prefix=/net/ipv6/conf/$name --prefix=/net/ipv6/neigh/$name"
64:SUBSYSTEM=="backlight", TAG+="systemd", IMPORT{builtin}="path_id", ENV{SYSTEMD_WANTS}+="systemd-backlight@backlight:$name.service"
65:SUBSYSTEM=="leds", KERNEL=="*kbd_backlight", TAG+="systemd", IMPORT{builtin}="path_id", ENV{SYSTEMD_WANTS}+="systemd-backlight@leds:$name.service"
68:SUBSYSTEM=="rfkill", ENV{SYSTEMD_RFKILL}="1"
69:SUBSYSTEM=="rfkill", IMPORT{builtin}="path_id"
70:SUBSYSTEM=="misc", KERNEL=="rfkill", TAG+="systemd", ENV{SYSTEMD_WANTS}+="systemd-rfkill.socket"
73:SUBSYSTEM=="module", KERNEL=="fuse", TAG+="systemd", ENV{SYSTEMD_WANTS}+="sys-fs-fuse-connections.mount"
74:SUBSYSTEM=="module", KERNEL=="configfs", TAG+="systemd", ENV{SYSTEMD_WANTS}+="sys-kernel-config.mount"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-mouse.rules
3:ACTION=="remove", GOTO="mouse_end"
14:DRIVERS=="psmouse", SUBSYSTEMS=="serio", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/64-btrfs.rules
4:ACTION=="remove", GOTO="btrfs_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/85-hwclock.rules
4:KERNEL=="rtc0", RUN+="/lib/udev/hwclock-set $root/$name"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-inputattach.rules
2:SUBSYSTEM=="tty", KERNEL=="ttyS[0-9]*", ATTRS{id}=="FUJ02e5", ACTION=="add|change", RUN+="/usr/bin/inputattach --daemon --baud 19200 --w8001 /dev/%k"
3:SUBSYSTEM=="tty", KERNEL=="ttyS[0-9]*", ATTRS{id}=="WACf00c", ACTION=="add|change", RUN+="/usr/bin/inputattach --daemon --baud 38400 --w8001 /dev/%k"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/71-seat.rules
10:ACTION=="remove", GOTO="seat_end"
13:SUBSYSTEM=="sound", KERNEL=="card*", TAG+="seat"
14:SUBSYSTEM=="input", KERNEL=="input*", TAG+="seat"
15:SUBSYSTEM=="graphics", KERNEL=="fb[0-9]*", TAG+="seat"
16:SUBSYSTEM=="drm", KERNEL=="card[0-9]*", TAG+="seat", TAG+="master-of-seat"
17:SUBSYSTEM=="usb", ATTR{bDeviceClass}=="09", TAG+="seat"
20:SUBSYSTEM=="usb", ATTR{idVendor}=="2230", ATTR{idProduct}=="000[13]", ENV{ID_AUTOSEAT}="1"
25:SUBSYSTEM=="pci", ATTR{vendor}=="0x1b36", ATTR{device}=="0x000a", TAG+="seat", ENV{ID_AUTOSEAT}="1"
36:SUBSYSTEM=="usb", ATTR{idVendor}=="058f", ATTR{idProduct}=="6254", \
41:SUBSYSTEM=="usb", ATTR{idVendor}=="17e9", ATTR{idProduct}=="401a", ATTR{product}=="mimo inc", \
46:SUBSYSTEM=="usb", ATTR{idVendor}=="17e9", ATTR{idProduct}=="401a", ATTR{product}=="mimo inc", \
54:SUBSYSTEM=="input", ATTR{name}=="Wiebetech LLC Wiebetech", RUN+="/bin/loginctl lock-sessions"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/90-console-setup.rules
1:ACTION=="add", SUBSYSTEM=="vtconsole", KERNEL=="vtcon*", RUN+="/etc/console-setup/cached_setup_font.sh"
3:ACTION=="add", SUBSYSTEM=="vc", KERNEL=="vcs[1-9]|vcs[1-9][0-9]", TEST=="/run/console-setup/font-loaded", RUN+="/etc/console-setup/cached_setup_terminal.sh %k"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-sensor.rules
3:ACTION=="remove", GOTO="sensor_end"
6:SUBSYSTEM=="iio", KERNEL=="iio*", SUBSYSTEMS=="usb|i2c", \
10:SUBSYSTEM=="input", ENV{ID_INPUT_ACCELEROMETER}=="1", SUBSYSTEMS=="acpi", \
14:SUBSYSTEM=="input", ENV{ID_INPUT_ACCELEROMETER}=="1", SUBSYSTEMS=="platform", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/73-seat-late.rules
10:ACTION=="remove", GOTO="seat_late_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/50-udev-default.rules
4:ACTION=="remove", ENV{REMOVE_CMD}!="", RUN+="$env{REMOVE_CMD}"
5:ACTION=="remove", GOTO="default_end"
7:SUBSYSTEM=="virtio-ports", KERNEL=="vport*", ATTR{name}=="?*", SYMLINK+="virtio-ports/$attr{name}"
10:SUBSYSTEM=="rtc", ATTR{hctosys}=="1", SYMLINK+="rtc"
11:SUBSYSTEM=="rtc", KERNEL=="rtc0", SYMLINK+="rtc", OPTIONS+="link_priority=-100"
13:SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", IMPORT{builtin}="usb_id", IMPORT{builtin}="hwdb --subsystem=usb"
18:SUBSYSTEM=="tty", KERNEL=="ptmx", GROUP="tty", MODE="0666"
19:SUBSYSTEM=="tty", KERNEL=="tty", GROUP="tty", MODE="0666"
20:SUBSYSTEM=="tty", KERNEL=="tty[0-9]*", GROUP="tty", MODE="0620"
21:SUBSYSTEM=="tty", KERNEL=="sclp_line[0-9]*", GROUP="tty", MODE="0620"
22:SUBSYSTEM=="tty", KERNEL=="ttysclp[0-9]*", GROUP="tty", MODE="0620"
23:SUBSYSTEM=="tty", KERNEL=="3270/tty[0-9]*", GROUP="tty", MODE="0620"
24:SUBSYSTEM=="vc", KERNEL=="vcs*|vcsa*", GROUP="tty"
25:KERNEL=="tty[A-Z]*[0-9]|ttymxc[0-9]*|pppox[0-9]*|ircomm[0-9]*|noz[0-9]*|rfcomm[0-9]*", GROUP="dialout"
27:SUBSYSTEM=="mem", KERNEL=="mem|kmem|port", GROUP="kmem", MODE="0640"
29:SUBSYSTEM=="input", GROUP="input"
30:SUBSYSTEM=="input", KERNEL=="js[0-9]*", MODE="0664"
32:SUBSYSTEM=="video4linux", GROUP="video"
33:SUBSYSTEM=="graphics", GROUP="video"
34:SUBSYSTEM=="drm", KERNEL!="renderD*", GROUP="video"
35:SUBSYSTEM=="dvb", GROUP="video"
36:SUBSYSTEM=="media", GROUP="video"
37:SUBSYSTEM=="cec", GROUP="video"
39:SUBSYSTEM=="drm", KERNEL=="renderD*", GROUP="render", MODE="0660"
40:SUBSYSTEM=="kfd", GROUP="render", MODE="0660"
42:SUBSYSTEM=="sound", GROUP="audio", \
45:SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", MODE="0664"
47:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x00010*", GROUP="video"
48:SUBSYSTEM=="firewire", ATTR{units}=="*0x00b09d:0x00010*", GROUP="video"
49:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x010001*", GROUP="video"
50:SUBSYSTEM=="firewire", ATTR{units}=="*0x00a02d:0x014001*", GROUP="video"
52:KERNEL=="parport[0-9]*", GROUP="lp"
53:SUBSYSTEM=="printer", KERNEL=="lp*", GROUP="lp"
54:SUBSYSTEM=="ppdev", GROUP="lp"
55:KERNEL=="lp[0-9]*", GROUP="lp"
56:KERNEL=="irlpt[0-9]*", GROUP="lp"
57:SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ENV{ID_USB_INTERFACES}=="*:0701??:*", GROUP="lp"
59:SUBSYSTEM=="block", GROUP="disk"
60:SUBSYSTEM=="block", KERNEL=="sr[0-9]*", GROUP="cdrom"
61:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="4|5", GROUP="cdrom"
62:KERNEL=="sch[0-9]*", GROUP="cdrom"
63:KERNEL=="pktcdvd[0-9]*", GROUP="cdrom"
64:KERNEL=="pktcdvd", GROUP="cdrom"
66:SUBSYSTEM=="scsi_generic|scsi_tape", SUBSYSTEMS=="scsi", ATTRS{type}=="1|8", GROUP="tape"
67:SUBSYSTEM=="scsi_generic", SUBSYSTEMS=="scsi", ATTRS{type}=="0", GROUP="disk"
68:KERNEL=="qft[0-9]*|nqft[0-9]*|zqft[0-9]*|nzqft[0-9]*|rawqft[0-9]*|nrawqft[0-9]*", GROUP="disk"
69:KERNEL=="loop-control", GROUP="disk", OPTIONS+="static_node=loop-control"
70:KERNEL=="btrfs-control", GROUP="disk"
71:KERNEL=="rawctl", GROUP="disk"
72:SUBSYSTEM=="raw", KERNEL=="raw[0-9]*", GROUP="disk"
73:SUBSYSTEM=="aoe", GROUP="disk", MODE="0220"
74:SUBSYSTEM=="aoe", KERNEL=="err", MODE="0440"
76:KERNEL=="rfkill", MODE="0664"
77:KERNEL=="tun", MODE="0666", OPTIONS+="static_node=net/tun"
79:KERNEL=="fuse", MODE="0666", OPTIONS+="static_node=fuse"
82:KERNEL=="kvm", GROUP="kvm", MODE="0660", OPTIONS+="static_node=kvm"
84:SUBSYSTEM=="ptp", ATTR{clock_name}=="KVM virtual PTP", SYMLINK += "ptp_kvm"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-persistent-v4l.rules
3:ACTION=="remove", GOTO="persistent_v4l_end"
10:KERNEL=="video*", ENV{ID_SERIAL}=="?*", SYMLINK+="v4l/by-id/$env{ID_BUS}-$env{ID_SERIAL}-video-index$attr{index}"
17:ENV{ID_PATH}=="?*", KERNEL=="video*|vbi*", SYMLINK+="v4l/by-path/$env{ID_PATH}-video-index$attr{index}"
18:ENV{ID_PATH}=="?*", KERNEL=="audio*", SYMLINK+="v4l/by-path/$env{ID_PATH}-audio-index$attr{index}"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-avrdude.rules
7:SUBSYSTEMS=="usb", DRIVERS=="cdc_acm", TAG+="uaccess"
12:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2103", TAG+="uaccess"
14:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2104", TAG+="uaccess"
16:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2106", TAG+="uaccess"
18:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2107", TAG+="uaccess"
20:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2110", TAG+="uaccess"
22:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2111", TAG+="uaccess"
24:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2140", TAG+="uaccess"
26:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2141", TAG+="uaccess"
28:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2144", TAG+="uaccess"
30:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2145", TAG+="uaccess"
32:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fd6", TAG+="uaccess"
34:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fd7", TAG+="uaccess"
36:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fda", TAG+="uaccess"
38:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fdb", TAG+="uaccess"
40:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fde", TAG+="uaccess"
42:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fdf", TAG+="uaccess"
44:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe0", TAG+="uaccess"
46:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe1", TAG+="uaccess"
48:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe2", TAG+="uaccess"
50:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe3", TAG+="uaccess"
52:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe4", TAG+="uaccess"
54:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe5", TAG+="uaccess"
56:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe6", TAG+="uaccess"
58:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe7", TAG+="uaccess"
60:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fe8", TAG+="uaccess"
62:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fea", TAG+="uaccess"
64:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fec", TAG+="uaccess"
66:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fed", TAG+="uaccess"
68:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fee", TAG+="uaccess"
70:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fef", TAG+="uaccess"
72:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff0", TAG+="uaccess"
74:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff1", TAG+="uaccess"
76:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff3", TAG+="uaccess"
78:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff4", TAG+="uaccess"
80:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff6", TAG+="uaccess"
82:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff7", TAG+="uaccess"
84:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff8", TAG+="uaccess"
86:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ff9", TAG+="uaccess"
88:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ffa", TAG+="uaccess"
90:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ffb", TAG+="uaccess"
92:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2ffd", TAG+="uaccess"
94:SUBSYSTEM=="usb", ATTR{idVendor}=="03eb", ATTR{idProduct}=="2fff", TAG+="uaccess"
96:SUBSYSTEM=="usb", ATTR{idVendor}=="04d8", ATTR{idProduct}=="0033", TAG+="uaccess"
98:SUBSYSTEM=="usb", ATTR{idVendor}=="16c0", ATTR{idProduct}=="05dc", TAG+="uaccess"
100:SUBSYSTEM=="usb", ATTR{idVendor}=="16c0", ATTR{idProduct}=="092f", TAG+="uaccess"
102:SUBSYSTEM=="usb", ATTR{idVendor}=="16d0", ATTR{idProduct}=="0ba5", TAG+="uaccess"
104:SUBSYSTEM=="usb", ATTR{idVendor}=="1781", ATTR{idProduct}=="0c9f", TAG+="uaccess"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/75-net-description.rules
3:ACTION=="remove", GOTO="net_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/85-hdparm.rules
1:ACTION=="add", SUBSYSTEM=="block", KERNEL=="[sh]d[a-z]", RUN+="/lib/udev/hdparm"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-drm.rules
3:ACTION!="remove", SUBSYSTEM=="drm", SUBSYSTEMS=="pci|usb|platform", IMPORT{builtin}="path_id"
6:ENV{ID_PATH}=="?*", KERNEL=="card*", SYMLINK+="dri/by-path/$env{ID_PATH}-card"
7:ENV{ID_PATH}=="?*", KERNEL=="controlD*", SYMLINK+="dri/by-path/$env{ID_PATH}-control"
8:ENV{ID_PATH}=="?*", KERNEL=="renderD*", SYMLINK+="dri/by-path/$env{ID_PATH}-render"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-libgphoto2-6.rules
15:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="1908", ATTRS{idProduct}=="1315", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
16:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="1908", ATTRS{idProduct}=="1320", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
17:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="1908", ATTRS{idProduct}=="0102", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
18:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="1908", ATTRS{idProduct}=="3335", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
19:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="0116", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
20:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="0108", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
21:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="0110", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
22:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="010e", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
23:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="0104", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
24:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="04b0", ATTRS{idProduct}=="0401", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
25:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
26:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
27:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
28:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0109", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
29:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
30:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
31:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
32:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
33:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0105", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
34:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0109", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
35:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0109", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
36:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0109", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
37:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="07b4", ATTRS{idProduct}=="0109", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
38:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0130", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
39:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="0070", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
40:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="00a1", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
41:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="006e", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
42:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="0093", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
43:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="0091", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
44:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0164", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
45:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0132", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
46:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="017a", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
47:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0160", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
48:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0102", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
49:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="0148", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
50:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="014a", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
51:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="25fb", ATTRS{idProduct}=="017c", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
52:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="0009", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
53:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0a17", ATTRS{idProduct}=="0007", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
54:KERNEL=="sd[a-z]*", ATTRS{idVendor}=="1403", ATTRS{idProduct}=="0001", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
55:KERNEL=="sg[0-9]*", ATTRS{idVendor}=="0168", ATTRS{idProduct}=="3011", ENV{ID_GPHOTO2}="1", ENV{GPHOTO2_DRIVER}="proprietary", MODE="0664", GROUP="plugdev"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/80-ifupdown.rules
2:KERNEL=="rfkill", MODE="0664", GROUP="netdev"
5:SUBSYSTEM=="net", ACTION=="add|remove", RUN+="ifupdown-hotplug"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/71-axp-power-button.rules
2:ACTION=="remove", GOTO="power_switch_end"
3:SUBSYSTEM=="input", KERNEL=="event*", ATTRS{name}=="axp20x-pek", TAG+="power-switch"
4:SUBSYSTEM=="input", KERNEL=="event*", ATTRS{name}=="axp[12][890]-supplyer", TAG+="power-switch"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-block.rules
4:ACTION=="add", SUBSYSTEM=="module", KERNEL=="block", ATTR{parameters/events_dfl_poll_msecs}=="0", \
8:ACTION=="change", SUBSYSTEM=="scsi", ENV{DEVTYPE}=="scsi_device", TEST=="block", ATTR{block/*/uevent}="change"
11:ACTION!="remove", SUBSYSTEM=="block", KERNEL=="loop*|nvme*|sd*|vd*|xvd*|pmem*|mmcblk*|dasd*", OPTIONS+="watch"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/73-usb-net-by-mac.rules
7:ACTION=="remove", GOTO="usb_net_by_mac_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-cdrom_id.rules
3:ACTION=="remove", GOTO="cdrom_end"
9:KERNEL=="sr[0-9]*", ENV{ID_CDROM}="1"
27:KERNEL=="sr0", SYMLINK+="cdrom", OPTIONS+="link_priority=-100"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/97-hid2hci.rules
3:ACTION=="remove", GOTO="hid2hci_end"
14:KERNEL=="hiddev*", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c70[345abce]|c71[3bc]", \
17:KERNEL=="hidraw*", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c714", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/80-debian-compat.rules
4:SUBSYSTEM=="scsi", ENV{DEVTYPE}=="scsi_device", TEST!="[module/sg]", RUN{builtin}+="kmod load sg"
7:KERNEL=="mISDNtimer", GROUP="dialout"
8:KERNEL=="mwave", GROUP="dialout"
9:KERNEL=="nvram", GROUP="kmem", MODE="0640"
10:KERNEL=="pktcdvd", GROUP="cdrom", MODE="0644"
11:KERNEL=="lirc[0-9]*", GROUP="video"
12:KERNEL=="legousbtower*", MODE="0666"
13:KERNEL=="sonypi", MODE="0666"
14:KERNEL=="mmtimer", MODE="0644"
15:KERNEL=="sgi_*", MODE="0666"
16:KERNEL=="z90crypt", MODE="0666"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/90-alsa-restore.rules
1:ACTION=="add", SUBSYSTEM=="sound", KERNEL=="controlC*", KERNELS!="card*", TEST=="/usr/sbin", TEST=="/usr/share/alsa", GOTO="alsa_restore_go"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/50-firmware.rules
3:SUBSYSTEM=="firmware", ACTION=="add", ATTR{loading}="-1"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/75-probe_mtd.rules
5:KERNEL=="mtd*ro", IMPORT{program}="mtd_probe $devnode"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/56-hpmud.rules
4:SUBSYSTEM=="ppdev", OWNER="root", GROUP="lp", MODE="0664"
5:SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", GOTO="hpmud_usb_rules"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/90-pulseaudio.rules
23:SUBSYSTEMS=="platform", DRIVERS=="thinkpad_acpi", ENV{PULSE_IGNORE}="1"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-input-id.rules
3:ACTION=="remove", GOTO="id_input_end"
5:SUBSYSTEM=="input", ENV{ID_INPUT}=="", IMPORT{builtin}="input_id"
6:SUBSYSTEM=="input", IMPORT{builtin}="hwdb --subsystem=input --lookup-prefix=id-input:modalias:"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-persistent-storage.rules
6:ACTION=="remove", GOTO="persistent_storage_end"
19:KERNEL=="nvme*[0-9]n*[0-9]", ATTR{wwid}=="?*", SYMLINK+="disk/by-id/nvme-$attr{wwid}"
20:KERNEL=="nvme*[0-9]n*[0-9]p*[0-9]", ENV{DEVTYPE}=="partition", ATTRS{wwid}=="?*", SYMLINK+="disk/by-id/nvme-$attr{wwid}-part%n"
22:KERNEL=="nvme*[0-9]n*[0-9]", ENV{DEVTYPE}=="disk", ATTRS{serial}=="?*", ENV{ID_SERIAL_SHORT}="$attr{serial}"
23:KERNEL=="nvme*[0-9]n*[0-9]", ENV{DEVTYPE}=="disk", ATTRS{wwid}=="?*", ENV{ID_WWN}="$attr{wwid}"
24:KERNEL=="nvme*[0-9]n*[0-9]", ENV{DEVTYPE}=="disk", ATTRS{model}=="?*", ENV{ID_MODEL}="$attr{model}"
25:KERNEL=="nvme*[0-9]n*[0-9]", ENV{DEVTYPE}=="disk", ATTRS{firmware_rev}=="?*", ENV{ID_REVISION}="$attr{firmware_rev}"
26:KERNEL=="nvme*[0-9]n*[0-9]", ENV{DEVTYPE}=="disk", ENV{ID_MODEL}=="?*", ENV{ID_SERIAL_SHORT}=="?*", \
29:KERNEL=="nvme*[0-9]n*[0-9]p*[0-9]", ENV{DEVTYPE}=="partition", ATTRS{serial}=="?*", ENV{ID_SERIAL_SHORT}="$attr{serial}"
30:KERNEL=="nvme*[0-9]n*[0-9]p*[0-9]", ENV{DEVTYPE}=="partition", ATTRS{model}=="?*", ENV{ID_MODEL}="$attr{model}"
31:KERNEL=="nvme*[0-9]n*[0-9]p*[0-9]", ENV{DEVTYPE}=="partition", ATTRS{firmware_rev}=="?*", ENV{ID_REVISION}="$attr{firmware_rev}"
32:KERNEL=="nvme*[0-9]n*[0-9]p*[0-9]", ENV{DEVTYPE}=="partition", ENV{ID_MODEL}=="?*", ENV{ID_SERIAL_SHORT}=="?*", \
36:KERNEL=="vd*[!0-9]", ATTRS{serial}=="?*", ENV{ID_SERIAL}="$attr{serial}", SYMLINK+="disk/by-id/virtio-$env{ID_SERIAL}"
37:KERNEL=="vd*[0-9]", ATTRS{serial}=="?*", ENV{ID_SERIAL}="$attr{serial}", SYMLINK+="disk/by-id/virtio-$env{ID_SERIAL}-part%n"
40:KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="scsi", ATTRS{vendor}=="ATA", IMPORT{program}="ata_id --export $devnode"
43:KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="scsi", ATTRS{type}=="5", ATTRS{scsi_level}=="[6-9]*", IMPORT{program}="ata_id --export $devnode"
46:KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", ATTR{removable}=="0", SUBSYSTEMS=="usb", IMPORT{program}="ata_id --export $devnode"
49:KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="usb", IMPORT{builtin}="usb_id"
52:KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", IMPORT{program}="scsi_id --export --whitelisted -d $devnode", ENV{ID_BUS}="scsi"
53:KERNEL=="cciss*", ENV{DEVTYPE}=="disk", ENV{ID_SERIAL}!="?*", IMPORT{program}="scsi_id --export --whitelisted -d $devnode", ENV{ID_BUS}="cciss"
54:KERNEL=="sd*|sr*|cciss*", ENV{DEVTYPE}=="disk", ENV{ID_SERIAL}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_SERIAL}"
55:KERNEL=="sd*|cciss*", ENV{DEVTYPE}=="partition", ENV{ID_SERIAL}=="?*", SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_SERIAL}-part%n"
58:KERNEL=="pmem*", ENV{DEVTYPE}=="disk", ATTRS{uuid}=="?*", SYMLINK+="disk/by-id/pmem-$attr{uuid}"
61:KERNEL=="sd*[!0-9]|sr*", ATTRS{ieee1394_id}=="?*", SYMLINK+="disk/by-id/ieee1394-$attr{ieee1394_id}"
62:KERNEL=="sd*[0-9]", ATTRS{ieee1394_id}=="?*", SYMLINK+="disk/by-id/ieee1394-$attr{ieee1394_id}-part%n"
65:KERNEL=="mmcblk[0-9]", SUBSYSTEMS=="mmc", ATTRS{name}=="?*", ATTRS{serial}=="?*", \
67:KERNEL=="mmcblk[0-9]p[0-9]*", ENV{ID_NAME}=="?*", ENV{ID_SERIAL}=="?*", SYMLINK+="disk/by-id/mmc-$env{ID_NAME}_$env{ID_SERIAL}-part%n"
70:SUBSYSTEM=="ubi", KERNEL=="ubi*_*", ATTRS{mtd_num}=="*", SYMLINK+="ubi_mtd%s{mtd_num}_%s{name}"
73:KERNEL=="msblk[0-9]|mspblk[0-9]", SUBSYSTEMS=="memstick", ATTRS{name}=="?*", ATTRS{serial}=="?*", \
75:KERNEL=="msblk[0-9]p[0-9]|mspblk[0-9]p[0-9]", ENV{ID_NAME}=="?*", ENV{ID_SERIAL}=="?*", SYMLINK+="disk/by-id/memstick-$env{ID_NAME}_$env{ID_SERIAL}-part%n"
79:KERNEL=="mmcblk[0-9]boot[0-9]", ENV{DEVTYPE}=="disk", ENV{ID_PATH}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-boot%n"
84:KERNEL=="vd*[!0-9]", ENV{ID_PATH}=="pci-*", SYMLINK+="disk/by-path/virtio-$env{ID_PATH}"
85:KERNEL=="vd*[0-9]", ENV{ID_PATH}=="pci-*", SYMLINK+="disk/by-path/virtio-$env{ID_PATH}-part%n"
88:KERNEL=="sr*", ENV{DISK_EJECT_REQUEST}!="?*", ENV{ID_CDROM_MEDIA_TRACK_COUNT_DATA}=="?*", ENV{ID_CDROM_MEDIA_SESSION_LAST_OFFSET}=="?*", \
91:KERNEL=="sr*", ENV{DISK_EJECT_REQUEST}!="?*", ENV{ID_CDROM_MEDIA_TRACK_COUNT_DATA}=="?*", ENV{ID_CDROM_MEDIA_SESSION_LAST_OFFSET}=="", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/40-usb_modeswitch.rules
10:KERNEL=="ttyUSB*", ATTRS{bNumConfigurations}=="*", PROGRAM="usb_modeswitch --symlink-name %p %s{idVendor} %s{idProduct} %E{PRODUCT}", SYMLINK+="%c"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-touchpad.rules
3:ACTION=="remove", GOTO="touchpad_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/69-libmtp.rules
6:SUBSYSTEM=="usb", GOTO="libmtp_usb_rules"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-i2c-tools.rules
1:SUBSYSTEM=="i2c-dev",KERNEL=="i2c-[0-9]*", GROUP="i2c", MODE="0660"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-power-switch.rules
10:ACTION=="remove", GOTO="power_switch_end"
12:SUBSYSTEM=="input", KERNEL=="event*", ENV{ID_INPUT_SWITCH}=="1", TAG+="power-switch"
13:SUBSYSTEM=="input", KERNEL=="event*", ENV{ID_INPUT_KEY}=="1", TAG+="power-switch"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-bridge-network-interface.rules
1:ACTION=="add", SUBSYSTEM=="net", RUN+="bridge-network-interface"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-u2f.rules
20:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0113|0114|0115|0116|0120|0200|0402|0403|0406|0407|0410", TAG+="uaccess", GROUP="plugdev", MODE="0660"
23:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="2581", ATTRS{idProduct}=="f1d0", TAG+="uaccess", GROUP="plugdev", MODE="0660"
26:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="1e0d", ATTRS{idProduct}=="f1d0|f1ae", TAG+="uaccess", GROUP="plugdev", MODE="0660"
29:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="096e|2ccf", ATTRS{idProduct}=="0880", TAG+="uaccess", GROUP="plugdev", MODE="0660"
32:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="096e", ATTRS{idProduct}=="0850|0852|0853|0854|0856|0858|085a|085b|085d", TAG+="uaccess", GROUP="plugdev", MODE="0660"
35:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="24dc", ATTRS{idProduct}=="0101|0501", TAG+="uaccess", GROUP="plugdev", MODE="0660"
38:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="8acf", TAG+="uaccess", GROUP="plugdev", MODE="0660"
41:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="1a44", ATTRS{idProduct}=="00bb", TAG+="uaccess", GROUP="plugdev", MODE="0660"
44:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="2abe", ATTRS{idProduct}=="1002", TAG+="uaccess", GROUP="plugdev", MODE="0660"
47:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="1ea8", ATTRS{idProduct}=="f025", TAG+="uaccess", GROUP="plugdev", MODE="0660"
50:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="20a0", ATTRS{idProduct}=="4287", TAG+="uaccess", GROUP="plugdev", MODE="0660"
53:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="5026", TAG+="uaccess", GROUP="plugdev", MODE="0660"
56:KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="cdab", TAG+="uaccess", GROUP="plugdev", MODE="0660"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/73-special-net-names.rules
3:ACTION=="add", SUBSYSTEM=="net", SUBSYSTEMS=="usb", ATTRS{idVendor}=="413c", ATTRS{idProduct}=="a102", NAME="idrac"
7:ACTION=="add", SUBSYSTEM=="net", SUBSYSTEMS=="usb", \
14:ACTION=="add", SUBSYSTEM=="net", NAME=="", DRIVERS=="ibmveth", PROGRAM="/bin/sh -ec 'D=${DEVPATH#*/vio/}; D=${D%%%%/*}; D=${D#????}; D=${D#0}; D=${D#0}; D=${D#0}; D=${D#0}; echo ${D:-0}'", NAME="ibmveth$result"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-joystick.rules
3:ACTION=="remove", GOTO="joystick_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/78-sound-card.rules
5:ACTION=="add|change", KERNEL=="controlC*", ATTR{../uevent}="change"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/80-drivers.rules
6:SUBSYSTEM=="tifm", ENV{TIFM_CARD_TYPE}=="SD", RUN{builtin}+="kmod load tifm_sd"
7:SUBSYSTEM=="tifm", ENV{TIFM_CARD_TYPE}=="MS", RUN{builtin}+="kmod load tifm_ms"
8:SUBSYSTEM=="memstick", RUN{builtin}+="kmod load ms_block mspro_block"
9:SUBSYSTEM=="i2o", RUN{builtin}+="kmod load i2o_block"
10:SUBSYSTEM=="module", KERNEL=="parport_pc", RUN{builtin}+="kmod load ppdev"
11:KERNEL=="mtd*ro", ENV{MTD_FTL}=="smartmedia", RUN{builtin}+="kmod load sm_ftl"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/55-dm.rules
31:KERNEL=="device-mapper", NAME="mapper/control"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-persistent-input.rules
3:ACTION=="remove", GOTO="persistent_input_end"
19:DRIVERS=="pcspkr", ENV{.INPUT_CLASS}="spkr"
26:KERNEL=="mouse*|js*", ENV{ID_BUS}=="?*", ENV{.INPUT_CLASS}=="?*", ATTRS{bInterfaceNumber}=="|00", SYMLINK+="input/by-id/$env{ID_BUS}-$env{ID_SERIAL}-$env{.INPUT_CLASS}"
27:KERNEL=="mouse*|js*", ENV{ID_BUS}=="?*", ENV{.INPUT_CLASS}=="?*", ATTRS{bInterfaceNumber}=="?*", ATTRS{bInterfaceNumber}!="00", SYMLINK+="input/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$attr{bInterfaceNumber}-$env{.INPUT_CLASS}"
28:KERNEL=="event*", ENV{ID_BUS}=="?*", ENV{.INPUT_CLASS}=="?*", ATTRS{bInterfaceNumber}=="|00", SYMLINK+="input/by-id/$env{ID_BUS}-$env{ID_SERIAL}-event-$env{.INPUT_CLASS}"
29:KERNEL=="event*", ENV{ID_BUS}=="?*", ENV{.INPUT_CLASS}=="?*", ATTRS{bInterfaceNumber}=="?*", ATTRS{bInterfaceNumber}!="00", SYMLINK+="input/by-id/$env{ID_BUS}-$env{ID_SERIAL}-if$attr{bInterfaceNumber}-event-$env{.INPUT_CLASS}"
31:SUBSYSTEMS=="usb", ENV{ID_BUS}=="?*", KERNEL=="event*", ENV{.INPUT_CLASS}=="", ATTRS{bInterfaceNumber}=="?*", \
36:ENV{ID_PATH}=="?*", KERNEL=="mouse*|js*", ENV{.INPUT_CLASS}=="?*", SYMLINK+="input/by-path/$env{ID_PATH}-$env{.INPUT_CLASS}"
37:ENV{ID_PATH}=="?*", KERNEL=="event*", ENV{.INPUT_CLASS}=="?*", SYMLINK+="input/by-path/$env{ID_PATH}-event-$env{.INPUT_CLASS}"
39:SUBSYSTEMS=="usb|platform", ENV{ID_PATH}=="?*", KERNEL=="event*", ENV{.INPUT_CLASS}=="", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-dfu-util.rules
4:ACTION=="add", SUBSYSTEM=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="df11", MODE="664", GROUP="plugdev"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/60-serial.rules
3:ACTION=="remove", GOTO="serial_end"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/udev/rules.d/70-spice-vdagentd.rules
1:ACTION=="add", SUBSYSTEM=="virtio-ports", ENV{DEVLINKS}=="/dev/virtio-ports/com.redhat.spice.0", ENV{SYSTEMD_WANTS}="spice-vdagentd.socket"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-time-wait-sync.service
31:ExecStart=/lib/systemd/systemd-time-wait-sync
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/pppd-dns.service
6:ExecStart=/etc/ppp/ip-down.d/0000usepeerdns
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/udisks2.service
8:ExecStart=/usr/lib/udisks2/udisksd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/fstrim.service
7:ExecStart=/sbin/fstrim -Av
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/alsa-restore.service
16:ExecStart=-/usr/sbin/alsactl -E HOME=/run/alsa restore
17:ExecStop=-/usr/sbin/alsactl -E HOME=/run/alsa store
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-backlight@.service
21:ExecStart=/lib/systemd/systemd-backlight load %i
22:ExecStop=/lib/systemd/systemd-backlight save %i
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/initrd-cleanup.service
20:ExecStart=/bin/systemctl --no-block isolate initrd-switch-root.target
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ssh.service
9:ExecStartPre=/usr/sbin/sshd -t
10:ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
11:ExecReload=/usr/sbin/sshd -t
12:ExecReload=/bin/kill -HUP $MAINPID
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-random-seed.service
23:ExecStart=/lib/systemd/systemd-random-seed load
24:ExecStop=/lib/systemd/systemd-random-seed save
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/netplan-wpa@.service
10:ExecStart=/sbin/wpa_supplicant -c /run/netplan/wpa-%I.conf -i%I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/serial-getty@.service
34:ExecStart=-/sbin/agetty -o '-p -- \\u' --keep-baud 115200,38400,9600 %I $TERM
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-ramlog.service
16:ExecStart=/usr/lib/armbian/armbian-ramlog start
17:ExecStop=/usr/lib/armbian/armbian-ramlog stop
18:ExecReload=/usr/lib/armbian/armbian-ramlog write
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-automount@.service
4:ExecStart=/usr/bin/makerbase-automount %I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-hardware-optimize.service
13:ExecStart=/usr/lib/armbian/armbian-hardware-optimization start
14:ExecStop=/usr/lib/armbian/armbian-hardware-optimization stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-hibernate-resume@.service
22:ExecStart=/lib/systemd/systemd-hibernate-resume %f
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-logind.service
26:ExecStart=/lib/systemd/systemd-logind
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-udev-settle.service
27:ExecStart=/bin/udevadm settle
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/rsyslog.service
9:ExecStart=/usr/sbin/rsyslogd -n -iNONE
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/rc-local.service
20:ExecStart=/etc/rc.local start
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/smartd.service
7:ExecStart=/usr/sbin/smartd -n $smartd_opts
8:ExecReload=/bin/kill -HUP $MAINPID
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/packagekit.service
12:ExecStart=/usr/lib/packagekit/packagekitd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ifup@.service
14:ExecStart=/bin/sh -ec 'ifup --allow=hotplug %I; ifquery --state %I'
15:ExecStop=/sbin/ifdown %I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-networkd-wait-online.service
21:ExecStart=/lib/systemd/systemd-networkd-wait-online
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/apt-daily.service
9:ExecStartPre=-/usr/lib/apt/apt-helper wait-online
10:ExecStart=/usr/lib/apt/apt.systemd.daily update
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-rfkill.service
20:ExecStart=/lib/systemd/systemd-rfkill
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-suspend-then-hibernate.service
19:ExecStart=/lib/systemd/systemd-sleep suspend-then-hibernate
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-resize-filesystem.service
14:ExecStart=/usr/lib/armbian/armbian-resize-filesystem start
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-suspend.service
19:ExecStart=/lib/systemd/systemd-sleep suspend
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/zram-setup@.service
11:ExecStart=-/bin/sh -c 'echo $ZRAM_NUM_STR > /sys/class/block/%i/max_comp_streams'
12:ExecStart=-/bin/sh -c 'echo $ZRAM_DEV_SIZE > /sys/class/block/%i/disksize'
13:ExecStart=-/bin/sh -c '[ "$SWAP" = "y" ] && mkswap /dev/%i && swapon /dev/%i'
14:ExecStop=-/bin/sh -c 'echo 1 > /sys/class/block/%i/reset'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-binfmt.service
29:ExecStart=/lib/systemd/systemd-binfmt
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-disable-autologin.service
6:ExecStart=rm -f /etc/lightdm/lightdm.conf.d/22-armbian-autologin.conf
8:ExecStop=systemctl disable armbian-disable-autologin.timer
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/console-setup.service
10:ExecStart=/lib/console-setup/console-setup.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/apt-daily-upgrade.service
9:ExecStartPre=-/usr/lib/apt/apt-helper wait-online
10:ExecStart=/usr/lib/apt/apt.systemd.daily install
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/serial-getty@ttyS2.service
34:ExecStart=-/sbin/agetty -o '-p -- \\u' --keep-baud 1500000,115200,38400,9600 %I $TERM
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/resolvconf.service
9:ExecStartPre=/bin/mkdir -p /run/resolvconf/interface
10:ExecStartPre=/bin/touch /run/resolvconf/postponed-update
11:ExecStart=/sbin/resolvconf --enable-updates
12:ExecStop=/sbin/resolvconf --disable-updates
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/getty@.service
39:ExecStart=-/sbin/agetty -o '-p -- \\u' --noclear %I $TERM
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-wlan0.service
9:ExecStart=/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-wlan0.conf -Dnl80211,wext -iwlan0
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-udev-trigger.service
22:ExecStart=/bin/udevadm trigger --type=subsystems --action=add
23:ExecStart=/bin/udevadm trigger --type=devices --action=add
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-fsckd.service
16:ExecStart=/lib/systemd/systemd-fsckd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/unattended-upgrades.service
8:ExecStart=/usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/bootsplash-ask-password-console.service
13:ExecStartPre=-/bin/sh -c '/bin/cat /sys/devices/platform/bootsplash.0/enabled > /run/systemd/ask-password/bootsplash-state ; exec /bin/echo off > /sys/devices/platform/bootsplash.0/enabled'
14:ExecStart=/usr/bin/systemd-tty-ask-password-agent --query --console
15:ExecStartPost=-/bin/sh -c 'exec /bin/cat /run/systemd/ask-password/bootsplash-state > /sys/devices/platform/bootsplash.0/enabled ; /bin/rm /run/systemd/ask-password/bootsplash-state'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-volatile-root.service
22:ExecStart=/lib/systemd/systemd-volatile-root yes /sysroot
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-tmpfiles-clean.service
20:ExecStart=/bin/systemd-tmpfiles --clean
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-resolved.service.d/resolvconf.conf
7:ExecStartPost=+/bin/sh -c '[ ! -e /run/resolvconf/enable-updates ] || echo "nameserver 127.0.0.53" | /sbin/resolvconf -a systemd-resolved'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/speech-dispatcherd.service
23:ExecStart=/usr/bin/speech-dispatcher -d --pid-file /var/run/speech-dispatcher/speech-dispatcher.pid
24:ExecReload=/bin/kill -HUP $MAINPID
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/nginx.service
4:# ExecStop sends SIGSTOP (graceful stop) to the nginx process.
21:ExecStartPre=/usr/sbin/nginx -t -q -g 'daemon on; master_process on;'
22:ExecStart=/usr/sbin/nginx -g 'daemon on; master_process on;'
23:ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload
24:ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/bootsplash-hide-when-booted.service
8:ExecStartPre=/bin/sh -c 'exec /bin/sleep 15'
9:ExecStart=/bin/sh -c 'exec /bin/echo off > /sys/devices/platform/bootsplash.0/enabled'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-ask-password-console.service
20:ExecStart=/bin/systemd-tty-ask-password-agent --watch --console
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/brltty.service
21:ExecStart=/bin/brltty --no-daemon
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/bluetooth.service
9:ExecStart=/usr/lib/bluetooth/bluetoothd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-user-sessions.service
18:ExecStart=/lib/systemd/systemd-user-sessions start
19:ExecStop=/lib/systemd/systemd-user-sessions stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-client.service
10:ExecStart=bash /home/mks/Desktop/myfile/znp/znp_tjc_klipper/build/start.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-halt.service
19:ExecStart=/bin/systemctl --force halt
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/elegoo-fix.service
10:ExecStart=/root/fix-service.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/quotaon.service
21:ExecStart=/sbin/quotaon -aug
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/usb_modeswitch@.service
7:ExecStart=/usr/sbin/usb_modeswitch_dispatcher --switch-mode %i
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-firstrun.service
12:ExecStart=/usr/lib/armbian/armbian-firstrun start
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-hostnamed.service
18:ExecStart=/lib/systemd/systemd-hostnamed
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/rsync.service
8:ExecStart=/usr/bin/rsync --daemon --no-detach
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-ask-password-wall.service
16:ExecStartPre=-/bin/systemctl stop systemd-ask-password-console.path systemd-ask-password-console.service systemd-ask-password-plymouth.path systemd-ask-password-plymouth.service
17:ExecStart=/bin/systemd-tty-ask-password-agent --wall
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-webcam.service
8:ExecStart=bash /root/auto-webcam-id.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/anacron.service
17:ExecStart=/usr/sbin/anacron -d -q $ANACRON_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/alsa-state.service
14:ExecStart=-/usr/sbin/alsactl -E HOME=/run/alsa -s -n 19 -c rdaemon
15:ExecStop=-/usr/sbin/alsactl -E HOME=/run/alsa -s kill save_and_quit
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/polkit.service
8:ExecStart=/usr/lib/policykit-1/polkitd --no-debug
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-update-utmp-runlevel.service
23:ExecStart=/lib/systemd/systemd-update-utmp runlevel
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-networkd.service
24:ExecStart=!!/lib/systemd/systemd-networkd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-hardware-monitor.service
13:ExecStart=/usr/lib/armbian/armbian-hardware-monitor start
14:ExecStop=/usr/lib/armbian/armbian-hardware-monitor stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-hibernate.service
19:ExecStart=/lib/systemd/systemd-sleep hibernate
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/container-getty@.service
29:ExecStart=-/sbin/agetty -o '-p -- \\u' --noclear --keep-baud pts/%I 115200,38400,9600 $TERM
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-localed.service
18:ExecStart=/lib/systemd/systemd-localed
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-sysusers.service
22:ExecStart=/bin/systemd-sysusers
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-bless-boot.service
22:ExecStart=/lib/systemd/systemd-bless-boot good
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/wpa_supplicant@.service
12:ExecStart=/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-%I.conf -Dnl80211,wext -i%I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/wpa_supplicant.service
10:ExecStart=/sbin/wpa_supplicant -u -s -O /run/wpa_supplicant
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/logrotate.service
8:ExecStart=/usr/sbin/logrotate /etc/logrotate.conf
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/initrd-switch-root.service
20:ExecStart=/bin/systemctl --no-block switch-root /sysroot
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-kexec.service
19:ExecStart=/bin/systemctl --force kexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/wg-quick@.service
16:ExecStart=/usr/bin/wg-quick up %i
17:ExecStop=/usr/bin/wg-quick down %i
18:ExecReload=/bin/bash -c 'exec /usr/bin/wg syncconf %i <(exec /usr/bin/wg-quick strip %i)'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-tmpfiles-setup.service
22:ExecStart=/bin/systemd-tmpfiles --create --remove --boot --exclude-prefix=/dev
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-update-utmp.service
22:ExecStart=/lib/systemd/systemd-update-utmp reboot
23:ExecStop=/lib/systemd/systemd-update-utmp shutdown
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ntp.service
11:ExecStart=/usr/lib/ntp/ntp-systemd-wrapper
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-fsck-root.service
24:ExecStart=/lib/systemd/systemd-fsck
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-initctl.service
16:ExecStart=/lib/systemd/systemd-initctl
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/rescue.service
21:ExecStartPre=-/bin/plymouth --wait quit
22:ExecStart=-/lib/systemd/systemd-sulogin-shell rescue
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-tmpfiles-setup-dev.service
21:ExecStart=/bin/systemd-tmpfiles --prefix=/dev --create --boot
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-journald.service
20:ExecStart=/lib/systemd/systemd-journald
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/console-getty.service
24:ExecStart=-/sbin/agetty -o '-p -- \\u' --noclear --keep-baud console 115200,38400,9600 $TERM
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/packagekit-offline-update.service
13:ExecStart=/usr/lib/packagekit/pk-offline-update
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-journal-flush.service
20:ExecStart=/bin/journalctl --flush
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-time-monitor.service
6:ExecStart=/root/set-time.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/dhcpcd.service
8:ExecStart=/usr/sbin/dhcpcd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/getty-static.service
8:ExecStart=/bin/systemctl --no-block start getty@tty2.service getty@tty3.service getty@tty4.service getty@tty5.service getty@tty6.service
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/cups.service
6:ExecStart=/usr/sbin/cupsd -l
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-fsck@.service
23:ExecStart=/lib/systemd/systemd-fsck %f
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-sysctl.service
22:ExecStart=/lib/systemd/systemd-sysctl
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ifupdown-wait-online.service
9:ExecStart=/lib/ifupdown/wait-online.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-boot-check-no-failures.service
21:ExecStart=/lib/systemd/systemd-boot-check-no-failures
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-timedated.service
18:ExecStart=/lib/systemd/systemd-timedated
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/fake-hwclock.service
10:ExecStart=/sbin/fake-hwclock load $FORCE
11:ExecStop=/sbin/fake-hwclock save
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/system-update-cleanup.service
35:ExecStart=/bin/rm -fv /system-update
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ifupdown-pre.service
13:ExecStart=/bin/sh -c 'if [ "$CONFIGURE_INTERFACES" != "no" ] && [ -n "$(ifquery --read-environment --list --exclude=lo)" ] && [ -x /bin/udevadm ]; then udevadm settle; fi'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/ssh@.service
8:ExecStart=-/usr/sbin/sshd -i $SSHD_OPTS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/emergency.service
22:ExecStartPre=-/bin/plymouth --wait quit
23:ExecStart=-/lib/systemd/systemd-sulogin-shell emergency
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/makerbase-net-mods.service
10:ExecStart=/bin/cp /boot/wpa_supplicant-wlan0.conf /etc/wpa_supplicant/wpa_supplicant-wlan0.conf
11:ExecStartPost=/bin/chmod 600 /etc/wpa_supplicant/wpa_supplicant-wlan0.conf
12:ExecStartPost=/usr/sbin/rfkill unblock wifi
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-firstrun-config.service
14:ExecStart=/usr/lib/armbian/armbian-firstrun-config
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-machine-id-commit.service
23:ExecStart=/bin/systemd-machine-id-setup --commit
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/debug-shell.service
20:ExecStart=/bin/bash
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/cron.service
8:ExecStart=/usr/sbin/cron -f $EXTRA_OPTS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/wpa_supplicant-nl80211@.service
12:ExecStart=/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-nl80211-%I.conf -Dnl80211 -i%I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-resolved.service
25:ExecStart=!!/lib/systemd/systemd-resolved
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/initrd-udevadm-cleanup-db.service
20:ExecStart=-/bin/udevadm info --cleanup-db
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/clean-mount-point@.service
10:ExecStop=/bin/rm -fd %f
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/bootsplash-show-on-shutdown.service
11:ExecStart=/bin/sh -c 'exec /bin/echo on > /sys/devices/platform/bootsplash.0/enabled'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/initrd-parse-etc.service
21:ExecStartPre=-/bin/systemctl daemon-reload
23:ExecStart=-/bin/systemctl --no-block start initrd-fs.target
24:ExecStart=/bin/systemctl --no-block start initrd-cleanup.service
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/armbian-zram-config.service
14:ExecStart=/usr/lib/armbian/armbian-zram-config start
15:ExecStop=/usr/lib/armbian/armbian-zram-config stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-remount-fs.service
24:ExecStart=/lib/systemd/systemd-remount-fs
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/spice-vdagentd.service
8:ExecStart=/usr/sbin/spice-vdagentd $SPICE_VDAGENTD_EXTRA_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/networking.service
18:ExecStart=/sbin/ifup -a --read-environment
19:ExecStop=/sbin/ifdown -a --read-environment --exclude=lo
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/wpa_supplicant-wired@.service
12:ExecStart=/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-wired-%I.conf -Dwired -i%I
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/sysstat.service
17:ExecStart=/usr/lib/sysstat/debian-sa1 --boot
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/user-runtime-dir@.service
18:ExecStart=/lib/systemd/systemd-user-runtime-dir start %i
19:ExecStop=/lib/systemd/systemd-user-runtime-dir stop %i
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/haveged.service
11:ExecStart=/usr/sbin/haveged --Foreground --verbose=1 $DAEMON_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/user@.service
21:ExecStart=-/lib/systemd/systemd --user
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/dbus.service
7:ExecStart=/usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
8:ExecReload=/usr/bin/dbus-send --print-reply --system --type=method_call --dest=org.freedesktop.DBus / org.freedesktop.DBus.ReloadConfig
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/keyboard-setup.service
10:ExecStart=/lib/console-setup/keyboard-setup.sh
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-udevd.service
24:ExecStart=/lib/systemd/systemd-udevd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/kmod-static-nodes.service
20:ExecStart=/bin/kmod static-nodes --format=tmpfiles --output=/run/tmpfiles.d/kmod.conf
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/lightdm.service
17:ExecStartPre=/bin/sh -c '[ "$(cat /etc/X11/default-display-manager 2>/dev/null)" = "/usr/sbin/lightdm" ]'
18:ExecStart=/usr/sbin/lightdm
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-quotacheck.service
21:ExecStart=/lib/systemd/systemd-quotacheck
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/man-db.service
9:ExecStart=+/usr/bin/install -d -o man -g man -m 0755 /var/cache/man
11:ExecStart=/usr/bin/find /var/cache/man -type f -name *.gz -atime +6 -delete
13:ExecStart=/usr/bin/mandb --quiet
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-hybrid-sleep.service
19:ExecStart=/lib/systemd/systemd-sleep hybrid-sleep
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-hwdb-update.service
25:ExecStart=/bin/systemd-hwdb update
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-modules-load.service
28:ExecStart=/lib/systemd/systemd-modules-load
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/system/systemd-timesyncd.service
24:ExecStart=!!/lib/systemd/systemd-timesyncd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/thunar.service
7:ExecStart=/usr/bin/Thunar --daemon
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/ssh-agent.service
10:ExecStart=/usr/lib/openssh/agent-launch start
11:ExecStopPost=/usr/lib/openssh/agent-launch stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/xscreensaver.service
5:ExecStart=xscreensaver
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/redshift.service
7:ExecStart=/usr/bin/redshift
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/xfce4-notifyd.service
7:ExecStart=/usr/lib/aarch64-linux-gnu/xfce4/notifyd/xfce4-notifyd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/dirmngr.service
7:ExecStart=/usr/bin/dirmngr --supervised
8:ExecReload=/usr/bin/gpgconf --reload dirmngr
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/systemd-tmpfiles-clean.service
19:ExecStart=/bin/systemd-tmpfiles --user --clean
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-mtp-volume-monitor.service
5:ExecStart=/usr/lib/gvfs/gvfs-mtp-volume-monitor
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gpg-agent.service
7:ExecStart=/usr/bin/gpg-agent --supervised
8:ExecReload=/usr/bin/gpgconf --reload gpg-agent
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/obex.service
7:ExecStart=/usr/lib/bluetooth/obexd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/pulseaudio.service
22:ExecStart=/usr/bin/pulseaudio --daemonize=no
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/systemd-tmpfiles-setup.service
21:ExecStart=/bin/systemd-tmpfiles --user --create --remove --boot
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-goa-volume-monitor.service
5:ExecStart=/usr/lib/gvfs/gvfs-goa-volume-monitor
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/psd.service
13:ExecStart=/bin/true
14:ExecStop=/usr/bin/profile-sync-daemon unsync
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-afc-volume-monitor.service
5:ExecStart=/usr/lib/gvfs/gvfs-afc-volume-monitor
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-gphoto2-volume-monitor.service
5:ExecStart=/usr/lib/gvfs/gvfs-gphoto2-volume-monitor
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/org.gnome.Evince.service
8:ExecStart=/usr/lib/evince/evinced
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/psd-resync.service
9:ExecStart=/usr/bin/profile-sync-daemon resync
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-udisks2-volume-monitor.service
5:ExecStart=/usr/lib/gvfs/gvfs-udisks2-volume-monitor
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-metadata.service
5:ExecStart=/usr/lib/gvfs/gvfsd-metadata
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/at-spi-dbus-bus.service
7:ExecStart=/usr/lib/at-spi2-core/at-spi-bus-launcher
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/glib-pacrunner.service
7:ExecStart=/usr/lib/glib-networking//glib-pacrunner
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/systemd/user/gvfs-daemon.service
5:ExecStart=/usr/lib/gvfs/gvfsd
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/subprocess.py
624:      preexec_fn: (POSIX only) An object to be called in the child process
658:                 preexec_fn=None, close_fds=True,
680:            if preexec_fn is not None:
769:            self._execute_child(args, executable, preexec_fn, close_fds,
1107:        def _execute_child(self, args, executable, preexec_fn, close_fds,
1383:        def _execute_child(self, args, executable, preexec_fn, close_fds,
1453:                            restore_signals, start_new_session, preexec_fn)
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/turtle.py
3595:        if action == "rot":
3599:        elif action == "stamp":
3602:        elif action == "go":
3608:        elif action == "dofill":
3612:        elif action == "beginfill":
3618:        elif action == "pen":
3644:        if action == "seq":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/distutils/filelist.py
115:        if action == 'include':
122:        elif action == 'exclude':
129:        elif action == 'global-include':
136:        elif action == 'global-exclude':
144:        elif action == 'recursive-include':
153:        elif action == 'recursive-exclude':
162:        elif action == 'graft':
168:        elif action == 'prune':
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/distutils/command/bdist_rpm.py
103:         "Specify a script for the pre-INSTALL phase of RPM building"),
107:         "Specify a script for the post-INSTALL phase of RPM building"),
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/distutils/command/bdist_wininst.py
264:        # Append the pre-install script
275:            # empty pre-install script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/distutils/command/bdist_msi.py
166:                  "the pre-install-script feature is not yet implemented")
388:        # XXX pre-install scripts are currently refused in finalize_options()
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/warnings.py
243:    if action == "all": return "always" # Alias
377:    if action == "ignore":
385:    if action == "error":
388:    if action == "once":
394:    elif action == "always":
396:    elif action == "module":
402:    elif action == "default":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/optparse.py
788:        if action == "store":
790:        elif action == "store_const":
792:        elif action == "store_true":
794:        elif action == "store_false":
796:        elif action == "append":
798:        elif action == "append_const":
800:        elif action == "count":
802:        elif action == "callback":
806:        elif action == "help":
809:        elif action == "version":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python3.7/pydoc.py
904:            assert attrs == []
1349:            assert attrs == []
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/subprocess.py
313:      preexec_fn: (POSIX only) An object to be called in the child process
336:                 preexec_fn=None, close_fds=False, shell=False,
346:            if preexec_fn is not None:
389:            self._execute_child(args, executable, preexec_fn, close_fds,
590:        def _execute_child(self, args, executable, preexec_fn, close_fds,
900:        def _execute_child(self, args, executable, preexec_fn, close_fds,
988:                            if preexec_fn:
989:                                preexec_fn()
992:                            # preexec_fn(), which may open FDs.
1294:        p = Popen(["id"], preexec_fn=lambda: os.setuid(100))
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/distutils/filelist.py
123:        if action == 'include':
130:        elif action == 'exclude':
137:        elif action == 'global-include':
144:        elif action == 'global-exclude':
152:        elif action == 'recursive-include':
161:        elif action == 'recursive-exclude':
170:        elif action == 'graft':
176:        elif action == 'prune':
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/distutils/command/bdist_rpm.py
108:         "Specify a script for the pre-INSTALL phase of RPM building"),
112:         "Specify a script for the post-INSTALL phase of RPM building"),
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/distutils/command/bdist_wininst.py
285:        # Append the pre-install script
291:            # empty pre-install script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/distutils/command/bdist_msi.py
166:            raise DistutilsOptionError, "the pre-install-script feature is not yet implemented"
390:        # XXX pre-install scripts are currently refused in finalize_options()
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/warnings.py
163:    if action == "all": return "always" # Alias
267:    if action == "ignore":
275:    if action == "error":
278:    if action == "once":
284:    elif action == "always":
286:    elif action == "module":
292:    elif action == "default":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/optparse.py
792:        if action == "store":
794:        elif action == "store_const":
796:        elif action == "store_true":
798:        elif action == "store_false":
800:        elif action == "append":
802:        elif action == "append_const":
804:        elif action == "count":
806:        elif action == "callback":
810:        elif action == "help":
813:        elif action == "version":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/webbrowser.py
198:                p = subprocess.Popen(cmdline, close_fds=True, preexec_fn=setsid)
238:                             stderr=inout, preexec_fn=setsid)
380:                                 preexec_fn=setsid)
393:                                 preexec_fn=setsid)
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/lib-tk/turtle.py
3487:        if action == "rot":
3491:        elif action == "stamp":
3494:        elif action == "go":
3500:        elif action == "dofill":
3504:        elif action == "beginfill":
3509:        elif action == "pen":
3535:        if action == "seq":
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/python2.7/pydoc.py
878:            assert attrs == []
1283:            assert attrs == []
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/bash-completion/completions/tc
397:        if [[ action == ${words[acwd]} ]]; then
420:        if [[ action == ${words[acwd]} ]]; then
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/X11/xman.help
164:Xman contains a set of preinstalled keyboard accelerators.  These are a
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/ghostscript/9.27/Resource/Init/pdf_main.ps
203:% ======================== Main program ======================== %
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/libpng.jam
211:            ECHO "notice: [libpng] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/lzma.jam
119:            ECHO "notice: [lzma] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/libtiff.jam
213:            ECHO "notice: [libtiff] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/libjpeg.jam
219:            ECHO "notice: [libjpeg] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/zlib.jam
221:            ECHO "notice: [zlib] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/zstd.jam
84:            ECHO "notice: [zstd] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/boost-build/src/tools/bzip2.jam
231:            ECHO "notice: [bzip2] Using pre-installed library" ;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/hunspell/en_US.dic
37205:preinstalled
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/hplip/ui5/sendfaxdialog.py
441:        elif action == FAB_NAME_REMOVE:
448:        elif action == FAB_NAME_RENAME:
458:        elif action == FAB_NAME_DETAILS_CHANGED:
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/hplip/hpdio.py
139:                            if action == EVENT_DEVICE_UPDATE_REQUESTED:
174:                elif action == EVENT_USER_CONFIGURATION_CHANGED:
177:                elif action == EVENT_SYSTEMTRAY_EXIT:
183:                if action == EVENT_DEVICE_UPDATE_REQUESTED:
199:                elif action == EVENT_POLLING_REQUEST:
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/kbd/examples/vcstime.service
13:ExecStart=/usr/sbin/vcstime
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/libgphoto2-6/README.Debian
15:ACTION=="add", SYSFS{idVendor}=="XXXX", SYSFS{idProduct}=="YYYY", \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/python3/python-policy.html/programs.html
38:	    package's post-install script using the current default Python
39:	    version, and removed in the pre-remove script. Modules should be
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/python3/python-policy.html/module_packages.html
208:	  package's post-install script, and removed in the package's
209:	  pre-remove script. The package's prerm has to make sure that
218:	  post-install scripts should respect these settings.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/anacron/README.Debian
6:cron.{daily,weekly,monthly}.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/inputattach/README.Debian
15:	ACTION=="add", KERNEL=="ttyS0", RUN+="/usr/bin/inputattach --daemon -msc /dev/%k"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/xterm/xterm.log.html
1551:    <li>install a complete set of icons, to simplify post-install
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/xdg-utils/README
74:you're writing your post installation script, and you want to create
81:    Then a simple post install script could look like this:
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/util-linux/examples/udev-raw.rules
4:#   ACTION=="add", KERNEL=="sda", RUN+="/bin/raw /dev/raw/raw1 %N"
6:#   ACTION=="add", ENV{MAJOR}=="8", ENV{MINOR}=="1", RUN+="/bin/raw /dev/raw/raw2 %M %m"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/zsh-common/examples/carstenh.zshrc
67:# ###  * Precmd / preexec:
193:# ### Precmd / preexec:                                                      #
197:# preexec_xterm_title() {
205:# preexec_functions=( ${preexec_functions} preexec_xterm_title )
209:# preexec_screen_window_title() {
235:# preexec_functions=( ${preexec_functions} preexec_screen_window_title )
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/zsh-common/examples/Misc/bash2zshprompt
27:    s/^\s*}\s*$/\n  precmd () { setopt promptsubst }\n  preexec () { }\n}\n/ and $seen_fn_end++;
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/openssh-client/examples/ssh-session-cleanup.service
7:ExecStart=/bin/true
8:ExecStop=/usr/lib/openssh/ssh-session-cleanup
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/git/RelNotes/1.6.1.txt
36:* Many operations that are lstat(3) heavy can be told to pre-execute
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/cron/THANKS
14:on it.  Kevin Braunsdorf of Purdue made a suggestion that led to @reboot and
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/cron/README.Debian
1:cron for DEBIAN
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/doc/cron/examples/crontab2english.pl
147:cron daemon understands.
945:              @reboot        xxstartuply foo
946:              @yearly        xxx yearlijk%thig%hooboy
947:              @annually      xxannuallijk heehoo
948:              @monthly       xxx monthlijk
949:              @weekly        xXxX weeklijk
950:              @daily         xxxdaylijk
951:              @midnight      xxxmidnightlijk
952:              @hourly        xXxXhourlijk
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/libtool/configure
10775:postinstall_cmds=
10879:      postinstall_cmds='test -n "$linkname" || linkname="$realname"~func_stripname "" ".so" "$linkname"~$install_shared_prog "$dir/$func_stripname_result.$libext" "$destdir/$func_stripname_result.$libext"~test -z "$tstripme" || test -z "$striplib" || $striplib "$destdir/$func_stripname_result.$libext"'
10889:      postinstall_cmds='test -z "$dlname" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z "$tstripme" || test -z "$striplib" || $striplib $destdir/$dlname~test -n "$linkname" || linkname=$realname~func_stripname "" ".a" "$linkname"~(cd "$destdir" && $LN_S -f $dlname $func_stripname_result.so)'
10942:    # DLL is installed to $(libdir)/../bin by postinstall_cmds
10943:    postinstall_cmds='base_file=`basename \$file`~
11019:    # DLL is installed to $(libdir)/../bin by postinstall_cmds
11020:    postinstall_cmds='base_file=`basename \$file`~
11168:  postinstall_cmds='chmod 555 $lib'
11397:  postinstall_cmds='base_file=`basename \$file`~
11436:  postinstall_cmds='chmod +x $lib'
12278:      postinstall_cmds='$RANLIB $lib'
14105:postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
14227:postinstall_cmds \
15244:postinstall_cmds=$lt_postinstall_cmds
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/cmake-3.13/Help/cpack_gen/rpm.rst
310: May be used to set RPM preinstall dependencies (requires(pre)). Note that
323: May be used to set RPM postinstall dependencies (requires(post)). Note that
430: this may also disable other default post install processing)::
722:detected, a post install symlink relocation script will be generated.
728:post install script - depending on relocation paths.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/cmake-3.13/Help/release/3.2.rst
165:  requirements for pre- and post-install scripts.  See the
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/perl/5.28.1/DB.pm
121:      # perform any client-specific prestop actions
133:      # perform any client-specific poststop actions
485:sub prestop {
490:sub poststop {
757:returns the prestop action string.
770:returns the poststop action string.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/perl/5.28.1/perl5db.pl
4500:The C<a> command handles pre-execution actions. These are associated with a
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/aclocal/glib-gettext.m4
251:	  [Define if the GNU gettext() function is already present or preinstalled.])
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/aclocal/ltdl.m4
222:# choose between a shipped copy of the ltdl sources or a preinstalled
302:	# preinstalled libltdl we found.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/autoload/netrw.vim
12022:    if action == "refresh"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/syntax/upstart.vim
52:syn keyword upstartOption pre-start post-start pre-stop post-stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/syntax/samba.vim
54:syn keyword sambaKeyword contained postexec postscript prediction preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/syntax/iss.vim
87:syn keyword issRunFlags hidewizard nowait postinstall runhidden runmaximized
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/syntax/modconf.vim
23:                                \ post-install post-remove pre-install
24:                                \ pre-remove persistdir blacklist
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/vim/vim81/syntax/aptconf.vim
321:	\ Pre-Install-Pkgs Pre-Invoke Post-Invoke
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Prompts/promptinit
35:  # To manipulate precmd and preexec hooks...
53:  local -a precmd_functions preexec_functions prompt_preview_cleanup
105:        local -a precmd_functions preexec_functions
176:       for hook in chpwd precmd preexec periodic zshaddhistory zshexit; do
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Prompts/prompt_bart_setup
187:	add-zsh-hook -D preexec "prompt_*_preexec"
230:    add-zsh-hook preexec prompt_bart_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Misc/getjobs
1:# Call this from the preexec function like so:
2:#   preexec() {
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Misc/add-zsh-hook
2:# HOOK is one of chpwd, precmd, preexec, periodic, zshaddhistory,
19:  chpwd precmd preexec periodic zshaddhistory zshexit
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Completion/Unix/_gem
108:        '--post-install-message[print post install message]'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Completion/Unix/_tmux
1112:    'post-hooks:command post-hook:compadd - after-${_tmux_aliasmap}'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Completion/Linux/_opkg
320:    '--force-postinstall[always run postinstall scripts]'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/zsh/functions/Completion/Zsh/_add-zsh-hook
20:    ':hook class:(chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name)' \
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/share/dictionaries-common/site-elisp/flyspell.el
724:;;*    The flyspell pre-hook, store the current position. In the        */
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/sbin/softy
588:				echo "ATTRS{idVendor}==\"152d\", ATTRS{idProduct}==\"0561\", KERNEL==\"sd*\", ENV{DEVTYPE}==\"disk\", SYMLINK=\"disk/by-id/\$env{ID_BUS}-CloudShell2-${REPLY}-\$env{ID_MODEL}\"" >> /etc/udev/rules.d/99-cloudshell2.rules
589:				echo "ATTRS{idVendor}==\"152d\", ATTRS{idProduct}==\"0561\", KERNEL==\"sd*\", ENV{DEVTYPE}==\"partition\", SYMLINK=\"disk/by-id/\$env{ID_BUS}-CloudShell2-${REPLY}-\$env{ID_MODEL}-part%n\"" >> /etc/udev/rules.d/99-cloudshell2.rules
942:ExecStart=/usr/bin/mono --debug /opt/Radarr/Radarr.exe -nobrowser
976:ExecStart=/usr/bin/mono --debug /opt/NzbDrone/NzbDrone.exe -nobrowser
1019:ExecStart=/usr/local/vpnserver/vpnserver start
1020:ExecStop=/usr/local/vpnserver/vpnserver stop
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/bin/ucf
25:# post installation configuration phase by the script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/init/resolvconf.conf
9:pre-start script
17:post-stop script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/rsyslog.conf
86:	cron,daemon.none;\
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/udev/rules.d/50-mali.rules
1:KERNEL=="mali*", MODE="0660", GROUP="video"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/udev/rules.d/10-wifi-disable-powermanagement.rules
1:KERNEL=="wlan*", ACTION=="add", RUN+="/sbin/iwconfig wlan0 power off"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/udev/rules.d/50-rk3399-vpu.rules
1:KERNEL=="vpu_service", MODE="0660", GROUP="video"
2:KERNEL=="rkvdec", MODE="0660", GROUP="video"
3:KERNEL=="rga", MODE="0660", GROUP="video" 
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/systemd/system/KlipperScreen.service
13:ExecStart="/home/mks/KlipperScreen/scripts/KlipperScreen-start.sh"
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/systemd/system/klipper.service
20:ExecStart=/home/mks/klippy-env/bin/python /home/mks/klipper/klippy/klippy.py ${KLIPPER_CONFIG} -I ${KLIPPER_PRINTER} -l ${KLIPPER_LOG} -a ${KLIPPER_SOCKET}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/systemd/system/logrotate.service
8:ExecStartPre=/usr/lib/armbian/armbian-ramlog write
9:ExecStart=/usr/sbin/logrotate /etc/logrotate.conf
10:ExecStartPost=/usr/lib/armbian/armbian-ramlog postrotate
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/systemd/system/crowsnest.service
28:ExecStart= /usr/local/bin/crowsnest $CROWSNEST_ARGS
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/systemd/system/moonraker.service
18:ExecStart=/home/mks/moonraker-env/bin/python /home/mks/moonraker/moonraker/moonraker.py -c ${MOONRAKER_CONF} -l ${MOONRAKER_LOG}
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/default/rsync
7:# options to the ExecStart line.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/themes/jonathan.zsh-theme
31:add-zsh-hook preexec theme_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/themes/steeef.zsh-theme
77:add-zsh-hook preexec steeef_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/themes/simonoff.zsh-theme
37:add-zsh-hook preexec theme_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/themes/half-life.zsh-theme
85:add-zsh-hook preexec steeef_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/themes/refined.zsh-theme
66:preexec() {
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/lib/termsupport.zsh
91:    # override preexec function arguments with job command
109:  add-zsh-hook preexec omz_termsupport_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/gnu-utils/gnu-utils.plugin.zsh
47:    # Thus, a preexec hook is needed, which will only run if whoami
63:add-zsh-hook preexec __gnu_utils_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/timer/timer.plugin.zsh
34:add-zsh-hook preexec __timer_save_time_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/gpg-agent/gpg-agent.plugin.zsh
9:add-zsh-hook preexec _gpg-agent_update-tty_preexec
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/zbell/zbell.plugin.zsh
95:add-zsh-hook preexec zbell_begin
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/screen/screen.plugin.zsh
40:  function preexec()
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/gem/_gem
32:  'rdoc:Generates RDoc for pre-installed gems'
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/git-prompt/git-prompt.plugin.zsh
13:function preexec_update_git_vars() {
31:add-zsh-hook preexec preexec_update_git_vars
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/alias-finder/alias-finder.plugin.zsh
40:preexec_alias-finder() {
47:add-zsh-hook preexec preexec_alias-finder
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/plugins/bgnotify/bgnotify.plugin.zsh
91:  add-zsh-hook preexec bgnotify_begin
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/oh-my-zsh/README.md
61:- [Zsh](https://www.zsh.org) should be installed (v4.3.9 or more recent is fine but we prefer 5.0.8 and newer). If not pre-installed (run `zsh --version` to confirm), check the following wiki instructions here: [Installing ZSH](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH)
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/anacrontab
13:@monthly	15	cron.monthly	run-parts --report /etc/cron.monthly
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/cron.d/armbian-updates
1:@reboot root /usr/lib/armbian/armbian-apt-updates
2:@daily root /usr/lib/armbian/armbian-apt-updates
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/armbian-bsp-cli-mkspi.postinst
3:# mkspi BSP post installation script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/ucf.postinst
60:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/ca-certificates.postinst
18:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/xterm.postinst
2:# Debian xterm package post-installation script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/xserver-xorg-legacy.postinst
2:# Debian xserver-xorg-legacy package post-installation script
35:# This file was generated by the post-installation script of the
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/cpufrequtils.postinst
21:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/flex.postinst
60:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/procps.postinst
21:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/less.postinst
20:#     post-installation script, and should be protected with a conditional
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/fbset.postinst
3:# Post-Installation script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/xcursor-themes.postinst
2:# Debian xcursor-themes package post-installation script
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/libc6:arm64.postinst
112:		    echo "Name Service Switch update in the C Library: post-installation question."
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/lib/dpkg/info/resolvconf.templates
136: pre-installation /etc/resolv.conf in its database until reboot.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/cache/debconf/templates.dat-old
7122:Extended_description: Suppliers of name server information such as local caching name servers and interface configurers are expected to supply name server information to the resolvconf program. However, although installation of the resolvconf package triggers them to supply their information, some of them fail to do so.\n\nThis bug would lead to loss of valid name server information on installation of the resolvconf package if the following workaround were not adopted: resolvconf includes the full contents of the pre-installation /etc/resolv.conf in its database until reboot. This has the drawback that name server information is retained even if the associated interface is later deconfigured. (This incorrect behavior is judged to be less harmful than the alternative of losing valid information.)\n\nUntil the bug in question is fixed and the workaround removed, the only way to ensure that resolvconf has fully correct name server information after the resolvconf package has been installed on a running system is to reboot the system.
----------------------------------------
File: /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/var/cache/debconf/templates.dat
7122:Extended_description: Suppliers of name server information such as local caching name servers and interface configurers are expected to supply name server information to the resolvconf program. However, although installation of the resolvconf package triggers them to supply their information, some of them fail to do so.\n\nThis bug would lead to loss of valid name server information on installation of the resolvconf package if the following workaround were not adopted: resolvconf includes the full contents of the pre-installation /etc/resolv.conf in its database until reboot. This has the drawback that name server information is retained even if the associated interface is later deconfigured. (This incorrect behavior is judged to be less harmful than the alternative of losing valid information.)\n\nUntil the bug in question is fixed and the workaround removed, the only way to ensure that resolvconf has fully correct name server information after the resolvconf package has been installed on a running system is to reboot the system.
----------------------------------------
