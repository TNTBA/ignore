Differences in scripts/flashtool.py:

- Lines with differences: 259 lines in 18 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/CanBoot/scripts/flashtool.py	2023-08-12 06:18:51.900709110 -0400
+++ /home/mks/firmware_comparison/downloads/CanBoot/scripts/flashtool.py	2024-10-08 17:45:28.585223681 -0400
@@ -15,7 +15,16 @@
 import argparse
 import hashlib
 import pathlib
+import shutil
+import shlex
+import contextlib
 from typing import Dict, List, Optional, Union
+HAS_SERIAL = True
+try:
+    from serial import Serial, SerialException
+except ModuleNotFoundError:
+    HAS_SERIAL = False
+    SerialException = Exception
 
 def output_line(msg: str) -> None:
     sys.stdout.write(msg + "\n")
@@ -34,6 +43,7 @@
         crc = ((data << 8) | (crc >> 8)) ^ (data >> 4) ^ (data << 3)
     return crc & 0xFFFF
 
+
 logging.basicConfig(level=logging.INFO)
 CAN_FMT = "<IB3x8s"
 CAN_READER_LIMIT = 1024 * 1024
@@ -67,7 +77,7 @@
 CANBUS_RESP_NEED_NODEID = 0x20
 CANBUS_NODEID_OFFSET = 128
 
-class FlashCanError(Exception):
+class FlashError(Exception):
     pass
 
 class CanFlasher:
@@ -84,21 +94,30 @@
         self.block_count = 0
         self.app_start_addr = 0
 
-    async def connect_btl(self):
+    async def connect_btl(self) -> None:
         output_line("Attempting to connect to bootloader")
         ret = await self.send_command('CONNECT')
         pinfo = ret[:12]
-        mcu_type = ret[12:]
+        mcu_info = ret[12:]
+        ver_bytes: bytes
         ver_bytes, start_addr, self.block_size = struct.unpack("<4sII", pinfo)
         self.app_start_addr = start_addr
-        proto_version = ".".join([str(v) for v in reversed(ver_bytes[:3])])
+        self.software_version = "?"
+        self.proto_version = tuple([v for v in reversed(ver_bytes[:3])])
+        proto_version_str = ".".join([str(v) for v in self.proto_version])
         if self.block_size not in [64, 128, 256, 512]:
-            raise FlashCanError("Invalid Block Size: %d" % (self.block_size,))
-        while mcu_type and mcu_type[-1] == 0x00:
-            mcu_type = mcu_type[:-1]
-        mcu_type = mcu_type.decode()
+            raise FlashError("Invalid Block Size: %d" % (self.block_size,))
+        mcu_info.rstrip(b"\x00")
+        if self.proto_version >= (1, 1, 0):
+            mcu_bytes, sv_bytes = mcu_info.split(b"\x00", maxsplit=1)
+            mcu_type = mcu_bytes.decode()
+            self.software_version = sv_bytes.decode()
+        else:
+            mcu_type = mcu_info.decode()
         output_line(
-            f"Katapult Connected\nProtocol Version: {proto_version}\n"
+            f"Katapult Connected\n"
+            f"Software Version: {self.software_version}\n"
+            f"Protocol Version: {proto_version_str}\n"
             f"Block Size: {self.block_size} bytes\n"
             f"Application Start: 0x{self.app_start_addr:4X}\n"
             f"MCU type: {mcu_type}"
@@ -109,7 +128,7 @@
         ret = await self.send_command('GET_CANBUS_ID')
         mcu_uuid = sum([v << ((5 - i) * 8) for i, v in enumerate(ret[:6])])
         if mcu_uuid != uuid:
-            raise FlashCanError("UUID mismatch (%s vs %s)" % (uuid, mcu_uuid))
+            raise FlashError("UUID mismatch (%s vs %s)" % (uuid, mcu_uuid))
 
     async def send_command(
         self,
@@ -127,7 +146,7 @@
         crc = crc16_ccitt(out_cmd[2:])
         out_cmd.extend(struct.pack("<H", crc))
         out_cmd.extend(CMD_TRAILER)
-        err = Exception()
+        last_err = Exception()
         while tries:
             data = bytearray()
             recd_len = 0
@@ -144,15 +163,17 @@
                         recd_len = data[3] * 4
                         read_done = len(data) == recd_len + 8
                         break
+            except asyncio.CancelledError:
+                raise
             except asyncio.TimeoutError:
                 logging.info(
                     f"Response for command {cmdname} timed out, "
                     f"{tries - 1} tries remaining"
                 )
             except Exception as e:
-                if type(e) != type(err) or str(e) != str(err):
-                    err = e
-                    logging.exception("Can Read Error")
+                if type(e) is type(last_err) and e.args == last_err.args:
+                    last_err = e
+                    logging.exception("Device Read Error")
             else:
                 trailer = data[-2:]
                 recd_crc, = struct.unpack("<H", data[-4:-2])
@@ -186,12 +207,13 @@
             tries -= 1
             # clear the read buffer
             try:
-                await self.node.read(1024, timeout=.1)
+                ret = await self.node.read(1024, timeout=.25)
             except asyncio.TimeoutError:
                 pass
+            else:
+                logging.info(f"Read Buffer Contents: {ret!r}")
             await asyncio.sleep(.1)
-        raise FlashCanError("Error sending command [%s] to Can Device"
-                            % (cmdname))
+        raise FlashError("Error sending command [%s] to Device" % (cmdname))
 
     async def send_file(self):
         last_percent = 0
@@ -202,6 +224,7 @@
             self.file_size = f.tell()
             f.seek(0)
             flash_address = self.app_start_addr
+            recd_addr = 0
             while True:
                 buf = f.read(self.block_size)
                 if not buf:
@@ -221,7 +244,7 @@
                     )
                     await asyncio.sleep(.1)
                 else:
-                    raise FlashCanError(
+                    raise FlashError(
                         f"Flash write failed, block address 0x{recd_addr:4X}"
                     )
                 flash_address += self.block_size
@@ -255,7 +278,7 @@
                 await asyncio.sleep(.1)
             else:
                 output_line("Error")
-                raise FlashCanError("Block Request Error, block: %d" % (i,))
+                raise FlashError("Block Request Error, block: %d" % (i,))
             ver_sha.update(resp[4:])
             pct = int(i * self.block_size / float(self.file_size) * 100 + .5)
             if pct >= last_percent + 2:
@@ -264,7 +287,7 @@
         ver_hex = ver_sha.hexdigest().upper()
         fw_hex = self.fw_sha.hexdigest().upper()
         if ver_hex != fw_hex:
-            raise FlashCanError("Checksum mismatch: Expected %s, Received %s"
+            raise FlashError("Checksum mismatch: Expected %s, Received %s"
                                 % (fw_hex, ver_hex))
         output_line("]\n\nVerification Complete: SHA = %s" % (ver_hex))
 
@@ -273,23 +296,23 @@
 
 
 class CanNode:
-    def __init__(self, node_id: int, cansocket: CanSocket) -> None:
+    def __init__(self, node_id: int, cansocket: CanSocket | SerialSocket) -> None:
         self.node_id = node_id
         self._reader = asyncio.StreamReader(CAN_READER_LIMIT)
         self._cansocket = cansocket
 
     async def read(
-        self, n: int = -1, timeout: Optional[float] = 2
+        self, n: int = -1, timeout: Optional[float] = 5.
     ) -> bytes:
         return await asyncio.wait_for(self._reader.read(n), timeout)
 
     async def readexactly(
-        self, n: int, timeout: Optional[float] = 2
+        self, n: int, timeout: Optional[float] = 5.
     ) -> bytes:
         return await asyncio.wait_for(self._reader.readexactly(n), timeout)
 
     async def readuntil(
-        self, sep: bytes = b"\x03", timeout: Optional[float] = 2
+        self, sep: bytes = b"\x03", timeout: Optional[float] = 5.
     ) -> bytes:
         return await asyncio.wait_for(self._reader.readuntil(sep), timeout)
 
@@ -453,27 +476,22 @@
         self, intf: str, uuid: int, fw_path: pathlib.Path, req_only: bool
     ) -> None:
         if not req_only and not fw_path.is_file():
-            raise FlashCanError("Invalid firmware path '%s'" % (fw_path))
+            raise FlashError("Invalid firmware path '%s'" % (fw_path))
         try:
             self.cansock.bind((intf,))
         except Exception:
-            raise FlashCanError("Unable to bind socket to can0")
+            raise FlashError("Unable to bind socket to can0")
         self.closed = False
         self.cansock.setblocking(False)
         self._loop.add_reader(
             self.cansock.fileno(), self._handle_can_response)
         self._jump_to_bootloader(uuid)
+        await asyncio.sleep(.5)
         if req_only:
             output_line("Bootloader request command sent")
             return
-        await asyncio.sleep(.5)
         self._reset_nodes()
-        await asyncio.sleep(.5)
-        id_list = await self._query_uuids()
-        if uuid not in id_list:
-            raise FlashCanError(
-                f"Unable to find node matching UUID: {uuid:012x}"
-            )
+        await asyncio.sleep(1.0)
         node = self._set_node_id(uuid)
         flasher = CanFlasher(node, fw_path)
         await asyncio.sleep(.5)
@@ -492,7 +510,7 @@
         try:
             self.cansock.bind((intf,))
         except Exception:
-            raise FlashCanError("Unable to bind socket to can0")
+            raise FlashError("Unable to bind socket to can0")
         self.closed = False
         self.cansock.setblocking(False)
         self._loop.add_reader(
@@ -513,42 +531,92 @@
 class SerialSocket:
     def __init__(self, loop: asyncio.AbstractEventLoop):
         self._loop = loop
-        self.serial = self.serial_error = None
+        self.serial: Optional[Serial] = None
         self.node = CanNode(0, self)
 
     def _handle_response(self) -> None:
+        assert self.serial is not None
         try:
             data = self.serial.read(4096)
-        except self.serial_error as e:
+        except SerialException:
             logging.exception("Error on serial read")
             self.close()
-        self.node.feed_data(data)
+        else:
+            self.node.feed_data(data)
 
     def send(self, can_id: int, payload: bytes = b"") -> None:
+        assert self.serial is not None
         try:
             self.serial.write(payload)
-        except self.serial_error as e:
+        except SerialException:
             logging.exception("Error on serial write")
             self.close()
 
+    async def _lookup_proc_name(self, process_id: str) -> str:
+        has_sysctl = shutil.which("systemctl") is not None
+        if has_sysctl:
+            cmd = shlex.split(f"systemctl status {process_id}")
+            proc = await asyncio.create_subprocess_exec(
+                *cmd,
+                stdout=asyncio.subprocess.PIPE,
+                stderr=asyncio.subprocess.PIPE
+            )
+            stdout, _ = await proc.communicate()
+            resp = stdout.strip().decode(errors="ignore")
+            if resp:
+                unit = resp.split(maxsplit=2)
+                if len(unit) == 3:
+                    return f"Systemd Unit Name: {unit[1]}"
+        cmdline_file = pathlib.Path(f"/proc/{process_id}/cmdline")
+        if cmdline_file.exists():
+            res = cmdline_file.read_text().replace("\x00", " ").strip()
+            return f"Command Line: {res}"
+        exe_file = pathlib.Path(f"/proc/{process_id}/exe")
+        if exe_file.exists():
+            return f"Executable: {exe_file.resolve()})"
+        return "Name Unknown"
+
+    async def validate_device(self, dev_strpath: str) -> None:
+        dev_path = pathlib.Path(dev_strpath)
+        if not dev_path.exists():
+            raise FlashError(f"No Serial Device found at {dev_path}")
+        try:
+            dev_st = dev_path.stat()
+        except PermissionError as e:
+            raise FlashError(f"No permission to access device {dev_path}") from e
+        dev_id = (dev_st.st_dev, dev_st.st_ino)
+        for fd_dir in pathlib.Path("/proc").glob("*/fd"):
+            pid = fd_dir.parent.name
+            if not pid.isdigit():
+                continue
+            with contextlib.suppress(OSError):
+                for item in fd_dir.iterdir():
+                    try:
+                        item_st = item.stat()
+                    except OSError:
+                        continue
+                    item_id = (item_st.st_dev, item_st.st_ino)
+                    if item_id == dev_id:
+                        proc_name = await self._lookup_proc_name(pid)
+                        output_line(
+                            f"Serial device {dev_path} in use by another program.\n"
+                            f"Process ID: {pid}\n"
+                            f"Process {proc_name}"
+                        )
+                        raise FlashError(f"Serial device {dev_path} in use")
+
     async def run(self, intf: str, baud: int, fw_path: pathlib.Path) -> None:
         if not fw_path.is_file():
-            raise FlashCanError("Invalid firmware path '%s'" % (fw_path))
-        try:
-            import serial
-        except ModuleNotFoundError:
-            raise FlashCanError(
-                "The pyserial python package was not found.  To install "
-                "run the following command in a terminal: \n\n"
-                "   pip3 install pyserial\n\n")
-        self.serial_error = serial.SerialException
+            raise FlashError("Invalid firmware path '%s'" % (fw_path))
+        await self.validate_device(intf)
         try:
-            serial_dev = serial.Serial(baudrate=baud, timeout=0,
-                                       exclusive=True)
+            serial_dev = Serial(                            # type: ignore
+                baudrate=baud, timeout=0, exclusive=True
+            )
             serial_dev.port = intf
             serial_dev.open()
-        except (OSError, IOError, self.serial_error) as e:
-            raise FlashCanError("Unable to open serial port: %s" % (e,))
+        except (OSError, IOError, SerialException) as e:
+            raise FlashError("Unable to open serial port: %s" % (e,))
         self.serial = serial_dev
         self._loop.add_reader(self.serial.fileno(), self._handle_response)
         flasher = CanFlasher(self.node, fw_path)
@@ -569,7 +637,59 @@
         self.serial.close()
         self.serial = None
 
-def main():
+async def main(args: argparse.Namespace) -> int:
+    if not args.verbose:
+        logging.getLogger().setLevel(logging.ERROR)
+    intf = args.interface
+    fpath = pathlib.Path(args.firmware).expanduser().resolve()
+    loop = asyncio.get_running_loop()
+    iscan = args.device is None
+    req_only = args.request_bootloader
+    sock: CanSocket | SerialSocket | None = None
+    try:
+        if iscan:
+            sock = CanSocket(loop)
+            if args.query:
+                await sock.run_query(intf)
+            else:
+                if args.uuid is None:
+                    raise FlashError(
+                        "The 'uuid' option must be specified to flash a device"
+                    )
+                output_line(f"Flashing CAN UUID {args.uuid} on interface {intf}")
+                uuid = int(args.uuid, 16)
+                await sock.run(intf, uuid, fpath, req_only)
+        else:
+            if not HAS_SERIAL:
+                ser_inst_cmd = "pip3 install serial"
+                if shutil.which("apt") is not None:
+                    ser_inst_cmd = "sudo apt install python3-serial"
+                raise FlashError(
+                    "The pyserial python package was not found.  To install "
+                    "run the following command in a terminal: \n\n"
+                    f"   {ser_inst_cmd}\n\n"
+                )
+            if args.device is None:
+                raise FlashError(
+                    "The 'device' option must be specified to flash a device"
+                )
+            output_line(f"Flashing Serial Device {args.device}, baud {args.baud}")
+            sock = SerialSocket(loop)
+            await sock.run(args.device, args.baud, fpath)
+    except Exception:
+        logging.exception("Flash Error")
+        return -1
+    finally:
+        if sock is not None:
+            sock.close()
+    if args.query:
+        output_line("Query Complete")
+    else:
+        output_line("Flash Success")
+    return 0
+
+
+if __name__ == '__main__':
     parser = argparse.ArgumentParser(
         description="Katapult Flash Tool")
     parser.add_argument(
@@ -606,44 +726,4 @@
     )
 
     args = parser.parse_args()
-    if not args.verbose:
-        logging.getLogger().setLevel(logging.ERROR)
-    intf = args.interface
-    fpath = pathlib.Path(args.firmware).expanduser().resolve()
-    loop = asyncio.get_event_loop()
-    iscan = args.device is None
-    req_only = args.request_bootloader
-    sock = None
-    try:
-        if iscan:
-            sock = CanSocket(loop)
-            if args.query:
-                loop.run_until_complete(sock.run_query(intf))
-            else:
-                if args.uuid is None:
-                    raise FlashCanError(
-                        "The 'uuid' option must be specified to flash a device"
-                    )
-                uuid = int(args.uuid, 16)
-                loop.run_until_complete(sock.run(intf, uuid, fpath, req_only))
-        else:
-            if args.device is None:
-                raise FlashCanError(
-                    "The 'device' option must be specified to flash a device"
-                )
-            sock = SerialSocket(loop)
-            loop.run_until_complete(sock.run(args.device, args.baud, fpath))
-    except Exception as e:
-        logging.exception("Flash Error")
-        sys.exit(-1)
-    finally:
-        if sock is not None:
-            sock.close()
-    if args.query:
-        output_line("Query Complete")
-    else:
-        output_line("Flash Success")
-
-
-if __name__ == '__main__':
-    main()
+    exit(asyncio.run(main(args)))
