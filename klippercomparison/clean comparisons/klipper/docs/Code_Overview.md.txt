Differences in docs/Code_Overview.md:

- Lines with differences: 36 lines in 3 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/docs/Code_Overview.md	2023-10-20 03:52:16.608163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/docs/Code_Overview.md	2024-10-08 17:45:26.537216179 -0400
@@ -136,8 +136,9 @@
 
 * The ToolHead class (in toolhead.py) handles "look-ahead" and tracks
   the timing of printing actions. The main codepath for a move is:
-  `ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() ->
-  Move.set_junction() -> ToolHead._process_moves()`.
+  `ToolHead.move() -> LookAheadQueue.add_move() ->
+  LookAheadQueue.flush() -> Move.set_junction() ->
+  ToolHead._process_moves()`.
   * ToolHead.move() creates a Move() object with the parameters of the
   move (in cartesian space and in units of seconds and millimeters).
   * The kinematics class is given the opportunity to audit each move
@@ -146,10 +147,10 @@
   may raise an error if the move is not valid. If check_move()
   completes successfully then the underlying kinematics must be able
   to handle the move.
-  * MoveQueue.add_move() places the move object on the "look-ahead"
-  queue.
-  * MoveQueue.flush() determines the start and end velocities of each
-  move.
+  * LookAheadQueue.add_move() places the move object on the
+  "look-ahead" queue.
+  * LookAheadQueue.flush() determines the start and end velocities of
+  each move.
   * Move.set_junction() implements the "trapezoid generator" on a
   move. The "trapezoid generator" breaks every move into three parts:
   a constant acceleration phase, followed by a constant velocity
@@ -170,17 +171,18 @@
   placed on a "trapezoid motion queue": `ToolHead._process_moves() ->
   trapq_append()` (in klippy/chelper/trapq.c). The step times are then
   generated: `ToolHead._process_moves() ->
-  ToolHead._update_move_time() -> MCU_Stepper.generate_steps() ->
-  itersolve_generate_steps() -> itersolve_gen_steps_range()` (in
-  klippy/chelper/itersolve.c). The goal of the iterative solver is to
-  find step times given a function that calculates a stepper position
-  from a time. This is done by repeatedly "guessing" various times
-  until the stepper position formula returns the desired position of
-  the next step on the stepper. The feedback produced from each guess
-  is used to improve future guesses so that the process rapidly
-  converges to the desired time. The kinematic stepper position
-  formulas are located in the klippy/chelper/ directory (eg,
-  kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c).
+  ToolHead._advance_move_time() -> ToolHead._advance_flush_time() ->
+  MCU_Stepper.generate_steps() -> itersolve_generate_steps() ->
+  itersolve_gen_steps_range()` (in klippy/chelper/itersolve.c). The
+  goal of the iterative solver is to find step times given a function
+  that calculates a stepper position from a time. This is done by
+  repeatedly "guessing" various times until the stepper position
+  formula returns the desired position of the next step on the
+  stepper. The feedback produced from each guess is used to improve
+  future guesses so that the process rapidly converges to the desired
+  time. The kinematic stepper position formulas are located in the
+  klippy/chelper/ directory (eg, kin_cart.c, kin_corexy.c,
+  kin_delta.c, kin_extruder.c).
 
 * Note that the extruder is handled in its own kinematic class:
   `ToolHead._process_moves() -> PrinterExtruder.move()`. Since
