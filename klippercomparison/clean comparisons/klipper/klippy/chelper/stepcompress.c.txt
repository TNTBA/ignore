Differences in klippy/chelper/stepcompress.c:

- Lines with differences: 37 lines in 7 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/chelper/stepcompress.c	2023-10-20 03:52:16.748163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/chelper/stepcompress.c	2024-10-08 17:45:26.556216248 -0400
@@ -54,8 +54,6 @@
     int16_t add;
 };
 
-#define HISTORY_EXPIRE (30.0)
-
 struct history_steps {
     struct list_node node;
     uint64_t first_clock, last_clock;
@@ -292,6 +290,13 @@
     }
 }
 
+// Expire the stepcompress history older than the given clock
+static void
+stepcompress_history_expire(struct stepcompress *sc, uint64_t end_clock)
+{
+    free_history(sc, end_clock);
+}
+
 // Free memory associated with a 'stepcompress' object
 void __visible
 stepcompress_free(struct stepcompress *sc)
@@ -322,9 +327,6 @@
 {
     double lsc = sc->last_step_clock;
     sc->last_step_print_time = sc->mcu_time_offset + (lsc - .5) / sc->mcu_freq;
-
-    if (lsc > sc->mcu_freq * HISTORY_EXPIRE)
-        free_history(sc, lsc - sc->mcu_freq * HISTORY_EXPIRE);
 }
 
 // Set the conversion rate of 'print_time' to mcu clock
@@ -623,6 +625,21 @@
     return 0;
 }
 
+// Queue an mcu command that will consume space in the mcu move queue
+int __visible
+stepcompress_queue_mq_msg(struct stepcompress *sc, uint64_t req_clock
+                          , uint32_t *data, int len)
+{
+    int ret = stepcompress_flush(sc, UINT64_MAX);
+    if (ret)
+        return ret;
+
+    struct queue_message *qm = message_alloc_and_encode(data, len);
+    qm->min_clock = qm->req_clock = req_clock;
+    list_add_tail(&qm->node, &sc->msg_queue);
+    return 0;
+}
+
 // Return history of queue_step commands
 int __visible
 stepcompress_extract_old(struct stepcompress *sc, struct pull_history_steps *p
@@ -716,6 +733,18 @@
     }
 }
 
+// Expire the stepcompress history before the given clock time
+static void
+steppersync_history_expire(struct steppersync *ss, uint64_t end_clock)
+{
+    int i;
+    for (i = 0; i < ss->sc_num; i++)
+    {
+        struct stepcompress *sc = ss->sc_list[i];
+        stepcompress_history_expire(sc, end_clock);
+    }
+}
+
 // Implement a binary heap algorithm to track when the next available
 // 'struct move' in the mcu will be available
 static void
@@ -743,7 +772,8 @@
 
 // Find and transmit any scheduled steps prior to the given 'move_clock'
 int __visible
-steppersync_flush(struct steppersync *ss, uint64_t move_clock)
+steppersync_flush(struct steppersync *ss, uint64_t move_clock
+                  , uint64_t clear_history_clock)
 {
     // Flush each stepcompress to the specified move_clock
     int i;
@@ -791,5 +821,7 @@
     // Transmit commands
     if (!list_empty(&msgs))
         serialqueue_send_batch(ss->sq, ss->cq, &msgs);
+
+    steppersync_history_expire(ss, clear_history_clock);
     return 0;
 }
