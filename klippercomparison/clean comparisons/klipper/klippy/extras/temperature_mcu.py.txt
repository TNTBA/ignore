Differences in klippy/extras/temperature_mcu.py:

- Lines with differences: 35 lines in 3 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/extras/temperature_mcu.py	2023-10-20 03:52:16.800163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/extras/temperature_mcu.py	2024-10-08 17:45:26.570216299 -0400
@@ -1,10 +1,11 @@
 # Support for micro-controller chip based temperature sensors
 #
-# Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
+# Copyright (C) 2020-2024  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging
 import mcu
+from . import adc_temperature
 
 SAMPLE_TIME = 0.001
 SAMPLE_COUNT = 8
@@ -31,30 +32,33 @@
         self.mcu_adc = ppins.setup_pin('adc',
                                        '%s:ADC_TEMPERATURE' % (mcu_name,))
         self.mcu_adc.setup_adc_callback(REPORT_TIME, self.adc_callback)
-        query_adc = config.get_printer().load_object(config, 'query_adc')
-        query_adc.register_adc(config.get_name(), self.mcu_adc)
+        self.diag_helper = adc_temperature.HelperTemperatureDiagnostics(
+            config, self.mcu_adc, self.calc_temp)
         # Register callbacks
         if self.printer.get_start_args().get('debugoutput') is not None:
-            self.mcu_adc.setup_minmax(SAMPLE_TIME, SAMPLE_COUNT,
-                                      range_check_count=RANGE_CHECK_COUNT)
+            self.mcu_adc.setup_adc_sample(SAMPLE_TIME, SAMPLE_COUNT)
             return
         self.printer.register_event_handler("klippy:mcu_identify",
-                                            self._mcu_identify)
+                                            self.handle_mcu_identify)
+    # Temperature interface
     def setup_callback(self, temperature_callback):
         self.temperature_callback = temperature_callback
     def get_report_time_delta(self):
         return REPORT_TIME
-    def adc_callback(self, read_time, read_value):
-        temp = self.base_temperature + read_value * self.slope
-        self.temperature_callback(read_time + SAMPLE_COUNT * SAMPLE_TIME, temp)
     def setup_minmax(self, min_temp, max_temp):
         self.min_temp = min_temp
         self.max_temp = max_temp
+    # Internal code
+    def adc_callback(self, read_time, read_value):
+        temp = self.base_temperature + read_value * self.slope
+        self.temperature_callback(read_time + SAMPLE_COUNT * SAMPLE_TIME, temp)
+    def calc_temp(self, adc):
+        return self.base_temperature + adc * self.slope
     def calc_adc(self, temp):
         return (temp - self.base_temperature) / self.slope
     def calc_base(self, temp, adc):
         return temp - adc * self.slope
-    def _mcu_identify(self):
+    def handle_mcu_identify(self):
         # Obtain mcu information
         mcu = self.mcu_adc.get_mcu()
         self.debug_read_cmd = mcu.lookup_query_command(
@@ -89,10 +93,13 @@
                 self.slope = (self.temp2 - self.temp1) / (self.adc2 - self.adc1)
             self.base_temperature = self.calc_base(self.temp1, self.adc1)
         # Setup min/max checks
-        adc_range = [self.calc_adc(t) for t in [self.min_temp, self.max_temp]]
-        self.mcu_adc.setup_minmax(SAMPLE_TIME, SAMPLE_COUNT,
-                                  minval=min(adc_range), maxval=max(adc_range),
-                                  range_check_count=RANGE_CHECK_COUNT)
+        arange = [self.calc_adc(t) for t in [self.min_temp, self.max_temp]]
+        min_adc, max_adc = sorted(arange)
+        self.mcu_adc.setup_adc_sample(SAMPLE_TIME, SAMPLE_COUNT,
+                                      minval=min_adc, maxval=max_adc,
+                                      range_check_count=RANGE_CHECK_COUNT)
+        self.diag_helper.setup_diag_minmax(self.min_temp, self.max_temp,
+                                           min_adc, max_adc)
     def config_unknown(self):
         raise self.printer.config_error("MCU temperature not supported on %s"
                                         % (self.mcu_type,))
