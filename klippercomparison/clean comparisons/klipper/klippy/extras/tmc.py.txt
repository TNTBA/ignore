Differences in klippy/extras/tmc.py:

- Lines with differences: 90 lines in 10 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/extras/tmc.py	2023-10-20 03:52:16.800163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/extras/tmc.py	2024-10-08 17:45:26.571216303 -0400
@@ -262,7 +262,8 @@
                                    desc=self.cmd_SET_TMC_CURRENT_help)
     def _init_registers(self, print_time=None):
         # Send registers
-        for reg_name, val in self.fields.registers.items():
+        for reg_name in list(self.fields.registers.keys()):
+            val = self.fields.registers[reg_name] # Val may change during loop
             self.mcu_tmc.set_register(reg_name, val, print_time)
     cmd_INIT_TMC_help = "Initialize TMC stepper driver registers"
     def cmd_INIT_TMC(self, gcmd):
@@ -277,16 +278,14 @@
             raise gcmd.error("Unknown field name '%s'" % (field_name,))
         value = gcmd.get_int('VALUE', None)
         velocity = gcmd.get_float('VELOCITY', None, minval=0.)
-        tmc_frequency = self.mcu_tmc.get_tmc_frequency()
-        if tmc_frequency is None and velocity is not None:
-            raise gcmd.error("VELOCITY parameter not supported by this driver")
         if (value is None) == (velocity is None):
             raise gcmd.error("Specify either VALUE or VELOCITY")
         if velocity is not None:
-            step_dist = self.stepper.get_step_dist()
-            mres = self.fields.get_field("mres")
-            value = TMCtstepHelper(step_dist, mres, tmc_frequency,
-                                   velocity)
+            if self.mcu_tmc.get_tmc_frequency() is None:
+                raise gcmd.error(
+                    "VELOCITY parameter not supported by this driver")
+            value = TMCtstepHelper(self.mcu_tmc, velocity,
+                                   pstepper=self.stepper)
         reg_val = self.fields.set_field(field_name, value)
         print_time = self.printer.lookup_object('toolhead').get_last_move_time()
         self.mcu_tmc.set_register(reg_name, reg_val, print_time)
@@ -480,7 +479,7 @@
             self.diag_pin_field = None
         self.mcu_endstop = None
         self.en_pwm = False
-        self.pwmthrs = self.coolthrs = 0
+        self.pwmthrs = self.coolthrs = self.thigh = 0
         # Register virtual_endstop pin
         name_parts = config.get_name().split()
         ppins = self.printer.lookup_object("pins")
@@ -504,8 +503,8 @@
     def handle_homing_move_begin(self, hmove):
         if self.mcu_endstop not in hmove.get_mcu_endstops():
             return
+        # Enable/disable stealthchop
         self.pwmthrs = self.fields.get_field("tpwmthrs")
-        self.coolthrs = self.fields.get_field("tcoolthrs")
         reg = self.fields.lookup_register("en_pwm_mode", None)
         if reg is None:
             # On "stallguard4" drivers, "stealthchop" must be enabled
@@ -519,12 +518,21 @@
             self.fields.set_field("en_pwm_mode", 0)
             val = self.fields.set_field(self.diag_pin_field, 1)
         self.mcu_tmc.set_register("GCONF", val)
+        # Enable tcoolthrs (if not already)
+        self.coolthrs = self.fields.get_field("tcoolthrs")
         if self.coolthrs == 0:
             tc_val = self.fields.set_field("tcoolthrs", 0xfffff)
             self.mcu_tmc.set_register("TCOOLTHRS", tc_val)
+        # Disable thigh
+        reg = self.fields.lookup_register("thigh", None)
+        if reg is not None:
+            self.thigh = self.fields.get_field("thigh")
+            th_val = self.fields.set_field("thigh", 0)
+            self.mcu_tmc.set_register(reg, th_val)
     def handle_homing_move_end(self, hmove):
         if self.mcu_endstop not in hmove.get_mcu_endstops():
             return
+        # Restore stealthchop/spreadcycle
         reg = self.fields.lookup_register("en_pwm_mode", None)
         if reg is None:
             tp_val = self.fields.set_field("tpwmthrs", self.pwmthrs)
@@ -534,8 +542,14 @@
             self.fields.set_field("en_pwm_mode", self.en_pwm)
             val = self.fields.set_field(self.diag_pin_field, 0)
         self.mcu_tmc.set_register("GCONF", val)
+        # Restore tcoolthrs
         tc_val = self.fields.set_field("tcoolthrs", self.coolthrs)
         self.mcu_tmc.set_register("TCOOLTHRS", tc_val)
+        # Restore thigh
+        reg = self.fields.lookup_register("thigh", None)
+        if reg is not None:
+            th_val = self.fields.set_field("thigh", self.thigh)
+            self.mcu_tmc.set_register(reg, th_val)
 
 
 ######################################################################
@@ -563,7 +577,7 @@
     set_config_field(config, "start_sin", 0)
     set_config_field(config, "start_sin90", 247)
 
-# Helper to configure and query the microstep settings
+# Helper to configure the microstep settings
 def TMCMicrostepHelper(config, mcu_tmc):
     fields = mcu_tmc.get_fields()
     stepper_name = " ".join(config.get_name().split()[1:])
@@ -571,27 +585,31 @@
         raise config.error(
             "Could not find config section '[%s]' required by tmc driver"
             % (stepper_name,))
-    stepper_config = ms_config = config.getsection(stepper_name)
-    if (stepper_config.get('microsteps', None, note_valid=False) is None
-        and config.get('microsteps', None, note_valid=False) is not None):
-        # Older config format with microsteps in tmc config section
-        ms_config = config
+    sconfig = config.getsection(stepper_name)
     steps = {256: 0, 128: 1, 64: 2, 32: 3, 16: 4, 8: 5, 4: 6, 2: 7, 1: 8}
-    mres = ms_config.getchoice('microsteps', steps)
+    mres = sconfig.getchoice('microsteps', steps)
     fields.set_field("mres", mres)
     fields.set_field("intpol", config.getboolean("interpolate", True))
 
 # Helper for calculating TSTEP based values from velocity
-def TMCtstepHelper(step_dist, mres, tmc_freq, velocity):
-    if velocity > 0.:
-        step_dist_256 = step_dist / (1 << mres)
-        threshold = int(tmc_freq * step_dist_256 / velocity + .5)
-        return max(0, min(0xfffff, threshold))
-    else:
+def TMCtstepHelper(mcu_tmc, velocity, pstepper=None, config=None):
+    if velocity <= 0.:
         return 0xfffff
+    if pstepper is not None:
+        step_dist = pstepper.get_step_dist()
+    else:
+        stepper_name = " ".join(config.get_name().split()[1:])
+        sconfig = config.getsection(stepper_name)
+        rotation_dist, steps_per_rotation = stepper.parse_step_distance(sconfig)
+        step_dist = rotation_dist / steps_per_rotation
+    mres = mcu_tmc.get_fields().get_field("mres")
+    step_dist_256 = step_dist / (1 << mres)
+    tmc_freq = mcu_tmc.get_tmc_frequency()
+    threshold = int(tmc_freq * step_dist_256 / velocity + .5)
+    return max(0, min(0xfffff, threshold))
 
 # Helper to configure stealthChop-spreadCycle transition velocity
-def TMCStealthchopHelper(config, mcu_tmc, tmc_freq):
+def TMCStealthchopHelper(config, mcu_tmc):
     fields = mcu_tmc.get_fields()
     en_pwm_mode = False
     velocity = config.getfloat('stealthchop_threshold', None, minval=0.)
@@ -599,13 +617,7 @@
 
     if velocity is not None:
         en_pwm_mode = True
-
-        stepper_name = " ".join(config.get_name().split()[1:])
-        sconfig = config.getsection(stepper_name)
-        rotation_dist, steps_per_rotation = stepper.parse_step_distance(sconfig)
-        step_dist = rotation_dist / steps_per_rotation
-        mres = fields.get_field("mres")
-        tpwmthrs = TMCtstepHelper(step_dist, mres, tmc_freq, velocity)
+        tpwmthrs = TMCtstepHelper(mcu_tmc, velocity, config=config)
     fields.set_field("tpwmthrs", tpwmthrs)
 
     reg = fields.lookup_register("en_pwm_mode", None)
@@ -614,3 +626,22 @@
     else:
         # TMC2208 uses en_spreadCycle
         fields.set_field("en_spreadcycle", not en_pwm_mode)
+
+# Helper to configure StallGuard and CoolStep minimum velocity
+def TMCVcoolthrsHelper(config, mcu_tmc):
+    fields = mcu_tmc.get_fields()
+    velocity = config.getfloat('coolstep_threshold', None, minval=0.)
+    tcoolthrs = 0
+    if velocity is not None:
+        tcoolthrs = TMCtstepHelper(mcu_tmc, velocity, config=config)
+    fields.set_field("tcoolthrs", tcoolthrs)
+
+# Helper to configure StallGuard and CoolStep maximum velocity and
+# SpreadCycle-FullStepping (High velocity) mode threshold.
+def TMCVhighHelper(config, mcu_tmc):
+    fields = mcu_tmc.get_fields()
+    velocity = config.getfloat('high_velocity_threshold', None, minval=0.)
+    thigh = 0
+    if velocity is not None:
+        thigh = TMCtstepHelper(mcu_tmc, velocity, config=config)
+    fields.set_field("thigh", thigh)
