Differences in klippy/kinematics/idex_modes.py:

- Lines with differences: 49 lines in 6 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/kinematics/idex_modes.py	2023-10-20 03:52:16.812163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/kinematics/idex_modes.py	2024-10-08 17:45:26.572216307 -0400
@@ -4,7 +4,7 @@
 # Copyright (C) 2023  Dmitry Butyugin <dmbutyugin@google.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import math
+import logging, math
 import chelper
 
 INACTIVE = 'INACTIVE'
@@ -42,7 +42,12 @@
                    desc=self.cmd_RESTORE_DUAL_CARRIAGE_STATE_help)
     def get_rails(self):
         return self.dc
-    def toggle_active_dc_rail(self, index, override_rail=False):
+    def get_primary_rail(self):
+        for rail in self.dc:
+            if rail.mode == PRIMARY:
+                return rail
+        return None
+    def toggle_active_dc_rail(self, index):
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.flush_step_generation()
         pos = toolhead.get_position()
@@ -52,15 +57,11 @@
             if i != index:
                 if dc.is_active():
                     dc.inactivate(pos)
-                if override_rail:
-                    kin.override_rail(3, dc_rail)
         target_dc = self.dc[index]
         if target_dc.mode != PRIMARY:
             newpos = pos[:self.axis] + [target_dc.get_axis_position(pos)] \
                         + pos[self.axis+1:]
             target_dc.activate(PRIMARY, newpos, old_position=pos)
-            if override_rail:
-                kin.override_rail(self.axis, target_dc.get_rail())
             toolhead.set_position(newpos)
         kin.update_limits(self.axis, target_dc.get_rail().get_range())
     def home(self, homing_state):
@@ -72,10 +73,10 @@
             # the same direction and the first carriage homes on the second one
             enumerated_dcs.reverse()
         for i, dc_rail in enumerated_dcs:
-            self.toggle_active_dc_rail(i, override_rail=True)
+            self.toggle_active_dc_rail(i)
             kin.home_axis(homing_state, self.axis, dc_rail.get_rail())
         # Restore the original rails ordering
-        self.toggle_active_dc_rail(0, override_rail=True)
+        self.toggle_active_dc_rail(0)
     def get_status(self, eventtime=None):
         return {('carriage_%d' % (i,)) : dc.mode
                 for (i, dc) in enumerate(self.dc)}
@@ -201,14 +202,31 @@
         move_speed = gcmd.get_float('MOVE_SPEED', 0., above=0.)
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.flush_step_generation()
-        pos = toolhead.get_position()
         if gcmd.get_int('MOVE', 1):
+            homing_speed = 99999999.
+            cur_pos = []
             for i, dc in enumerate(self.dc):
                 self.toggle_active_dc_rail(i)
-                saved_pos = saved_state['axes_positions'][i]
-                toolhead.manual_move(
-                        pos[:self.axis] + [saved_pos] + pos[self.axis+1:],
-                        move_speed or dc.get_rail().homing_speed)
+                homing_speed = min(homing_speed, dc.get_rail().homing_speed)
+                cur_pos.append(toolhead.get_position())
+            move_pos = list(cur_pos[0])
+            dl = [saved_state['axes_positions'][i] - cur_pos[i][self.axis]
+                  for i in range(2)]
+            primary_ind = 0 if abs(dl[0]) >= abs(dl[1]) else 1
+            self.toggle_active_dc_rail(primary_ind)
+            move_pos[self.axis] = saved_state['axes_positions'][primary_ind]
+            dc_mode = INACTIVE if min(abs(dl[0]), abs(dl[1])) < 0.000000001 \
+                    else COPY if dl[0] * dl[1] > 0 else MIRROR
+            if dc_mode != INACTIVE:
+                self.dc[1-primary_ind].activate(dc_mode, cur_pos[primary_ind])
+                self.dc[1-primary_ind].override_axis_scaling(
+                        abs(dl[1-primary_ind] / dl[primary_ind]),
+                        cur_pos[primary_ind])
+            toolhead.manual_move(move_pos, move_speed or homing_speed)
+            toolhead.flush_step_generation()
+            # Make sure the scaling coefficients are restored with the mode
+            self.dc[0].inactivate(move_pos)
+            self.dc[1].inactivate(move_pos)
         for i, dc in enumerate(self.dc):
             saved_mode = saved_state['carriage_modes'][i]
             self.activate_dc_mode(i, saved_mode)
@@ -256,3 +274,8 @@
         self.scale = 0.
         self.apply_transform()
         self.mode = INACTIVE
+    def override_axis_scaling(self, new_scale, position):
+        old_axis_position = self.get_axis_position(position)
+        self.scale = math.copysign(new_scale, self.scale)
+        self.offset = old_axis_position - position[self.axis] * self.scale
+        self.apply_transform()
