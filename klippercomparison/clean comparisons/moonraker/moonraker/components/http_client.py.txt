Differences in moonraker/components/http_client.py:

- Lines with differences: 116 lines in 10 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/http_client.py	2022-07-25 05:53:30.902869287 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/http_client.py	2024-10-08 17:45:43.665278020 -0400
@@ -6,14 +6,15 @@
 
 from __future__ import annotations
 import re
-import json
 import time
 import asyncio
 import pathlib
 import tempfile
 import logging
-from utils import ServerError
-from tornado.escape import url_escape, url_unescape
+import copy
+from ..utils import ServerError
+from ..utils import json_wrapper as jsonw
+from tornado.escape import url_unescape
 from tornado.httpclient import AsyncHTTPClient, HTTPRequest, HTTPError
 from tornado.httputil import HTTPHeaders
 from typing import (
@@ -27,8 +28,8 @@
     Any
 )
 if TYPE_CHECKING:
-    from moonraker import Server
-    from confighelper import ConfigHelper
+    from ..server import Server
+    from ..confighelper import ConfigHelper
     from io import BufferedWriter
     StrOrPath = Union[str, pathlib.Path]
 
@@ -40,18 +41,6 @@
 
 GITHUB_PREFIX = "https://api.github.com/"
 
-def escape_query_string(qs: str) -> str:
-    parts = qs.split("&")
-    escaped: List[str] = []
-    for p in parts:
-        item = p.split("=", 1)
-        key = url_escape(item[0])
-        if len(item) == 2:
-            escaped.append(f"{key}={url_escape(item[1])}")
-        else:
-            escaped.append(key)
-    return "&".join(escaped)
-
 class HttpClient:
     def __init__(self, config: ConfigHelper) -> None:
         self.server = config.get_server()
@@ -76,29 +65,14 @@
         if len(headers) == 0:
             raise self.server.error(
                 "Either an Etag or Last Modified Date must be specified")
-        empty_resp = HttpResponse(url, 200, b"", headers, None)
+        empty_resp = HttpResponse(url, url, 200, b"", headers, None)
         self.response_cache[url] = empty_resp
 
-    def escape_url(self, url: str) -> str:
-        # escape the url
-        match = re.match(r"(https?://[^/?#]+)([^?#]+)?(\?[^#]+)?(#.+)?", url)
-        if match is not None:
-            uri, path, qs, fragment = match.groups()
-            if path is not None:
-                uri += "/".join([url_escape(p, plus=False)
-                                 for p in path.split("/")])
-            if qs is not None:
-                uri += "?" + escape_query_string(qs[1:])
-            if fragment is not None:
-                uri += "#" + url_escape(fragment[1:], plus=False)
-            url = uri
-        return url
-
     async def request(
         self,
         method: str,
         url: str,
-        body: Optional[Union[str, List[Any], Dict[str, Any]]] = None,
+        body: Optional[Union[bytes, str, List[Any], Dict[str, Any]]] = None,
         headers: Optional[Dict[str, Any]] = None,
         connect_timeout: float = 5.,
         request_timeout: float = 10.,
@@ -106,14 +80,16 @@
         retry_pause_time: float = .1,
         enable_cache: bool = False,
         send_etag: bool = True,
-        send_if_modified_since: bool = True
+        send_if_modified_since: bool = True,
+        basic_auth_user: Optional[str] = None,
+        basic_auth_pass: Optional[str] = None
     ) -> HttpResponse:
         cache_key = url.split("?", 1)[0]
         method = method.upper()
         # prepare the body if required
         req_headers: Dict[str, Any] = {}
         if isinstance(body, (list, dict)):
-            body = json.dumps(body)
+            body = jsonw.dumps(body)
             req_headers["Content-Type"] = "application/json"
         cached: Optional[HttpResponse] = None
         if enable_cache:
@@ -129,9 +105,17 @@
             headers = req_headers
 
         timeout = 1 + connect_timeout + request_timeout
-        request = HTTPRequest(url, method, headers, body=body,
-                              request_timeout=request_timeout,
-                              connect_timeout=connect_timeout)
+        req_args: Dict[str, Any] = dict(
+            body=body,
+            request_timeout=request_timeout,
+            connect_timeout=connect_timeout
+        )
+        if basic_auth_user is not None:
+            assert basic_auth_pass is not None
+            req_args["auth_username"] = basic_auth_user
+            req_args["auth_password"] = basic_auth_pass
+            req_args["auth_mode"] = "basic"
+        request = HTTPRequest(url, method, headers, **req_args)
         err: Optional[BaseException] = None
         for i in range(attempts):
             if i:
@@ -160,10 +144,13 @@
                     continue
                 else:
                     result = resp.body
-                ret = HttpResponse(url, resp.code, result, resp.headers, err)
+                ret = HttpResponse(
+                    url, resp.effective_url, resp.code, result,
+                    resp.headers, err
+                )
                 break
         else:
-            ret = HttpResponse(url, 500, b"", HTTPHeaders(), err)
+            ret = HttpResponse(url, url, 500, b"", HTTPHeaders(), err)
         if enable_cache and ret.is_cachable():
             logging.debug(f"Caching HTTP Response: {url}")
             self.response_cache[cache_key] = ret
@@ -291,18 +278,70 @@
                 return dl.dest_file
         raise self.server.error(f"Retries exceeded for request: {url}")
 
+    def wrap_request(self, default_url: str, **kwargs) -> HttpRequestWrapper:
+        return HttpRequestWrapper(self, default_url, **kwargs)
+
     def close(self):
         self.client.close()
 
+class HttpRequestWrapper:
+    def __init__(
+        self, client: HttpClient, default_url: str, **kwargs
+    ) -> None:
+        self._do_request = client.request
+        self._last_response: Optional[HttpResponse] = None
+        self.default_request_args: Dict[str, Any] = {
+            "method": "GET",
+            "url": default_url,
+        }
+        self.default_request_args.update(kwargs)
+        self.request_args = copy.deepcopy(self.default_request_args)
+        self.reset()
+
+    async def send(self, **kwargs) -> HttpResponse:
+        req_args = copy.deepcopy(self.request_args)
+        req_args.update(kwargs)
+        method = req_args.pop("method", self.default_request_args["method"])
+        url = req_args.pop("url", self.default_request_args["url"])
+        self._last_response = await self._do_request(method, url, **req_args)
+        return self._last_response
+
+    def set_method(self, method: str) -> None:
+        self.request_args["method"] = method
+
+    def set_url(self, url: str) -> None:
+        self.request_args["url"] = url
+
+    def set_body(
+        self, body: Optional[Union[str, List[Any], Dict[str, Any]]]
+    ) -> None:
+        self.request_args["body"] = body
+
+    def add_header(self, name: str, value: str) -> None:
+        headers = self.request_args.get("headers", {})
+        headers[name] = value
+        self.request_args["headers"] = headers
+
+    def set_headers(self, headers: Dict[str, str]) -> None:
+        self.request_args["headers"] = headers
+
+    def reset(self) -> None:
+        self.request_args = copy.deepcopy(self.default_request_args)
+
+    def last_response(self) -> Optional[HttpResponse]:
+        return self._last_response
+
 class HttpResponse:
     def __init__(self,
                  url: str,
+                 final_url: str,
                  code: int,
                  result: bytes,
                  response_headers: HTTPHeaders,
                  error: Optional[BaseException]
                  ) -> None:
         self._url = url
+        self._final_url = final_url
         self._code = code
         self._result: bytes = result
         self._encoding: str = "utf-8"
@@ -312,8 +351,8 @@
         self._last_modified: Optional[str] = response_headers.get(
             "last-modified", None)
 
-    def json(self, **kwargs) -> Union[List[Any], Dict[str, Any]]:
-        return json.loads(self._result, **kwargs)
+    def json(self) -> Union[List[Any], Dict[str, Any]]:
+        return jsonw.loads(self._result)
 
     def is_cachable(self) -> bool:
         return self._last_modified is not None or self._etag is not None
@@ -354,6 +393,10 @@
         return self._url
 
     @property
+    def final_url(self) -> str:
+        return self._final_url
+
+    @property
     def status_code(self) -> int:
         return self._code
 
