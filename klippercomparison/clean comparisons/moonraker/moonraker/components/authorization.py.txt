Differences in moonraker/components/authorization.py:

- Lines with differences: 630 lines in 22 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/authorization.py	2022-07-25 05:53:30.894869266 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/authorization.py	2024-10-08 17:45:43.662278009 -0400
@@ -17,16 +17,16 @@
 import re
 import socket
 import logging
-import json
 from tornado.web import HTTPError
 from libnacl.sign import Signer, Verifier
+from ..utils import json_wrapper as jsonw
+from ..common import RequestType, TransportType, SqlTableDefinition, UserInfo
 
 # Annotation imports
 from typing import (
     TYPE_CHECKING,
     Any,
     Tuple,
-    Set,
     Optional,
     Union,
     Dict,
@@ -34,15 +34,16 @@
 )
 
 if TYPE_CHECKING:
-    from confighelper import ConfigHelper
-    from websockets import WebRequest
+    from ..confighelper import ConfigHelper
+    from ..common import WebRequest
+    from .websockets import WebsocketManager
     from tornado.httputil import HTTPServerRequest
-    from tornado.web import RequestHandler
     from .database import MoonrakerDatabase as DBComp
+    from .database import DBProviderWrapper
     from .ldap import MoonrakerLDAP
     IPAddr = Union[ipaddress.IPv4Address, ipaddress.IPv6Address]
     IPNetwork = Union[ipaddress.IPv4Network, ipaddress.IPv6Network]
-    OneshotToken = Tuple[IPAddr, Optional[Dict[str, Any]], asyncio.Handle]
+    OneshotToken = Tuple[IPAddr, Optional[UserInfo], asyncio.Handle]
 
 # Helpers for base64url encoding and decoding
 def base64url_encode(data: bytes) -> bytes:
@@ -57,8 +58,10 @@
 
 ONESHOT_TIMEOUT = 5
 TRUSTED_CONNECTION_TIMEOUT = 3600
+FQDN_CACHE_TIMEOUT = 84000
 PRUNE_CHECK_TIME = 300.
 
+USER_TABLE = "authorized_users"
 AUTH_SOURCES = ["moonraker", "ldap"]
 HASH_ITER = 100000
 API_USER = "_API_KEY_USER_"
@@ -70,17 +73,71 @@
     'typ': "JWT"
 }
 
+class UserSqlDefinition(SqlTableDefinition):
+    name = USER_TABLE
+    prototype = (
+        f"""
+        {USER_TABLE} (
+            username TEXT PRIMARY KEY NOT NULL,
+            password TEXT NOT NULL,
+            created_on REAL NOT NULL,
+            salt TEXT NOT NULL,
+            source TEXT NOT NULL,
+            jwt_secret TEXT,
+            jwk_id TEXT,
+            groups pyjson
+        )
+        """
+    )
+    version = 1
+
+    def migrate(self, last_version: int, db_provider: DBProviderWrapper) -> None:
+        if last_version == 0:
+            users: Dict[str, Dict[str, Any]]
+            users = db_provider.get_namespace("authorized_users")
+            api_user = users.pop(API_USER, {})
+            if not isinstance(api_user, dict):
+                api_user = {}
+            user_vals: List[Tuple[Any, ...]] = [
+                UserInfo(
+                    username=API_USER,
+                    password=api_user.get("api_key", uuid.uuid4().hex),
+                    created_on=api_user.get("created_on", time.time())
+                ).as_tuple()
+            ]
+            for key, user in users.items():
+                if not isinstance(user, dict):
+                    logging.info(
+                        f"Auth migration, skipping invalid value: {key} {user}"
+                    )
+                    continue
+                user_vals.append(UserInfo(**user).as_tuple())
+            placeholders = ",".join("?" * len(user_vals[0]))
+            conn = db_provider.connection
+            with conn:
+                conn.executemany(
+                    f"INSERT OR IGNORE INTO {USER_TABLE} VALUES({placeholders})",
+                    user_vals
+                )
+            db_provider.wipe_local_namespace("authorized_users")
+
 class Authorization:
     def __init__(self, config: ConfigHelper) -> None:
         self.server = config.get_server()
         self.login_timeout = config.getint('login_timeout', 90)
         self.force_logins = config.getboolean('force_logins', False)
         self.default_source = config.get('default_source', "moonraker").lower()
+        self.enable_api_key = config.getboolean('enable_api_key', True)
+        self.max_logins = config.getint("max_login_attempts", None, above=0)
+        self.failed_logins: Dict[IPAddr, int] = {}
+        self.fqdn_cache: Dict[IPAddr, Dict[str, Any]] = {}
         if self.default_source not in AUTH_SOURCES:
-            raise config.error(
+            self.server.add_warning(
                 "[authorization]: option 'default_source' - Invalid "
-                f"value '{self.default_source}'"
+                f"value '{self.default_source}', falling back to "
+                "'moonraker'."
             )
+            self.default_source = "moonraker"
         self.ldap: Optional[MoonrakerLDAP] = None
         if config.has_section("ldap"):
             self.ldap = self.server.load_component(config, "ldap", None)
@@ -90,78 +147,32 @@
                 " however [ldap] section failed to load or not configured"
             )
         database: DBComp = self.server.lookup_component('database')
-        database.register_local_namespace('authorized_users', forbidden=True)
-        self.user_db = database.wrap_namespace('authorized_users')
-        self.users: Dict[str, Dict[str, Any]] = self.user_db.as_dict()
-        api_user: Optional[Dict[str, Any]] = self.users.get(API_USER, None)
-        if api_user is None:
-            self.api_key = uuid.uuid4().hex
-            self.users[API_USER] = {
-                'username': API_USER,
-                'api_key': self.api_key,
-                'created_on': time.time()
-            }
-        else:
-            self.api_key = api_user['api_key']
+        self.user_table = database.register_table(UserSqlDefinition())
+        self.users: Dict[str, UserInfo] = {}
+        self.api_key = uuid.uuid4().hex
         hi = self.server.get_host_info()
         self.issuer = f"http://{hi['hostname']}:{hi['port']}"
         self.public_jwks: Dict[str, Dict[str, Any]] = {}
-        for username, user_info in list(self.users.items()):
-            if username == API_USER:
-                # Validate the API User
-                for item in ["username", "api_key", "created_on"]:
-                    if item not in user_info:
-                        self.users[API_USER] = {
-                            'username': API_USER,
-                            'api_key': self.api_key,
-                            'created_on': time.time()
-                        }
-                        break
-                continue
-            else:
-                # validate created users
-                valid = True
-                for item in ["username", "password", "salt", "created_on"]:
-                    if item not in user_info:
-                        logging.info(
-                            f"Authorization: User {username} does not "
-                            f"contain field {item}, removing")
-                        del self.users[username]
-                        valid = False
-                        break
-                if not valid:
-                    continue
-            # generate jwks for valid users
-            if 'jwt_secret' in user_info:
-                try:
-                    priv_key = self._load_private_key(user_info['jwt_secret'])
-                    jwk_id = user_info['jwk_id']
-                except (self.server.error, KeyError):
-                    logging.info("Invalid key found for user, removing")
-                    user_info.pop('jwt_secret', None)
-                    user_info.pop('jwk_id', None)
-                    self.users[username] = user_info
-                    continue
-                self.public_jwks[jwk_id] = self._generate_public_jwk(priv_key)
-        # sync user changes to the database
-        self.user_db.sync(self.users)
-        self.trusted_users: Dict[IPAddr, Any] = {}
+        self.trusted_users: Dict[IPAddr, Dict[str, Any]] = {}
         self.oneshot_tokens: Dict[str, OneshotToken] = {}
-        self.permitted_paths: Set[str] = set()
 
         # Get allowed cors domains
         self.cors_domains: List[str] = []
         for domain in config.getlist('cors_domains', []):
             bad_match = re.search(r"^.+\.[^:]*\*", domain)
             if bad_match is not None:
-                raise config.error(
-                    f"Unsafe CORS Domain '{domain}'.  Wildcards are not"
-                    " permitted in the top level domain.")
+                self.server.add_warning(
+                    f"[authorization]: Unsafe domain '{domain}' in option "
+                    f"'cors_domains'. Wildcards are not permitted in the"
+                    " top level domain."
+                )
+                continue
             if domain.endswith("/"):
                 self.server.add_warning(
                     f"[authorization]: Invalid domain '{domain}' in option "
                     "'cors_domains'.  Domain's cannot contain a trailing "
-                    "slash.")
+                    "slash."
+                )
             else:
                 self.cors_domains.append(
                     domain.replace(".", "\\.").replace("*", ".*"))
@@ -217,52 +228,117 @@
             self._prune_conn_handler)
 
         # Register Authorization Endpoints
-        self.permitted_paths.add("/server/redirect")
-        self.permitted_paths.add("/access/login")
-        self.permitted_paths.add("/access/refresh_jwt")
-        self.permitted_paths.add("/access/info")
         self.server.register_endpoint(
-            "/access/login", ['POST'], self._handle_login,
-            transports=['http'])
+            "/access/login", RequestType.POST, self._handle_login,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET,
+            auth_required=False
+        )
         self.server.register_endpoint(
-            "/access/logout", ['POST'], self._handle_logout,
-            transports=['http'])
+            "/access/logout", RequestType.POST, self._handle_logout,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/refresh_jwt", ['POST'], self._handle_refresh_jwt,
-            transports=['http'])
+            "/access/refresh_jwt", RequestType.POST, self._handle_refresh_jwt,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET,
+            auth_required=False
+        )
         self.server.register_endpoint(
-            "/access/user", ['GET', 'POST', 'DELETE'],
-            self._handle_user_request, transports=['http'])
+            "/access/user", RequestType.all(), self._handle_user_request,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/users/list", ['GET'], self._handle_list_request,
-            transports=['http'])
+            "/access/users/list", RequestType.GET, self._handle_list_request,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/user/password", ['POST'], self._handle_password_reset,
-            transports=['http'])
+            "/access/user/password", RequestType.POST, self._handle_password_reset,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/api_key", ['GET', 'POST'],
-            self._handle_apikey_request, transports=['http'])
+            "/access/api_key", RequestType.GET | RequestType.POST,
+            self._handle_apikey_request,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/oneshot_token", ['GET'],
-            self._handle_oneshot_request, transports=['http'])
+            "/access/oneshot_token", RequestType.GET, self._handle_oneshot_request,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET
+        )
         self.server.register_endpoint(
-            "/access/info", ['GET'],
-            self._handle_info_request, transports=['http'])
-        self.server.register_notification("authorization:user_created")
-        self.server.register_notification("authorization:user_deleted")
-
-    def _sync_user(self, username: str) -> None:
-        self.user_db[username] = self.users[username]
+            "/access/info", RequestType.GET, self._handle_info_request,
+            transports=TransportType.HTTP | TransportType.WEBSOCKET,
+            auth_required=False
+        )
+        wsm: WebsocketManager = self.server.lookup_component("websockets")
+        wsm.register_notification("authorization:user_created")
+        wsm.register_notification(
+            "authorization:user_deleted", event_type="logout"
+        )
+        wsm.register_notification(
+            "authorization:user_logged_out", event_type="logout"
+        )
 
     async def component_init(self) -> None:
+        # Populate users from database
+        cursor = await self.user_table.execute(f"SELECT * FROM {USER_TABLE}")
+        self.users = {row[0]: UserInfo(**dict(row)) for row in await cursor.fetchall()}
+        need_sync = self._initialize_users()
+        if need_sync:
+            await self._sync_user_table()
         self.prune_timer.start(delay=PRUNE_CHECK_TIME)
 
+    async def _sync_user(self, username: str) -> None:
+        user = self.users[username]
+        vals = user.as_tuple()
+        placeholders = ",".join("?" * len(vals))
+        async with self.user_table as tx:
+            await tx.execute(
+                f"REPLACE INTO {USER_TABLE} VALUES({placeholders})", vals
+            )
+
+    async def _sync_user_table(self) -> None:
+        async with self.user_table as tx:
+            await tx.execute(f"DELETE FROM {USER_TABLE}")
+            user_vals: List[Tuple[Any, ...]]
+            user_vals = [user.as_tuple() for user in self.users.values()]
+            if not user_vals:
+                return
+            placeholders = ",".join("?" * len(user_vals[0]))
+            await tx.executemany(
+                f"INSERT INTO {USER_TABLE} VALUES({placeholders})", user_vals
+            )
+
+    def _initialize_users(self) -> bool:
+        need_sync = False
+        api_user: Optional[UserInfo] = self.users.get(API_USER, None)
+        if api_user is None:
+            need_sync = True
+            self.users[API_USER] = UserInfo(username=API_USER, password=self.api_key)
+        else:
+            self.api_key = api_user.password
+        for username, user_info in list(self.users.items()):
+            if username == API_USER:
+                continue
+            # generate jwks for valid users
+            if user_info.jwt_secret is not None:
+                try:
+                    priv_key = self._load_private_key(user_info.jwt_secret)
+                    jwk_id = user_info.jwk_id
+                    assert jwk_id is not None
+                except (self.server.error, KeyError, AssertionError):
+                    logging.info("Invalid jwk found for user, removing")
+                    user_info.jwt_secret = None
+                    user_info.jwk_id = None
+                    self.users[username] = user_info
+                    need_sync = True
+                    continue
+                self.public_jwks[jwk_id] = self._generate_public_jwk(priv_key)
+        return need_sync
+
     async def _handle_apikey_request(self, web_request: WebRequest) -> str:
-        action = web_request.get_action()
-        if action.upper() == 'POST':
+        if web_request.get_request_type() == RequestType.POST:
             self.api_key = uuid.uuid4().hex
-            self.users[API_USER]['api_key'] = self.api_key
-            self._sync_user(API_USER)
+            self.users[API_USER].password = self.api_key
+            await self._sync_user(API_USER)
         return self.api_key
 
     async def _handle_oneshot_request(self, web_request: WebRequest) -> str:
@@ -272,34 +348,65 @@
         return self.get_oneshot_token(ip, user_info)
 
     async def _handle_login(self, web_request: WebRequest) -> Dict[str, Any]:
-        return await self._login_jwt_user(web_request)
+        ip = web_request.get_ip_address()
+        if ip is not None and self.check_logins_maxed(ip):
+            raise HTTPError(
+                401, "Unauthorized, Maximum Login Attempts Reached"
+            )
+        try:
+            ret = await self._login_jwt_user(web_request)
+        except asyncio.CancelledError:
+            raise
+        except Exception:
+            if ip is not None:
+                failed = self.failed_logins.get(ip, 0)
+                self.failed_logins[ip] = failed + 1
+            raise
+        if ip is not None:
+            self.failed_logins.pop(ip, None)
+        return ret
 
     async def _handle_logout(self, web_request: WebRequest) -> Dict[str, str]:
         user_info = web_request.get_current_user()
         if user_info is None:
             raise self.server.error("No user logged in")
-        username: str = user_info['username']
+        username: str = user_info.username
         if username in RESERVED_USERS:
             raise self.server.error(
                 f"Invalid log out request for user {username}")
-        self.users[username].pop("jwt_secret", None)
-        jwk_id: str = self.users[username].pop("jwk_id", None)
-        self._sync_user(username)
-        self.public_jwks.pop(jwk_id, None)
+        jwk_id: Optional[str] = self.users[username].jwk_id
+        self.users[username].jwt_secret = None
+        self.users[username].jwk_id = None
+        if jwk_id is not None:
+            self.public_jwks.pop(jwk_id, None)
+        await self._sync_user(username)
+        eventloop = self.server.get_event_loop()
+        eventloop.delay_callback(
+            .005, self.server.send_event, "authorization:user_logged_out",
+            {'username': username}
+        )
         return {
             "username": username,
             "action": "user_logged_out"
         }
 
-    async def _handle_info_request(
-        self, web_request: WebRequest
-    ) -> Dict[str, Any]:
+    async def _handle_info_request(self, web_request: WebRequest) -> Dict[str, Any]:
         sources = ["moonraker"]
         if self.ldap is not None:
             sources.append("ldap")
+        login_req = self.force_logins and len(self.users) > 1
+        request_trusted: Optional[bool] = None
+        user = web_request.get_current_user()
+        req_ip = web_request.ip_addr
+        if user is not None and user.username == TRUSTED_USER:
+            request_trusted = True
+        elif req_ip is not None:
+            request_trusted = await self._check_authorized_ip(req_ip)
         return {
             "default_source": self.default_source,
-            "available_sources": sources
+            "available_sources": sources,
+            "login_required": login_req,
+            "trusted": request_trusted
         }
 
     async def _handle_refresh_jwt(self,
@@ -307,46 +414,46 @@
                                   ) -> Dict[str, str]:
         refresh_token: str = web_request.get_str('refresh_token')
         try:
-            user_info = self._decode_jwt(refresh_token, token_type="refresh")
+            user_info = self.decode_jwt(refresh_token, token_type="refresh")
         except Exception:
             raise self.server.error("Invalid Refresh Token", 401)
-        username: str = user_info['username']
-        if 'jwt_secret' not in user_info or "jwk_id" not in user_info:
+        username: str = user_info.username
+        if user_info.jwt_secret is None or user_info.jwk_id is None:
             raise self.server.error("User not logged in", 401)
-        private_key = self._load_private_key(user_info['jwt_secret'])
-        jwk_id: str = user_info['jwk_id']
+        private_key = self._load_private_key(user_info.jwt_secret)
+        jwk_id: str = user_info.jwk_id
         token = self._generate_jwt(username, jwk_id, private_key)
         return {
             'username': username,
             'token': token,
-            'source': user_info.get("source", "moonraker"),
+            'source': user_info.source,
             'action': 'user_jwt_refresh'
         }
 
-    async def _handle_user_request(self,
-                                   web_request: WebRequest
-                                   ) -> Dict[str, Any]:
-        action = web_request.get_action()
-        if action == "GET":
+    async def _handle_user_request(
+        self, web_request: WebRequest
+    ) -> Dict[str, Any]:
+        req_type = web_request.get_request_type()
+        if req_type == RequestType.GET:
             user = web_request.get_current_user()
             if user is None:
                 return {
-                    'username': None,
-                    'source': None,
-                    'created_on': None,
+                    "username": None,
+                    "source": None,
+                    "created_on": None,
                 }
             else:
                 return {
-                    'username': user['username'],
-                    'source': user.get("source", "moonraker"),
-                    'created_on': user.get('created_on')
+                    "username": user.username,
+                    "source": user.source,
+                    "created_on": user.created_on
                 }
-        elif action == "POST":
+        elif req_type == RequestType.POST:
             # Create User
             return await self._login_jwt_user(web_request, create=True)
-        elif action == "DELETE":
+        elif req_type == RequestType.DELETE:
             # Delete User
-            return self._delete_jwt_user(web_request)
+            return await self._delete_jwt_user(web_request)
         raise self.server.error("Invalid Request Method")
 
     async def _handle_list_request(self,
@@ -354,12 +461,12 @@
                                    ) -> Dict[str, List[Dict[str, Any]]]:
         user_list = []
         for user in self.users.values():
-            if user['username'] == API_USER:
+            if user.username == API_USER:
                 continue
             user_list.append({
-                'username': user['username'],
-                'source': user.get("source", "moonraker"),
-                'created_on': user['created_on']
+                'username': user.username,
+                'source': user.source,
+                'created_on': user.created_on
             })
         return {
             'users': user_list
@@ -373,22 +480,22 @@
         user_info = web_request.get_current_user()
         if user_info is None:
             raise self.server.error("No Current User")
-        username = user_info['username']
-        if user_info.get("source", "moonraker") == "ldap":
+        username = user_info.username
+        if user_info.source == "ldap":
             raise self.server.error(
                 f"CanÂ´t Reset password for ldap user {username}")
         if username in RESERVED_USERS:
             raise self.server.error(
                 f"Invalid Reset Request for user {username}")
-        salt = bytes.fromhex(user_info['salt'])
+        salt = bytes.fromhex(user_info.salt)
         hashed_pass = hashlib.pbkdf2_hmac(
             'sha256', password.encode(), salt, HASH_ITER).hex()
-        if hashed_pass != user_info['password']:
+        if hashed_pass != user_info.password:
             raise self.server.error("Invalid Password")
         new_hashed_pass = hashlib.pbkdf2_hmac(
             'sha256', new_pass.encode(), salt, HASH_ITER).hex()
-        self.users[username]['password'] = new_hashed_pass
-        self._sync_user(username)
+        self.users[username].password = new_hashed_pass
+        await self._sync_user(username)
         return {
             'username': username,
             'action': "user_password_reset"
@@ -404,7 +511,7 @@
         ).lower()
         if source not in AUTH_SOURCES:
             raise self.server.error(f"Invalid 'source': {source}")
-        user_info: Dict[str, Any]
+        user_info: UserInfo
         if username in RESERVED_USERS:
             raise self.server.error(
                 f"Invalid Request for user {username}")
@@ -424,15 +531,14 @@
             salt = secrets.token_bytes(32)
             hashed_pass = hashlib.pbkdf2_hmac(
                 'sha256', password.encode(), salt, HASH_ITER).hex()
-            user_info = {
-                'username': username,
-                'password': hashed_pass,
-                'salt': salt.hex(),
-                'source': source,
-                'created_on': time.time()
-            }
+            user_info = UserInfo(
+                username=username,
+                password=hashed_pass,
+                salt=salt.hex(),
+                source=source,
+            )
             self.users[username] = user_info
-            self._sync_user(username)
+            await self._sync_user(username)
             action = "user_created"
             if source == "ldap":
                 # Dont notify user created
@@ -442,66 +548,73 @@
             if username not in self.users:
                 raise self.server.error(f"Unregistered User: {username}")
             user_info = self.users[username]
-            auth_src = user_info.get("source", "moonraker")
+            auth_src = user_info.source
             if auth_src != source:
                 raise self.server.error(
                     f"Moonraker cannot authenticate user '{username}', must "
                     f"specify source '{auth_src}'", 401
                 )
-            salt = bytes.fromhex(user_info['salt'])
+            salt = bytes.fromhex(user_info.salt)
             hashed_pass = hashlib.pbkdf2_hmac(
                 'sha256', password.encode(), salt, HASH_ITER).hex()
             action = "user_logged_in"
-            if hashed_pass != user_info['password']:
+            if hashed_pass != user_info.password:
                 raise self.server.error("Invalid Password")
-        jwt_secret_hex: Optional[str] = user_info.get('jwt_secret', None)
+        jwt_secret_hex: Optional[str] = user_info.jwt_secret
         if jwt_secret_hex is None:
             private_key = Signer()
             jwk_id = base64url_encode(secrets.token_bytes()).decode()
-            user_info['jwt_secret'] = private_key.hex_seed().decode()
-            user_info['jwk_id'] = jwk_id
+            user_info.jwt_secret = private_key.hex_seed().decode()  # type: ignore
+            user_info.jwk_id = jwk_id
             self.users[username] = user_info
-            self._sync_user(username)
+            await self._sync_user(username)
             self.public_jwks[jwk_id] = self._generate_public_jwk(private_key)
         else:
             private_key = self._load_private_key(jwt_secret_hex)
-            jwk_id = user_info['jwk_id']
+            if user_info.jwk_id is None:
+                user_info.jwk_id = base64url_encode(secrets.token_bytes()).decode()
+            jwk_id = user_info.jwk_id
         token = self._generate_jwt(username, jwk_id, private_key)
         refresh_token = self._generate_jwt(
             username, jwk_id, private_key, token_type="refresh",
             exp_time=datetime.timedelta(days=self.login_timeout))
+        conn = web_request.get_client_connection()
         if create:
             event_loop = self.server.get_event_loop()
             event_loop.delay_callback(
                 .005, self.server.send_event,
                 "authorization:user_created",
                 {'username': username})
+        elif conn is not None:
+            conn.user_info = user_info
         return {
             'username': username,
             'token': token,
-            'source': user_info.get("source", "moonraker"),
+            'source': user_info.source,
             'refresh_token': refresh_token,
             'action': action
         }
 
-    def _delete_jwt_user(self, web_request: WebRequest) -> Dict[str, str]:
+    async def _delete_jwt_user(self, web_request: WebRequest) -> Dict[str, str]:
         username: str = web_request.get_str('username')
         current_user = web_request.get_current_user()
         if current_user is not None:
-            curname = current_user.get('username', None)
-            if curname is not None and curname == username:
-                raise self.server.error(
-                    f"Cannot delete logged in user {curname}")
+            curname = current_user.username
+            if curname == username:
+                raise self.server.error(f"Cannot delete logged in user {curname}")
         if username in RESERVED_USERS:
             raise self.server.error(
                 f"Invalid Request for reserved user {username}")
-        user_info: Optional[Dict[str, Any]] = self.users.get(username)
+        user_info: Optional[UserInfo] = self.users.get(username)
         if user_info is None:
             raise self.server.error(f"No registered user: {username}")
-        if 'jwk_id' in user_info:
-            self.public_jwks.pop(user_info['jwk_id'], None)
+        if user_info.jwk_id is not None:
+            self.public_jwks.pop(user_info.jwk_id, None)
         del self.users[username]
-        del self.user_db[username]
+        async with self.user_table as tx:
+            await tx.execute(
+                f"DELETE FROM {USER_TABLE} WHERE username = ?", (username,)
+            )
         event_loop = self.server.get_event_loop()
         event_loop.delay_callback(
             .005, self.server.send_event,
@@ -530,26 +643,25 @@
         }
         header = {'kid': jwk_id}
         header.update(JWT_HEADER)
-        jwt_header = base64url_encode(json.dumps(header).encode())
-        jwt_payload = base64url_encode(json.dumps(payload).encode())
+        jwt_header = base64url_encode(jsonw.dumps(header))
+        jwt_payload = base64url_encode(jsonw.dumps(payload))
         jwt_msg = b".".join([jwt_header, jwt_payload])
         sig = private_key.signature(jwt_msg)
         jwt_sig = base64url_encode(sig)
         return b".".join([jwt_msg, jwt_sig]).decode()
 
-    def _decode_jwt(self,
-                    token: str,
-                    token_type: str = "access"
-                    ) -> Dict[str, Any]:
+    def decode_jwt(
+        self, token: str, token_type: str = "access", check_exp: bool = True
+    ) -> UserInfo:
         message, sig = token.rsplit('.', maxsplit=1)
         enc_header, enc_payload = message.split('.')
-        header: Dict[str, Any] = json.loads(base64url_decode(enc_header))
+        header: Dict[str, Any] = jsonw.loads(base64url_decode(enc_header))
         sig_bytes = base64url_decode(sig)
 
         # verify header
         if header.get('typ') != "JWT" or header.get('alg') != "EdDSA":
             raise self.server.error("Invalid JWT header")
-        jwk_id = header.get('kid')
+        jwk_id: Optional[str] = header.get('kid')
         if jwk_id not in self.public_jwks:
             raise self.server.error("Invalid key ID")
 
@@ -558,7 +670,7 @@
         public_key.verify(sig_bytes + message.encode())
 
         # validate claims
-        payload: Dict[str, Any] = json.loads(base64url_decode(enc_payload))
+        payload: Dict[str, Any] = jsonw.loads(base64url_decode(enc_payload))
         if payload['token_type'] != token_type:
             raise self.server.error(
                 f"JWT Token type mismatch: Expected {token_type}, "
@@ -567,16 +679,34 @@
             raise self.server.error("Invalid JWT Issuer", 401)
         if payload['aud'] != "Moonraker":
             raise self.server.error("Invalid JWT Audience", 401)
-        if payload['exp'] < int(time.time()):
+        if check_exp and payload['exp'] < int(time.time()):
             raise self.server.error("JWT Expired", 401)
 
         # get user
-        user_info: Optional[Dict[str, Any]] = self.users.get(
+        user_info: Optional[UserInfo] = self.users.get(
             payload.get('username', ""), None)
         if user_info is None:
             raise self.server.error("Unknown user", 401)
         return user_info
 
+    def validate_jwt(self, token: str) -> UserInfo:
+        try:
+            user_info = self.decode_jwt(token)
+        except Exception as e:
+            if isinstance(e, self.server.error):
+                raise
+            raise self.server.error(
+                f"Failed to decode JWT: {e}", 401
+            ) from e
+        return user_info
+
+    def validate_api_key(self, api_key: str) -> UserInfo:
+        if not self.enable_api_key:
+            raise self.server.error("API Key authentication is disabled", 401)
+        if api_key and api_key == self.api_key:
+            return self.users[API_USER]
+        raise self.server.error("Invalid API Key", 401)
+
     def _load_private_key(self, secret: str) -> Signer:
         try:
             key = Signer(bytes.fromhex(secret))
@@ -611,17 +741,19 @@
             exp_time: float = user_info['expires_at']
             if cur_time >= exp_time:
                 self.trusted_users.pop(ip, None)
-                logging.info(
-                    f"Trusted Connection Expired, IP: {ip}")
+                logging.info(f"Trusted Connection Expired, IP: {ip}")
+        for ip, fqdn_info in list(self.fqdn_cache.items()):
+            exp_time = fqdn_info["expires_at"]
+            if cur_time >= exp_time:
+                domain: str = fqdn_info["domain"]
+                self.fqdn_cache.pop(ip, None)
+                logging.info(f"Cached FQDN Expired, IP: {ip}, domain: {domain}")
         return eventtime + PRUNE_CHECK_TIME
 
     def _oneshot_token_expire_handler(self, token):
         self.oneshot_tokens.pop(token, None)
 
-    def get_oneshot_token(self,
-                          ip_addr: IPAddr,
-                          user: Optional[Dict[str, Any]]
-                          ) -> str:
+    def get_oneshot_token(self, ip_addr: IPAddr, user: Optional[UserInfo]) -> str:
         token = base64.b32encode(os.urandom(20)).decode()
         event_loop = self.server.get_event_loop()
         hdl = event_loop.delay_callback(
@@ -629,68 +761,76 @@
         self.oneshot_tokens[token] = (ip_addr, user, hdl)
         return token
 
-    def _check_json_web_token(self,
-                              request: HTTPServerRequest
-                              ) -> Optional[Dict[str, Any]]:
+    def _check_json_web_token(
+        self, request: HTTPServerRequest, required: bool = True
+    ) -> Optional[UserInfo]:
         auth_token: Optional[str] = request.headers.get("Authorization")
         if auth_token is None:
             auth_token = request.headers.get("X-Access-Token")
             if auth_token is None:
                 qtoken = request.query_arguments.get('access_token', None)
                 if qtoken is not None:
-                    auth_token = qtoken[-1].decode()
+                    auth_token = qtoken[-1].decode(errors="ignore")
+        elif auth_token.startswith("Bearer "):
+            auth_token = auth_token[7:]
         else:
-            if auth_token.startswith("Bearer "):
-                auth_token = auth_token[7:]
-            elif auth_token.startswith("Basic "):
-                raise HTTPError(401, "Basic Auth is not supported")
-            else:
-                raise HTTPError(
-                    401, f"Invalid Authorization Header: {auth_token}")
+            return None
         if auth_token:
             try:
-                return self._decode_jwt(auth_token)
+                return self.decode_jwt(auth_token, check_exp=required)
             except Exception:
                 logging.exception(f"JWT Decode Error {auth_token}")
-                raise HTTPError(401, f"Error decoding JWT: {auth_token}")
+                raise HTTPError(401, "JWT Decode Error")
         return None
 
-    def _check_authorized_ip(self, ip: IPAddr) -> bool:
+    async def _check_authorized_ip(self, ip: IPAddr) -> bool:
         if ip in self.trusted_ips:
             return True
         for rng in self.trusted_ranges:
             if ip in rng:
                 return True
-        fqdn = socket.getfqdn(str(ip)).lower()
-        if fqdn in self.trusted_domains:
-            return True
+        if self.trusted_domains:
+            if ip in self.fqdn_cache:
+                fqdn: str = self.fqdn_cache[ip]["domain"]
+            else:
+                eventloop = self.server.get_event_loop()
+                try:
+                    fut = eventloop.run_in_thread(socket.getfqdn, str(ip))
+                    fqdn = await asyncio.wait_for(fut, 5.0)
+                except asyncio.TimeoutError:
+                    logging.info("Call to socket.getfqdn() timed out")
+                    return False
+                else:
+                    fqdn = fqdn.lower()
+                    self.fqdn_cache[ip] = {
+                        "expires_at": time.time() + FQDN_CACHE_TIMEOUT,
+                        "domain": fqdn
+                    }
+            return fqdn in self.trusted_domains
         return False
 
-    def _check_trusted_connection(self,
-                                  ip: Optional[IPAddr]
-                                  ) -> Optional[Dict[str, Any]]:
+    async def _check_trusted_connection(
+        self, ip: Optional[IPAddr]
+    ) -> Optional[UserInfo]:
         if ip is not None:
             curtime = time.time()
             exp_time = curtime + TRUSTED_CONNECTION_TIMEOUT
             if ip in self.trusted_users:
-                self.trusted_users[ip]['expires_at'] = exp_time
-                return self.trusted_users[ip]
-            elif self._check_authorized_ip(ip):
+                self.trusted_users[ip]["expires_at"] = exp_time
+                return self.trusted_users[ip]["user"]
+            elif await self._check_authorized_ip(ip):
                 logging.info(
                     f"Trusted Connection Detected, IP: {ip}")
                 self.trusted_users[ip] = {
-                    'username': TRUSTED_USER,
-                    'password': None,
-                    'created_on': curtime,
-                    'expires_at': exp_time
+                    "user": UserInfo(TRUSTED_USER, "", curtime),
+                    "expires_at": exp_time
                 }
-                return self.trusted_users[ip]
+                return self.trusted_users[ip]["user"]
         return None
 
-    def _check_oneshot_token(self,
-                             token: str,
-                             cur_ip: Optional[IPAddr]
-                             ) -> Optional[Dict[str, Any]]:
+    def _check_oneshot_token(
+        self, token: str, cur_ip: Optional[IPAddr]
+    ) -> Optional[UserInfo]:
         if token in self.oneshot_tokens:
             ip_addr, user, hdl = self.oneshot_tokens.pop(token)
             hdl.cancel()
@@ -702,17 +842,19 @@
         else:
             return None
 
-    def check_authorized(self,
-                         request: HTTPServerRequest
-                         ) -> Optional[Dict[str, Any]]:
-        if (
-            request.path in self.permitted_paths
-            or request.method == "OPTIONS"
-        ):
+    def check_logins_maxed(self, ip_addr: IPAddr) -> bool:
+        if self.max_logins is None:
+            return False
+        return self.failed_logins.get(ip_addr, 0) >= self.max_logins
+
+    async def authenticate_request(
+        self, request: HTTPServerRequest, auth_required: bool = True
+    ) -> Optional[UserInfo]:
+        if request.method == "OPTIONS":
             return None
 
         # Check JSON Web Token
-        jwt_user = self._check_json_web_token(request)
+        jwt_user = self._check_json_web_token(request, auth_required)
         if jwt_user is not None:
             return jwt_user
 
@@ -731,26 +873,29 @@
                 return ost_user
 
         # Check API Key Header
-        key: Optional[str] = request.headers.get("X-Api-Key")
-        if key and key == self.api_key:
-            return self.users[API_USER]
+        if self.enable_api_key:
+            key: Optional[str] = request.headers.get("X-Api-Key")
+            if key and key == self.api_key:
+                return self.users[API_USER]
 
-        # If the force_logins option is enabled and at least one
-        # user is created this is an unauthorized request
+        # If the force_logins option is enabled and at least one user is created
+        # then trusted user authentication is disabled
         if self.force_logins and len(self.users) > 1:
-            raise HTTPError(401, "Unauthorized")
+            if not auth_required:
+                return None
+            raise HTTPError(401, "Unauthorized, Force Logins Enabled")
 
-        # Check if IP is trusted
-        trusted_user = self._check_trusted_connection(ip)
+        # Check if IP is trusted.  If this endpoint doesn't require authentication
+        # then it is acceptable to return None
+        trusted_user = await self._check_trusted_connection(ip)
         if trusted_user is not None:
             return trusted_user
+        if not auth_required:
+            return None
 
         raise HTTPError(401, "Unauthorized")
 
-    def check_cors(self,
-                   origin: Optional[str],
-                   req_hdlr: Optional[RequestHandler] = None
-                   ) -> bool:
+    async def check_cors(self, origin: Optional[str]) -> bool:
         if origin is None or not self.cors_domains:
             return False
         for regex in self.cors_domains:
@@ -759,7 +904,6 @@
                 if match.group() == origin:
                     logging.debug(f"CORS Pattern Matched, origin: {origin} "
                                   f" | pattern: {regex}")
-                    self._set_cors_headers(origin, req_hdlr)
                     return True
                 else:
                     logging.debug(f"Partial Cors Match: {match.group()}")
@@ -774,37 +918,13 @@
                 except ValueError:
                     pass
                 else:
-                    if self._check_authorized_ip(ipaddr):
-                        logging.debug(
-                            f"Cors request matched trusted IP: {ip}")
-                        self._set_cors_headers(origin, req_hdlr)
+                    if await self._check_authorized_ip(ipaddr):
+                        logging.debug(f"Cors request matched trusted IP: {ip}")
                         return True
             logging.debug(f"No CORS match for origin: {origin}\n"
                           f"Patterns: {self.cors_domains}")
         return False
 
-    def _set_cors_headers(self,
-                          origin: str,
-                          req_hdlr: Optional[RequestHandler]
-                          ) -> None:
-        if req_hdlr is None:
-            return
-        req_hdlr.set_header("Access-Control-Allow-Origin", origin)
-        if req_hdlr.request.method == "OPTIONS":
-            req_hdlr.set_header(
-                "Access-Control-Allow-Methods",
-                "GET, POST, PUT, DELETE, OPTIONS")
-            req_hdlr.set_header(
-                "Access-Control-Allow-Headers",
-                "Origin, Accept, Content-Type, X-Requested-With, "
-                "X-CRSF-Token, Authorization, X-Access-Token, "
-                "X-Api-Key")
-            if req_hdlr.request.headers.get(
-                    "Access-Control-Request-Private-Network", None) == "true":
-                req_hdlr.set_header(
-                    "Access-Control-Allow-Private-Network",
-                    "true")
-
     def cors_enabled(self) -> bool:
         return self.cors_domains is not None
 
