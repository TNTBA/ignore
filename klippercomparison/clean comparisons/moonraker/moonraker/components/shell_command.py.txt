Differences in moonraker/components/shell_command.py:

- Lines with differences: 247 lines in 12 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/shell_command.py	2022-07-25 05:53:30.910869307 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/shell_command.py	2024-10-08 17:45:43.667278026 -0400
@@ -10,7 +10,7 @@
 import logging
 import signal
 import asyncio
-from utils import ServerError
+from ..utils import ServerError
 
 # Annotation imports
 from typing import (
@@ -22,47 +22,48 @@
     Coroutine,
     Dict,
     Set,
+    cast
 )
 if TYPE_CHECKING:
-    from confighelper import ConfigHelper
+    from ..confighelper import ConfigHelper
     OutputCallback = Optional[Callable[[bytes], None]]
 
 class ShellCommandError(ServerError):
-    def __init__(self,
-                 message: str,
-                 return_code: Optional[int],
-                 stdout: Optional[bytes] = b"",
-                 stderr: Optional[bytes] = b"",
-                 status_code: int = 500
-                 ) -> None:
+    def __init__(
+        self,
+        message: str,
+        return_code: Optional[int],
+        stdout: Optional[bytes] = b"",
+        stderr: Optional[bytes] = b"",
+        status_code: int = 500
+    ) -> None:
         super().__init__(message, status_code=status_code)
         self.stdout = stdout or b""
         self.stderr = stderr or b""
         self.return_code = return_code
 
 class ShellCommandProtocol(asyncio.subprocess.SubprocessStreamProtocol):
-    def __init__(self,
-                 limit: int,
-                 loop: asyncio.events.AbstractEventLoop,
-                 program_name: str = "",
-                 std_out_cb: OutputCallback = None,
-                 std_err_cb: OutputCallback = None,
-                 log_stderr: bool = False
-                 ) -> None:
+    def __init__(
+        self,
+        limit: int,
+        loop: asyncio.events.AbstractEventLoop,
+        std_out_cb: OutputCallback = None,
+        std_err_cb: OutputCallback = None,
+        log_stderr: bool = False
+    ) -> None:
         self._loop = loop
         self._pipe_fds: List[int] = []
         super().__init__(limit, loop)
-        self.program_name = program_name
         self.std_out_cb = std_out_cb
         self.std_err_cb = std_err_cb
         self.log_stderr = log_stderr
         self.pending_data: List[bytes] = [b"", b""]
 
-    def connection_made(self,
-                        transport: asyncio.transports.BaseTransport
-                        ) -> None:
+    def connection_made(
+        self, transport: asyncio.transports.BaseTransport
+    ) -> None:
+        transport = cast(asyncio.SubprocessTransport, transport)
         self._transport = transport
-        assert isinstance(transport, asyncio.SubprocessTransport)
         stdout_transport = transport.get_pipe_transport(1)
         if stdout_transport is not None:
             self._pipe_fds.append(1)
@@ -74,10 +75,11 @@
         stdin_transport = transport.get_pipe_transport(0)
         if stdin_transport is not None:
             self.stdin = asyncio.streams.StreamWriter(
-                stdin_transport,
+                stdin_transport,  # type: ignore
                 protocol=self,
                 reader=None,
-                loop=self._loop)
+                loop=self._loop
+            )
 
     def pipe_data_received(self, fd: int, data: bytes | str) -> None:
         cb = None
@@ -91,7 +93,7 @@
                     msg = data.decode(errors='ignore')
                 else:
                     msg = data
-                logging.info(f"{self.program_name}: {msg}")
+                logging.info(msg)
         if cb is not None:
             if isinstance(data, str):
                 data = data.encode()
@@ -103,10 +105,9 @@
                     continue
                 cb(line)
 
-    def pipe_connection_lost(self,
-                             fd: int,
-                             exc: Exception | None
-                             ) -> None:
+    def pipe_connection_lost(
+        self, fd: int, exc: Exception | None
+    ) -> None:
         cb = None
         pending = b""
         if fd == 1:
@@ -124,15 +125,16 @@
     IDX_SIGINT = 0
     IDX_SIGTERM = 1
     IDX_SIGKILL = 2
-    def __init__(self,
-                 factory: ShellCommandFactory,
-                 cmd: str,
-                 std_out_callback: OutputCallback,
-                 std_err_callback: OutputCallback,
-                 env: Optional[Dict[str, str]] = None,
-                 log_stderr: bool = False,
-                 cwd: Optional[str] = None
-                 ) -> None:
+    def __init__(
+        self,
+        factory: ShellCommandFactory,
+        cmd: str,
+        std_out_callback: OutputCallback,
+        std_err_callback: OutputCallback,
+        env: Optional[Dict[str, str]] = None,
+        log_stderr: bool = False,
+        cwd: Optional[str] = None
+    ) -> None:
         self.factory = factory
         self.name = cmd
         self.std_out_cb = std_out_callback
@@ -178,13 +180,15 @@
         self.return_code = self.proc = None
         self.cancelled = False
 
-    async def run(self,
-                  timeout: float = 2.,
-                  verbose: bool = True,
-                  log_complete: bool = True,
-                  sig_idx: int = 1,
-                  proc_input: Optional[str] = None
-                  ) -> bool:
+    async def run(
+        self,
+        timeout: float = 2.,
+        verbose: bool = True,
+        log_complete: bool = True,
+        sig_idx: int = 1,
+        proc_input: Optional[str] = None,
+        success_codes: Optional[List[int]] = None
+    ) -> bool:
         async with self.run_lock:
             self.factory.add_running_command(self)
             self._reset_command_data()
@@ -217,22 +221,26 @@
             else:
                 complete = not self.cancelled
             self.factory.remove_running_command(self)
-            return self._check_proc_success(complete, log_complete)
-
-    async def run_with_response(self,
-                                timeout: float = 2.,
-                                retries: int = 1,
-                                log_complete: bool = True,
-                                sig_idx: int = 1,
-                                proc_input: Optional[str] = None
-                                ) -> str:
+            return self._check_proc_success(
+                complete, log_complete, success_codes
+            )
+
+    async def run_with_response(
+        self,
+        timeout: float = 2.,
+        attempts: int = 1,
+        log_complete: bool = True,
+        sig_idx: int = 1,
+        proc_input: Optional[str] = None,
+        success_codes: Optional[List[int]] = None
+    ) -> str:
         async with self.run_lock:
             self.factory.add_running_command(self)
-            retries = max(1, retries)
+            attempts = max(1, attempts)
             stdin: Optional[bytes] = None
             if proc_input is not None:
                 stdin = proc_input.encode()
-            while retries > 0:
+            while attempts > 0:
                 self._reset_command_data()
                 timed_out = False
                 stdout = stderr = b""
@@ -252,7 +260,9 @@
                             logging.info(
                                 f"{self.command[0]}: "
                                 f"{stderr.decode(errors='ignore')}")
-                    if self._check_proc_success(complete, log_complete):
+                    if self._check_proc_success(
+                        complete, log_complete, success_codes
+                    ):
                         self.factory.remove_running_command(self)
                         return stdout.decode(errors='ignore').rstrip("\n")
                     if stdout:
@@ -261,24 +271,25 @@
                             f"\n{stdout.decode(errors='ignore')}")
                     if self.cancelled and not timed_out:
                         break
-                retries -= 1
+                attempts -= 1
                 await asyncio.sleep(.5)
             self.factory.remove_running_command(self)
             raise ShellCommandError(
-                f"Error running shell command: '{self.command}'",
+                f"Error running shell command: '{self.name}'",
                 self.return_code, stdout, stderr)
 
-    async def _create_subprocess(self,
-                                 use_callbacks: bool = False,
-                                 has_input: bool = False
-                                 ) -> bool:
+    async def _create_subprocess(
+        self,
+        use_callbacks: bool = False,
+        has_input: bool = False
+    ) -> bool:
         loop = asyncio.get_running_loop()
 
         def protocol_factory():
             return ShellCommandProtocol(
-                limit=2**20, loop=loop, program_name=self.command[0],
-                std_out_cb=self.std_out_cb, std_err_cb=self.std_err_cb,
-                log_stderr=self.log_stderr)
+                limit=2**20, loop=loop, std_out_cb=self.std_out_cb,
+                std_err_cb=self.std_err_cb, log_stderr=self.log_stderr
+            )
         try:
             stdpipe: Optional[int] = None
             if has_input:
@@ -299,19 +310,25 @@
                     *self.command, stdin=stdpipe,
                     stdout=asyncio.subprocess.PIPE,
                     stderr=errpipe, env=self.env, cwd=self.cwd)
+        except asyncio.CancelledError:
+            raise
         except Exception:
             logging.exception(
                 f"shell_command: Command ({self.name}) failed")
             return False
         return True
 
-    def _check_proc_success(self,
-                            complete: bool,
-                            log_complete: bool
-                            ) -> bool:
+    def _check_proc_success(
+        self,
+        complete: bool,
+        log_complete: bool,
+        success_codes: Optional[List[int]] = None
+    ) -> bool:
         assert self.proc is not None
+        if success_codes is None:
+            success_codes = [0]
         self.return_code = self.proc.returncode
-        success = self.return_code == 0 and complete
+        success = self.return_code in success_codes and complete
         if success:
             msg = f"Command ({self.name}) successfully finished"
         elif self.cancelled:
@@ -339,32 +356,77 @@
         except KeyError:
             pass
 
-    def build_shell_command(self,
-                            cmd: str,
-                            callback: OutputCallback = None,
-                            std_err_callback: OutputCallback = None,
-                            env: Optional[Dict[str, str]] = None,
-                            log_stderr: bool = False,
-                            cwd: Optional[str] = None
-                            ) -> ShellCommand:
-        return ShellCommand(self, cmd, callback, std_err_callback, env,
-                            log_stderr, cwd)
-
-    def exec_cmd(self,
-                 cmd: str,
-                 timeout: float = 2.,
-                 retries: int = 1,
-                 sig_idx: int = 1,
-                 proc_input: Optional[str] = None,
-                 log_complete: bool = True,
-                 log_stderr: bool = False,
-                 env: Optional[Dict[str, str]] = None,
-                 cwd: Optional[str] = None
-                 ) -> Awaitable:
+    def build_shell_command(
+        self,
+        cmd: str,
+        callback: OutputCallback = None,
+        std_err_callback: OutputCallback = None,
+        env: Optional[Dict[str, str]] = None,
+        log_stderr: bool = False,
+        cwd: Optional[str] = None
+    ) -> ShellCommand:
+        return ShellCommand(
+            self, cmd, callback, std_err_callback, env, log_stderr, cwd
+        )
+
+    def run_cmd_async(
+        self,
+        cmd: str,
+        callback: OutputCallback = None,
+        std_err_callback: OutputCallback = None,
+        timeout: float = 2.,
+        attempts: int = 1,
+        verbose: bool = True,
+        sig_idx: int = 1,
+        proc_input: Optional[str] = None,
+        log_complete: bool = True,
+        log_stderr: bool = False,
+        env: Optional[Dict[str, str]] = None,
+        cwd: Optional[str] = None,
+        success_codes: Optional[List[int]] = None
+    ) -> Awaitable[None]:
+        """
+        Runs a command and processes responses as they are received. Optional
+        callbacks may be provided to handle stdout and stderr.
+        """
+        scmd = ShellCommand(
+            self, cmd, callback, std_err_callback, env, log_stderr, cwd
+        )
+        attempts = max(1, attempts)
+        async def _wrapper() -> None:
+            for _ in range(attempts):
+                if await scmd.run(
+                    timeout, verbose, log_complete, sig_idx,
+                    proc_input, success_codes
+                ):
+                    break
+            else:
+                ret_code = scmd.get_return_code()
+                raise ShellCommandError(f"Error running command {cmd}", ret_code)
+        return asyncio.create_task(_wrapper())
+
+    def exec_cmd(
+        self,
+        cmd: str,
+        timeout: float = 2.,
+        attempts: int = 1,
+        sig_idx: int = 1,
+        proc_input: Optional[str] = None,
+        log_complete: bool = True,
+        log_stderr: bool = False,
+        env: Optional[Dict[str, str]] = None,
+        cwd: Optional[str] = None,
+        success_codes: Optional[List[int]] = None
+    ) -> Awaitable[str]:
+        """
+        Executes a command and returns UTF-8 decoded stdout upon completion.
+        """
         scmd = ShellCommand(self, cmd, None, None, env,
                             log_stderr, cwd)
-        coro = scmd.run_with_response(timeout, retries, log_complete,
-                                      sig_idx, proc_input)
+        coro = scmd.run_with_response(
+            timeout, attempts, log_complete, sig_idx,
+            proc_input, success_codes
+        )
         return asyncio.create_task(coro)
 
     async def close(self) -> None:
