Differences in moonraker/components/file_manager/metadata.py:

- Lines with differences: 575 lines in 33 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/file_manager/metadata.py	2024-04-09 04:42:07.000000000 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/file_manager/metadata.py	2024-10-08 17:45:43.664278016 -0400
@@ -17,6 +17,7 @@
 import zipfile
 import shutil
 import uuid
+import logging
 from PIL import Image
 
 # Annotation imports
@@ -35,40 +36,39 @@
 UFP_MODEL_PATH = "/3D/model.gcode"
 UFP_THUMB_PATH = "/Metadata/thumbnail.png"
 
-def log_to_stderr(msg: str) -> None:
-    sys.stderr.write(f"{msg}\n")
-    sys.stderr.flush()
-
-# regex helpers
-def _regex_find_floats(pattern: str,
-                       data: str,
-                       strict: bool = False
-                       ) -> List[float]:
-    # If strict is enabled, pattern requires a floating point
-    # value, otherwise it can be an integer value
-    fptrn = r'\d+\.\d*' if strict else r'\d+\.?\d*'
+logging.basicConfig(stream=sys.stderr, level=logging.INFO)
+logger = logging.getLogger("metadata")
+
+# Regex helpers.  These methods take patterns with placeholders
+# to insert the correct regex capture group for floats, ints,
+# and strings:
+#  Float: (%F) = (\d*\.?\d+)
+#  Integer: (%D) = (\d+)
+#  String: (%S) = (.+)
+def regex_find_floats(pattern: str, data: str) -> List[float]:
+    pattern = pattern.replace(r"(%F)", r"([0-9]*\.?[0-9]+)")
     matches = re.findall(pattern, data)
     if matches:
         # return the maximum height value found
         try:
-            return [float(h) for h in re.findall(
-                    fptrn, " ".join(matches))]
+            return [float(h) for h in matches]
         except Exception:
             pass
     return []
 
-def _regex_find_ints(pattern: str, data: str) -> List[int]:
+def regex_find_ints(pattern: str, data: str) -> List[int]:
+    pattern = pattern.replace(r"(%D)", r"([0-9]+)")
     matches = re.findall(pattern, data)
     if matches:
         # return the maximum height value found
         try:
-            return [int(h) for h in re.findall(
-                    r'\d+', " ".join(matches))]
+            return [int(h) for h in matches]
         except Exception:
             pass
     return []
 
-def _regex_find_first(pattern: str, data: str) -> Optional[float]:
+def regex_find_float(pattern: str, data: str) -> Optional[float]:
+    pattern = pattern.replace(r"(%F)", r"([0-9]*\.?[0-9]+)")
     match = re.search(pattern, data)
     val: Optional[float] = None
     if match:
@@ -78,7 +78,8 @@
             return None
     return val
 
-def _regex_find_int(pattern: str, data: str) -> Optional[int]:
+def regex_find_int(pattern: str, data: str) -> Optional[int]:
+    pattern = pattern.replace(r"(%D)", r"([0-9]+)")
     match = re.search(pattern, data)
     val: Optional[int] = None
     if match:
@@ -88,24 +89,21 @@
             return None
     return val
 
-def _regex_find_string(pattern: str, data: str) -> Optional[str]:
+def regex_find_string(pattern: str, data: str) -> Optional[str]:
+    pattern = pattern.replace(r"(%S)", r"(.*)")
     match = re.search(pattern, data)
     if match:
-        return match.group(1)
+        return match.group(1).strip('"')
     return None
 
-def _regex_find_string_znp(pattern: str, data: str) -> Optional[str]:
-    last_pattern = ';'+pattern
-    split_datas = data.split("\n")
-    preview_string = ""
-    for split_data in split_datas:
-        if last_pattern in split_data:
-            preview_string += split_data.replace(last_pattern, "")
-        elif pattern in split_data:
-            preview_string += split_data.replace(pattern, "")
-    if preview_string:
-        return preview_string
-    return None
+def regex_find_min_float(pattern: str, data: str) -> Optional[float]:
+    result = regex_find_floats(pattern, data)
+    return min(result) if result else None
+
+def regex_find_max_float(pattern: str, data: str) -> Optional[float]:
+    result = regex_find_floats(pattern, data)
+    return max(result) if result else None
+
 
 # Slicer parsing implementations
 class BaseSlicer(object):
@@ -114,6 +112,7 @@
         self.header_data: str = ""
         self.footer_data: str = ""
         self.layer_height: Optional[float] = None
+        self.has_m486_objects: bool = False
 
     def set_data(self,
                  header_data: str,
@@ -123,35 +122,26 @@
         self.footer_data = footer_data
         self.size: int = fsize
 
-    def _parse_min_float(self,
-                         pattern: str,
-                         data: str,
-                         strict: bool = False
-                         ) -> Optional[float]:
-        result = _regex_find_floats(pattern, data, strict)
-        if result:
-            return min(result)
-        else:
-            return None
-
-    def _parse_max_float(self,
-                         pattern: str,
-                         data: str,
-                         strict: bool = False
-                         ) -> Optional[float]:
-        result = _regex_find_floats(pattern, data, strict)
-        if result:
-            return max(result)
-        else:
-            return None
-
     def _check_has_objects(self,
                            data: str,
                            pattern: Optional[str] = None
                            ) -> bool:
-        match = re.search(r"\nDEFINE_OBJECT NAME=", data)
+        match = re.search(
+            r"\n((DEFINE_OBJECT)|(EXCLUDE_OBJECT_DEFINE)) NAME=",
+            data
+        )
         if match is not None:
-            # Objects alread processed
+            # Objects already processed
+            fname = os.path.basename(self.path)
+            logger.info(
+                f"File '{fname}' currently supports cancellation, "
+                "processing aborted"
+            )
+            if match.group(1).startswith("DEFINE_OBJECT"):
+                logger.info(
+                    "Legacy object processing detected.  This is not "
+                    "compatible with official versions of Klipper."
+                )
             return False
         # Always check M486
         patterns = [r"\nM486"]
@@ -159,6 +149,7 @@
             patterns.append(pattern)
         for regex in patterns:
             if re.search(regex, data) is not None:
+                self.has_m486_objects = regex == r"\nM486"
                 return True
         return False
 
@@ -208,6 +199,9 @@
     def parse_first_layer_bed_temp(self) -> Optional[float]:
         return None
 
+    def parse_chamber_temp(self) -> Optional[float]:
+        return None
+
     def parse_first_layer_extr_temp(self) -> Optional[float]:
         return None
 
@@ -224,22 +218,22 @@
             try:
                 os.mkdir(thumb_dir)
             except Exception:
-                log_to_stderr(f"Unable to create thumb dir: {thumb_dir}")
+                logger.info(f"Unable to create thumb dir: {thumb_dir}")
                 return None
         thumb_base = os.path.splitext(os.path.basename(self.path))[0]
         parsed_matches: List[Dict[str, Any]] = []
         has_miniature: bool = False
         for match in thumb_matches:
             lines = re.split(r"\r?\n", match.replace('; ', ''))
-            info = _regex_find_ints(r".*", lines[0])
+            info = regex_find_ints(r"(%D)", lines[0])
             data = "".join(lines[1:-1])
             if len(info) != 3:
-                log_to_stderr(
+                logger.info(
                     f"MetadataError: Error parsing thumbnail"
                     f" header: {lines[0]}")
                 continue
             if len(data) != info[2]:
-                log_to_stderr(
+                logger.info(
                     f"MetadataError: Thumbnail Size Mismatch: "
                     f"detected {info[2]}, actual {len(data)}")
                 continue
@@ -278,7 +272,7 @@
                         'relative_path': rel_path_small
                     })
             except Exception as e:
-                log_to_stderr(str(e))
+                logger.info(str(e))
         return parsed_matches
 
     def parse_layer_count(self) -> Optional[int]:
@@ -292,18 +286,19 @@
         return {'slicer': "Unknown"}
 
     def parse_first_layer_height(self) -> Optional[float]:
-        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+        return regex_find_min_float(r"G1\sZ(%F)\s", self.header_data)
 
     def parse_object_height(self) -> Optional[float]:
-        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+        return regex_find_max_float(r"G1\sZ(%F)\s", self.footer_data)
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M109 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M109 S(%F)", self.header_data)
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M190 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M190 S(%F)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(r"M191 S(%F)", self.header_data)
 
     def parse_thumbnails(self) -> Optional[List[Dict[str, Any]]]:
         return None
@@ -313,7 +308,12 @@
         aliases = {
             'PrusaSlicer': r"PrusaSlicer\s(.*)\son",
             'SuperSlicer': r"SuperSlicer\s(.*)\son",
-            'SliCR-3D': r"SliCR-3D\s(.*)\son"
+            'OrcaSlicer': r"OrcaSlicer\s(.*)\son",
+            'MomentSlicer': r"MomentSlicer\s(.*)\son",
+            'SliCR-3D': r"SliCR-3D\s(.*)\son",
+            'BambuStudio': r"BambuStudio[^ ]*\s(.*)\n",
+            'A3dp-Slicer': r"A3dp-Slicer\s(.*)\son",
+            'QIDISlicer': r"QIDISlicer\s(.*)\son",
         }
         for name, expr in aliases.items():
             match = re.search(expr, data)
@@ -330,20 +330,19 @@
 
     def parse_first_layer_height(self) -> Optional[float]:
         # Check percentage
-        pct = _regex_find_first(
-            r"; first_layer_height = (\d+)%", self.footer_data)
+        pct = regex_find_float(r"; first_layer_height = (%F)%", self.footer_data)
         if pct is not None:
             if self.layer_height is None:
                 # Failed to parse the original layer height, so it is not
                 # possible to calculate a percentage
                 return None
             return round(pct / 100. * self.layer_height, 6)
-        return _regex_find_first(
-            r"; first_layer_height = (\d+\.?\d*)", self.footer_data)
+        return regex_find_float(r"; first_layer_height = (%F)", self.footer_data)
 
     def parse_layer_height(self) -> Optional[float]:
-        self.layer_height = _regex_find_first(
-            r"; layer_height = (\d+\.?\d*)", self.footer_data)
+        self.layer_height = regex_find_float(
+            r"; layer_height = (%F)", self.footer_data
+        )
         return self.layer_height
 
     def parse_object_height(self) -> Optional[float]:
@@ -356,23 +355,31 @@
                 pass
             else:
                 return max(matches)
-        return self._parse_max_float(r"G1\sZ\d+\.\d*\sF", self.footer_data)
+        return regex_find_max_float(r"G1\sZ(%F)\sF", self.footer_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r"filament\sused\s\[mm\]\s=\s(\d+\.\d*)", self.footer_data)
+        line = regex_find_string(r'filament\sused\s\[mm\]\s=\s(%S)\n', self.footer_data)
+        if line:
+            filament = regex_find_floats(
+                r"(%F)", line
+            )
+            if filament:
+                return sum(filament)
+        return None
 
     def parse_filament_weight_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r"total\sfilament\sused\s\[g\]\s=\s(\d+\.\d*)", self.footer_data)
+        return regex_find_float(
+            r"total\sfilament\sused\s\[g\]\s=\s(%F)",
+            self.footer_data
+        )
 
     def parse_filament_type(self) -> Optional[str]:
-        return _regex_find_string(
-            r";\sfilament_type\s=\s(.*)", self.footer_data)
+        return regex_find_string(r";\sfilament_type\s=\s(%S)", self.footer_data)
 
     def parse_filament_name(self) -> Optional[str]:
-        return _regex_find_string(
-            r";\sfilament_settings_id\s=\s(.*)", self.footer_data)
+        return regex_find_string(
+            r";\sfilament_settings_id\s=\s(%S)", self.footer_data
+        )
 
     def parse_estimated_time(self) -> Optional[float]:
         time_match = re.search(
@@ -393,20 +400,27 @@
         return round(total_time, 2)
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"; first_layer_temperature = (\d+\.?\d*)", self.footer_data)
+        return regex_find_float(
+            r"; first_layer_temperature = (%F)", self.footer_data
+        )
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"; first_layer_bed_temperature = (\d+\.?\d*)", self.footer_data)
+        return regex_find_float(
+            r"; first_layer_bed_temperature = (%F)", self.footer_data
+        )
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(
+            r"; chamber_temperature = (%F)", self.footer_data
+        )
 
     def parse_nozzle_diameter(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\snozzle_diameter\s=\s(\d+\.\d*)", self.footer_data)
+        return regex_find_float(
+            r";\snozzle_diameter\s=\s(%F)", self.footer_data
+        )
 
     def parse_layer_count(self) -> Optional[int]:
-        return _regex_find_int(
-            r"; total layers count = (\d+)", self.footer_data)
+        return regex_find_int(r"; total layers count = (%D)", self.footer_data)
 
 class Slic3rPE(PrusaSlicer):
     def check_identity(self, data: str) -> Optional[Dict[str, str]]:
@@ -419,8 +433,7 @@
         return None
 
     def parse_filament_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r"filament\sused\s=\s(\d+\.\d+)mm", self.footer_data)
+        return regex_find_float(r"filament\sused\s=\s(%F)mm", self.footer_data)
 
     def parse_thumbnails(self) -> Optional[List[Dict[str, Any]]]:
         return None
@@ -436,15 +449,15 @@
         return None
 
     def parse_filament_total(self) -> Optional[float]:
-        filament = _regex_find_first(
-            r";\sfilament\_length\_m\s=\s(\d+\.\d*)", self.footer_data)
+        filament = regex_find_float(
+            r";\sfilament\_length\_m\s=\s(%F)", self.footer_data
+        )
         if filament is not None:
             filament *= 1000
         return filament
 
     def parse_filament_weight_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sfilament\smass\_g\s=\s(\d+\.\d*)", self.footer_data)
+        return regex_find_float(r";\sfilament\smass\_g\s=\s(%F)", self.footer_data)
 
     def parse_estimated_time(self) -> Optional[float]:
         return None
@@ -460,57 +473,52 @@
         return None
 
     def has_objects(self) -> bool:
-        return self._check_has_objects(
-            self.header_data, r"\n;MESH:")
+        return self._check_has_objects(self.header_data, r"\n;MESH:")
 
     def parse_first_layer_height(self) -> Optional[float]:
-        return _regex_find_first(r";MINZ:(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r";MINZ:(%F)", self.header_data)
 
     def parse_layer_height(self) -> Optional[float]:
-        self.layer_height = _regex_find_first(
-            r";Layer\sheight:\s(\d+\.?\d*)", self.header_data)
+        self.layer_height = regex_find_float(
+            r";Layer\sheight:\s(%F)", self.header_data
+        )
         return self.layer_height
 
     def parse_object_height(self) -> Optional[float]:
-        return _regex_find_first(r";MAXZ:(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r";MAXZ:(%F)", self.header_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        filament = _regex_find_first(
-            r";Filament\sused:\s(\d+\.?\d*)m", self.header_data)
+        filament = regex_find_float(r";Filament\sused:\s(%F)m", self.header_data)
         if filament is not None:
             filament *= 1000
         return filament
 
     def parse_filament_weight_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";Filament\sweight\s=\s.(\d+\.\d+).", self.header_data)
+        return regex_find_float(r";Filament\sweight\s=\s.(%F).", self.header_data)
 
     def parse_filament_type(self) -> Optional[str]:
-        return _regex_find_string(
-            r";Filament\stype\s=\s(.*)", self.header_data)
+        return regex_find_string(r";Filament\stype\s=\s(%S)", self.header_data)
 
     def parse_filament_name(self) -> Optional[str]:
-        return _regex_find_string(
-            r";Filament\sname\s=\s(.*)", self.header_data)
+        return regex_find_string(r";Filament\sname\s=\s(%S)", self.header_data)
 
     def parse_estimated_time(self) -> Optional[float]:
-        return self._parse_max_float(r";TIME:.*", self.header_data)
+        return regex_find_max_float(r";TIME:(%F)", self.header_data)
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M109 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M109 S(%F)", self.header_data)
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M190 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M190 S(%F)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(r"M191 S(%F)", self.header_data)
 
     def parse_layer_count(self) -> Optional[int]:
-        return _regex_find_int(
-            r";LAYER_COUNT\:(\d+)", self.header_data)
+        return regex_find_int(r";LAYER_COUNT\:(%D)", self.header_data)
 
     def parse_nozzle_diameter(self) -> Optional[float]:
-        return _regex_find_first(
-            r";Nozzle\sdiameter\s=\s(\d+\.\d*)", self.header_data)
+        return regex_find_float(r";Nozzle\sdiameter\s=\s(%F)", self.header_data)
 
     def parse_thumbnails(self) -> Optional[List[Dict[str, Any]]]:
         # Attempt to parse thumbnails from file metadata
@@ -536,7 +544,7 @@
                     'relative_path': rel_path_full
                 })
                 # Create 32x32 thumbnail
-                im.thumbnail((32, 32), Image.ANTIALIAS)
+                im.thumbnail((32, 32), Image.Resampling.LANCZOS)
                 im.save(thumb_path_small, format="PNG")
                 thumbs.insert(0, {
                     'width': im.width, 'height': im.height,
@@ -544,22 +552,16 @@
                     'relative_path': rel_path_small
                 })
         except Exception as e:
-            log_to_stderr(str(e))
+            logger.info(str(e))
             return None
         return thumbs
 
-    def parse_gimage(self) -> Optional[str]:
-        return _regex_find_string_znp(
-            r";gimage:", self.header_data)
-
-    def parse_simage(self) -> Optional[str]:
-        return _regex_find_string_znp(
-            r";simage:", self.header_data)
-
 class Simplify3D(BaseSlicer):
     def check_identity(self, data: str) -> Optional[Dict[str, str]]:
         match = re.search(r"Simplify3D\(R\)\sVersion\s(.*)", data)
         if match:
+            self._version = match.group(1)
+            self._is_v5 = self._version.startswith("5")
             return {
                 'slicer': "Simplify3D",
                 'slicer_version': match.group(1)
@@ -567,31 +569,39 @@
         return None
 
     def parse_first_layer_height(self) -> Optional[float]:
-        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+        return regex_find_min_float(r"G1\sZ(%F)\s", self.header_data)
 
     def parse_layer_height(self) -> Optional[float]:
-        self.layer_height = _regex_find_first(
-            r";\s+layerHeight,(\d+\.?\d*)", self.header_data)
+        self.layer_height = regex_find_float(
+            r";\s+layerHeight,(%F)", self.header_data
+        )
         return self.layer_height
 
     def parse_object_height(self) -> Optional[float]:
-        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+        return regex_find_max_float(r"G1\sZ(%F)\s", self.footer_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\s+Filament\slength:\s(\d+\.?\d*)\smm", self.footer_data)
+        return regex_find_float(
+            r";\s+(?:Filament\slength|Material\sLength):\s(%F)\smm",
+            self.footer_data
+        )
 
     def parse_filament_weight_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\s+Plastic\sweight:\s(\d+\.?\d*)\sg", self.footer_data)
+        return regex_find_float(
+            r";\s+(?:Plastic\sweight|Material\sWeight):\s(%F)\sg",
+            self.footer_data
+        )
 
     def parse_filament_name(self) -> Optional[str]:
-        return _regex_find_string(
-            r";\s+printMaterial,(.*)", self.header_data)
+        return regex_find_string(
+            r";\s+printMaterial,(%S)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return regex_find_string(
+            r";\s+makerBotModelMaterial,(%S)", self.footer_data)
 
     def parse_estimated_time(self) -> Optional[float]:
-        time_match = re.search(
-            r';\s+Build time:.*', self.footer_data)
+        time_match = re.search(r';\s+Build (t|T)ime:.*', self.footer_data)
         if not time_match:
             return None
         total_time = 0
@@ -624,15 +634,37 @@
                     return None
         return None
 
+    def _get_first_layer_temp_v5(self, heater_type: str) -> Optional[float]:
+        pattern = (
+            r";\s+temperatureController,.+?"
+            r";\s+temperatureType,"f"{heater_type}"r".+?"
+            r";\s+temperatureSetpoints,\d+\|(\d+)"
+        )
+        match = re.search(pattern, self.header_data, re.MULTILINE | re.DOTALL)
+        if match is not None:
+            try:
+                return float(match.group(1))
+            except Exception:
+                return None
+        return None
+
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return self._get_first_layer_temp("Extruder 1")
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("extruder")
+        else:
+            return self._get_first_layer_temp("Extruder 1")
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return self._get_first_layer_temp("Heated Bed")
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("platform")
+        else:
+            return self._get_first_layer_temp("Heated Bed")
 
     def parse_nozzle_diameter(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\s+extruderDiameter,(\d+\.\d*)", self.header_data)
+        return regex_find_float(
+            r";\s+(?:extruderDiameter|nozzleDiameter),(%F)",
+            self.header_data
+        )
 
 class KISSlicer(BaseSlicer):
     def check_identity(self, data: str) -> Optional[Dict[str, Any]]:
@@ -647,28 +679,28 @@
         return None
 
     def parse_first_layer_height(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\s+first_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+        return regex_find_float(
+            r";\s+first_layer_thickness_mm\s=\s(%F)", self.header_data)
 
     def parse_layer_height(self) -> Optional[float]:
-        self.layer_height = _regex_find_first(
-            r";\s+max_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+        self.layer_height = regex_find_float(
+            r";\s+max_layer_thickness_mm\s=\s(%F)", self.header_data)
         return self.layer_height
 
     def parse_object_height(self) -> Optional[float]:
-        return self._parse_max_float(
-            r";\sEND_LAYER_OBJECT\sz.*", self.footer_data)
+        return regex_find_max_float(
+            r";\sEND_LAYER_OBJECT\sz=(%F)", self.footer_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        filament = _regex_find_floats(
-            r";\s+Ext\s.*mm", self.footer_data, strict=True)
+        filament = regex_find_floats(
+            r";\s+Ext #\d+\s+=\s+(%F)\s*mm", self.footer_data)
         if filament:
             return sum(filament)
         return None
 
     def parse_estimated_time(self) -> Optional[float]:
-        time = _regex_find_first(
-            r";\sCalculated.*Build\sTime:\s(\d+\.?\d*)\sminutes",
+        time = regex_find_float(
+            r";\sCalculated.*Build\sTime:\s(%F)\sminutes",
             self.footer_data)
         if time is not None:
             time *= 60
@@ -676,12 +708,13 @@
         return None
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"; first_layer_C = (\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"; first_layer_C = (%F)", self.header_data)
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"; bed_C = (\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"; bed_C = (%F)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(r"; chamber_C = (%F)", self.header_data)
 
 
 class IdeaMaker(BaseSlicer):
@@ -695,54 +728,49 @@
         return None
 
     def has_objects(self) -> bool:
-        return self._check_has_objects(
-            self.header_data, r"\n;PRINTING:")
+        return self._check_has_objects(self.header_data, r"\n;PRINTING:")
 
     def parse_first_layer_height(self) -> Optional[float]:
-        layer_info = _regex_find_floats(
-            r";LAYER:0\s*.*\s*;HEIGHT.*", self.header_data)
-        if len(layer_info) >= 3:
-            return layer_info[2]
-        return None
+        return regex_find_float(
+            r";LAYER:0\s*.*\s*;HEIGHT:(%F)", self.header_data
+        )
 
     def parse_layer_height(self) -> Optional[float]:
-        layer_info = _regex_find_floats(
-            r";LAYER:1\s*.*\s*;HEIGHT.*", self.header_data)
-        if len(layer_info) >= 3:
-            self.layer_height = layer_info[2]
-            return self.layer_height
-        return None
+        return regex_find_float(
+            r";LAYER:1\s*.*\s*;HEIGHT:(%F)", self.header_data
+        )
 
     def parse_object_height(self) -> Optional[float]:
-        bounds = _regex_find_floats(
-            r";Bounding Box:.*", self.header_data)
-        if len(bounds) >= 6:
-            return bounds[5]
-        return None
+        return regex_find_float(r";Bounding Box:(?:\s+(%F))+", self.header_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        filament = _regex_find_floats(
-            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
+        filament = regex_find_floats(
+            r";Material.\d\sUsed:\s+(%F)", self.footer_data
+        )
         if filament:
             return sum(filament)
         return None
 
     def parse_filament_type(self) -> Optional[str]:
-        return _regex_find_string(
-            r";Filament\stype\s=\s(.*)", self.header_data)
+        return (
+            regex_find_string(r";Filament\sType\s.\d:\s(%S)", self.header_data) or
+            regex_find_string(r";Filament\stype\s=\s(%S)", self.header_data)
+        )
 
     def parse_filament_name(self) -> Optional[str]:
-        return _regex_find_string(
-            r";Filament\sname\s=\s(.*)", self.header_data)
+        return (
+            regex_find_string(r";Filament\sName\s.\d:\s(%S)", self.header_data) or
+            regex_find_string(r";Filament\sname\s=\s(%S)", self.header_data)
+        )
 
     def parse_filament_weight_total(self) -> Optional[float]:
         pi = 3.141592653589793
-        length = _regex_find_floats(
-            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
-        diameter = _regex_find_floats(
-            r";Filament\sDiameter\s.\d:.*", self.header_data, strict=True)
-        density = _regex_find_floats(
-            r";Filament\sDensity\s.\d:.*", self.header_data, strict=True)
+        length = regex_find_floats(
+            r";Material.\d\sUsed:\s+(%F)", self.footer_data)
+        diameter = regex_find_floats(
+            r";Filament\sDiameter\s.\d:\s+(%F)", self.header_data)
+        density = regex_find_floats(
+            r";Filament\sDensity\s.\d:\s+(%F)", self.header_data)
         if len(length) == len(density) == len(diameter):
             # calc individual weight for each filament with m=pi/4*d²*l*rho
             weights = [(pi/4 * diameter[i]**2 * length[i] * density[i]/10**6)
@@ -751,20 +779,20 @@
         return None
 
     def parse_estimated_time(self) -> Optional[float]:
-        return _regex_find_first(
-            r";Print\sTime:\s(\d+\.?\d*)", self.footer_data)
+        return regex_find_float(r";Print\sTime:\s(%F)", self.footer_data)
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M109 T0 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M109 T0 S(%F)", self.header_data)
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r"M190 S(\d+\.?\d*)", self.header_data)
+        return regex_find_float(r"M190 S(%F)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(r"M191 S(%F)", self.header_data)
 
     def parse_nozzle_diameter(self) -> Optional[float]:
-        return _regex_find_first(
-            r";Dimension:(?:\s\d+\.\d+){3}\s(\d+\.\d+)", self.header_data)
+        return regex_find_float(
+            r";Dimension:(?:\s\d+\.\d+){3}\s(%F)", self.header_data)
 
 class IceSL(BaseSlicer):
     def check_identity(self, data) -> Optional[Dict[str, Any]]:
@@ -778,65 +806,127 @@
         return None
 
     def parse_first_layer_height(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sz_layer_height_first_layer_mm\s:\s+(\d+\.\d+)",
+        return regex_find_float(
+            r";\sz_layer_height_first_layer_mm\s:\s+(%F)",
             self.header_data)
 
     def parse_layer_height(self) -> Optional[float]:
-        self.layer_height = _regex_find_first(
-            r";\sz_layer_height_mm\s:\s+(\d+\.\d+)",
+        self.layer_height = regex_find_float(
+            r";\sz_layer_height_mm\s:\s+(%F)",
             self.header_data)
         return self.layer_height
 
     def parse_object_height(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sprint_height_mm\s:\s+(\d+\.\d+)", self.header_data)
+        return regex_find_float(
+            r";\sprint_height_mm\s:\s+(%F)", self.header_data)
 
     def parse_first_layer_extr_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sextruder_temp_degree_c_0\s:\s+(\d+\.?\d*)", self.header_data)
+        return regex_find_float(
+            r";\sextruder_temp_degree_c_0\s:\s+(%F)", self.header_data)
 
     def parse_first_layer_bed_temp(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sbed_temp_degree_c\s:\s+(\d+\.?\d*)", self.header_data)
+        return regex_find_float(
+            r";\sbed_temp_degree_c\s:\s+(%F)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return regex_find_float(
+            r";\schamber_temp_degree_c\s:\s+(%F)", self.header_data)
 
     def parse_filament_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sfilament_used_mm\s:\s+(\d+\.\d+)", self.header_data)
+        return regex_find_float(
+            r";\sfilament_used_mm\s:\s+(%F)", self.header_data)
 
     def parse_filament_weight_total(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sfilament_used_g\s:\s+(\d+\.\d+)", self.header_data)
+        return regex_find_float(
+            r";\sfilament_used_g\s:\s+(%F)", self.header_data)
 
     def parse_filament_name(self) -> Optional[str]:
-        return _regex_find_string(
-            r";\sfilament_name\s:\s+(.*)", self.header_data)
+        return regex_find_string(
+            r";\sfilament_name\s:\s+(%S)", self.header_data)
 
     def parse_filament_type(self) -> Optional[str]:
-        return _regex_find_string(
-            r";\sfilament_type\s:\s+(.*)", self.header_data)
+        return regex_find_string(
+            r";\sfilament_type\s:\s+(%S)", self.header_data)
 
     def parse_estimated_time(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\sestimated_print_time_s\s:\s+(\d*\.*\d*)", self.header_data)
+        return regex_find_float(
+            r";\sestimated_print_time_s\s:\s+(%F)", self.header_data)
 
     def parse_layer_count(self) -> Optional[int]:
-        return _regex_find_int(
-            r";\slayer_count\s:\s+(\d+)", self.header_data)
+        return regex_find_int(
+            r";\slayer_count\s:\s+(%D)", self.header_data)
 
     def parse_nozzle_diameter(self) -> Optional[float]:
-        return _regex_find_first(
-            r";\snozzle_diameter_mm_0\s:\s+(\d+\.\d+)", self.header_data)
+        return regex_find_float(
+            r";\snozzle_diameter_mm_0\s:\s+(%F)", self.header_data)
+
+class KiriMoto(BaseSlicer):
+    def check_identity(self, data) -> Optional[Dict[str, Any]]:
+        variants: Dict[str, str] = {
+            "Kiri:Moto": r"; Generated by Kiri:Moto (\d.+)",
+            "SimplyPrint": r"; Generated by Kiri:Moto \(SimplyPrint\) (.+)"
+        }
+        for name, pattern in variants.items():
+            match = re.search(pattern, data)
+            if match:
+                return {
+                    "slicer": name,
+                    "slicer_version": match.group(1)
+                }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return regex_find_float(
+            r"; firstSliceHeight = (%F)", self.header_data
+        )
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = regex_find_float(
+            r"; sliceHeight = (%F)", self.header_data
+        )
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return regex_find_max_float(
+            r"G1 Z(%F) (?:; z-hop end|F\d+\n)", self.footer_data
+        )
+
+    def parse_layer_count(self) -> Optional[int]:
+        matches = re.findall(
+            r";; --- layer (\d+) \(.+", self.footer_data
+        )
+        if not matches:
+            return None
+        try:
+            return int(matches[-1]) + 1
+        except Exception:
+            return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return regex_find_int(r"; --- print time: (%D)s", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return regex_find_float(
+            r"; --- filament used: (%F) mm", self.footer_data
+        )
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return regex_find_float(
+            r"; firstLayerNozzleTemp = (%F)", self.header_data
+        )
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return regex_find_float(
+            r"; firstLayerBedTemp = (%F)", self.header_data
+        )
 
 
-READ_SIZE = 512 * 1024
+READ_SIZE = 1024 * 1024  # 1 MiB
 SUPPORTED_SLICERS: List[Type[BaseSlicer]] = [
     PrusaSlicer, Slic3rPE, Slic3r, Cura, Simplify3D,
-    KISSlicer, IdeaMaker, IceSL
+    KISSlicer, IdeaMaker, IceSL, KiriMoto
 ]
 SUPPORTED_DATA = [
-    'gimage',
-    'simage',
     'gcode_start_byte',
     'gcode_end_byte',
     'layer_count',
@@ -847,25 +937,55 @@
     'first_layer_height',
     'first_layer_extr_temp',
     'first_layer_bed_temp',
+    'chamber_temp',
     'filament_name',
     'filament_type',
     'filament_total',
     'filament_weight_total',
     'thumbnails']
 
-def process_objects(file_path: str) -> bool:
+def process_objects(file_path: str, slicer: BaseSlicer, name: str) -> bool:
     try:
-        from preprocess_cancellation import preprocessor
+        from preprocess_cancellation import (
+            preprocess_slicer,
+            preprocess_cura,
+            preprocess_ideamaker,
+            preprocess_m486
+        )
     except ImportError:
-        log_to_stderr("Module 'preprocess-cancellation' failed to load")
+        logger.info("Module 'preprocess-cancellation' failed to load")
         return False
     fname = os.path.basename(file_path)
-    log_to_stderr(f"Performing Object Processing on file: {fname}")
+    logger.info(
+        f"Performing Object Processing on file: {fname}, "
+        f"sliced by {name}"
+    )
     with tempfile.TemporaryDirectory() as tmp_dir_name:
         tmp_file = os.path.join(tmp_dir_name, fname)
         with open(file_path, 'r') as in_file:
             with open(tmp_file, 'w') as out_file:
-                preprocessor(in_file, out_file)
+                try:
+                    if slicer.has_m486_objects:
+                        processor = preprocess_m486
+                    elif isinstance(slicer, PrusaSlicer):
+                        processor = preprocess_slicer
+                    elif isinstance(slicer, Cura):
+                        processor = preprocess_cura
+                    elif isinstance(slicer, IdeaMaker):
+                        processor = preprocess_ideamaker
+                    else:
+                        logger.info(
+                            f"Object Processing Failed, slicer {name}"
+                            "not supported"
+                        )
+                        return False
+                    for line in processor(in_file):
+                        out_file.write(line)
+                except Exception as e:
+                    logger.info(f"Object processing failed: {e}")
+                    return False
+        if os.path.islink(file_path):
+            file_path = os.path.realpath(file_path)
         shutil.move(tmp_file, file_path)
     return True
 
@@ -904,7 +1024,8 @@
     metadata: Dict[str, Any] = {}
     slicer, ident = get_slicer(file_path)
     if check_objects and slicer.has_objects():
-        if process_objects(file_path):
+        name = ident.get("slicer", "unknown")
+        if process_objects(file_path, slicer, name):
             slicer, ident = get_slicer(file_path)
     metadata['size'] = os.path.getsize(file_path)
     metadata['modified'] = os.path.getmtime(file_path)
@@ -919,7 +1040,7 @@
 
 def extract_ufp(ufp_path: str, dest_path: str) -> None:
     if not os.path.isfile(ufp_path):
-        log_to_stderr(f"UFP file Not Found: {ufp_path}")
+        logger.info(f"UFP file Not Found: {ufp_path}")
         sys.exit(-1)
     thumb_name = os.path.splitext(
         os.path.basename(dest_path))[0] + ".png"
@@ -934,18 +1055,20 @@
                 if UFP_THUMB_PATH in zf.namelist():
                     tmp_thumb_path = zf.extract(
                         UFP_THUMB_PATH, path=tmp_dir_name)
+            if os.path.islink(dest_path):
+                dest_path = os.path.realpath(dest_path)
             shutil.move(tmp_model_path, dest_path)
             if tmp_thumb_path:
                 if not os.path.exists(dest_thumb_dir):
                     os.mkdir(dest_thumb_dir)
                 shutil.move(tmp_thumb_path, dest_thumb_path)
     except Exception:
-        log_to_stderr(traceback.format_exc())
+        logger.info(traceback.format_exc())
         sys.exit(-1)
     try:
         os.remove(ufp_path)
     except Exception:
-        log_to_stderr(f"Error removing ufp file: {ufp_path}")
+        logger.info(f"Error removing ufp file: {ufp_path}")
 
 def main(path: str,
          filename: str,
@@ -957,12 +1080,12 @@
         extract_ufp(ufp, file_path)
     metadata: Dict[str, Any] = {}
     if not os.path.isfile(file_path):
-        log_to_stderr(f"File Not Found: {file_path}")
+        logger.info(f"File Not Found: {file_path}")
         sys.exit(-1)
     try:
         metadata = extract_metadata(file_path, check_objects)
     except Exception:
-        log_to_stderr(traceback.format_exc())
+        logger.info(traceback.format_exc())
         sys.exit(-1)
     fd = sys.stdout.fileno()
     data = json.dumps(
@@ -997,5 +1120,5 @@
     args = parser.parse_args()
     check_objects = args.check_objects
     enabled_msg = "enabled" if check_objects else "disabled"
-    log_to_stderr(f"Object Processing is {enabled_msg}")
+    logger.info(f"Object Processing is {enabled_msg}")
     main(args.path, args.filename, args.ufp, check_objects)
