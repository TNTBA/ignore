Differences in moonraker/components/proc_stats.py:

- Lines with differences: 128 lines in 8 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/proc_stats.py	2022-07-25 05:53:30.910869307 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/proc_stats.py	2024-10-08 17:45:43.667278026 -0400
@@ -6,12 +6,16 @@
 
 from __future__ import annotations
 import asyncio
+import struct
+import fcntl
 import time
 import re
 import os
 import pathlib
 import logging
 from collections import deque
+from ..utils import ioctl_macros
+from ..common import RequestType
 
 # Annotation imports
 from typing import (
@@ -26,12 +30,13 @@
     Dict,
 )
 if TYPE_CHECKING:
-    from confighelper import ConfigHelper
-    from websockets import WebRequest, WebsocketManager
-    from . import shell_command
+    from ..confighelper import ConfigHelper
+    from ..common import WebRequest
+    from .websockets import WebsocketManager
     STAT_CALLBACK = Callable[[int], Optional[Awaitable]]
 
 VC_GEN_CMD_FILE = "/usr/bin/vcgencmd"
+VCIO_PATH = "/dev/vcio"
 STATM_FILE_PATH = "/proc/self/smaps_rollup"
 NET_DEV_PATH = "/proc/net/dev"
 TEMPERATURE_PATH = "/sys/class/thermal/thermal_zone0/temp"
@@ -61,13 +66,10 @@
         self.watchdog = Watchdog(self)
         self.stat_update_timer = self.event_loop.register_timer(
             self._handle_stat_update)
-        self.vcgencmd: Optional[shell_command.ShellCommand] = None
-        if os.path.exists(VC_GEN_CMD_FILE):
+        self.vcgencmd: Optional[VCGenCmd] = None
+        if os.path.exists(VC_GEN_CMD_FILE) and os.path.exists(VCIO_PATH):
             logging.info("Detected 'vcgencmd', throttle checking enabled")
-            shell_cmd: shell_command.ShellCommandFactory
-            shell_cmd = self.server.load_component(config, "shell_command")
-            self.vcgencmd = shell_cmd.build_shell_command(
-                "vcgencmd get_throttled")
+            self.vcgencmd = VCGenCmd()
             self.server.register_notification("proc_stats:cpu_throttled")
         else:
             logging.info("Unable to find 'vcgencmd', throttle checking "
@@ -78,9 +80,11 @@
         self.cpu_stats_file = pathlib.Path(CPU_STAT_PATH)
         self.meminfo_file = pathlib.Path(MEM_AVAIL_PATH)
         self.server.register_endpoint(
-            "/machine/proc_stats", ["GET"], self._handle_stat_request)
+            "/machine/proc_stats", RequestType.GET, self._handle_stat_request
+        )
         self.server.register_event_handler(
-            "server:klippy_shutdown", self._handle_shutdown)
+            "server:klippy_shutdown", self._handle_shutdown
+        )
         self.server.register_notification("proc_stats:proc_stat_update")
         self.proc_stat_queue: Deque[Dict[str, Any]] = deque(maxlen=30)
         self.last_update_time = time.time()
@@ -170,17 +174,19 @@
             'system_memory': self.memory_usage,
             'websocket_connections': websocket_count
         })
-        if not self.update_sequence % THROTTLE_CHECK_INTERVAL:
-            if self.vcgencmd is not None:
-                ts = await self._check_throttled_state()
-                cur_throttled = ts['bits']
-                if cur_throttled & ~self.total_throttled:
-                    self.server.add_log_rollover_item(
-                        'throttled', f"CPU Throttled Flags: {ts['flags']}")
-                if cur_throttled != self.last_throttled:
-                    self.server.send_event("proc_stats:cpu_throttled", ts)
-                self.last_throttled = cur_throttled
-                self.total_throttled |= cur_throttled
+        if (
+            not self.update_sequence % THROTTLE_CHECK_INTERVAL
+            and self.vcgencmd is not None
+        ):
+            ts = await self._check_throttled_state()
+            cur_throttled = ts['bits']
+            if cur_throttled & ~self.total_throttled:
+                self.server.add_log_rollover_item(
+                    'throttled', f"CPU Throttled Flags: {ts['flags']}")
+            if cur_throttled != self.last_throttled:
+                self.server.send_event("proc_stats:cpu_throttled", ts)
+            self.last_throttled = cur_throttled
+            self.total_throttled |= cur_throttled
         for cb in self.stat_callbacks:
             ret = cb(self.update_sequence)
             if ret is not None:
@@ -191,19 +197,18 @@
         return eventtime + STAT_UPDATE_TIME
 
     async def _check_throttled_state(self) -> Dict[str, Any]:
-        async with self.throttle_check_lock:
-            assert self.vcgencmd is not None
-            try:
-                resp = await self.vcgencmd.run_with_response(
-                    timeout=.5, log_complete=False)
-                ts = int(resp.strip().split("=")[-1], 16)
-            except Exception:
-                return {'bits': 0, 'flags': ["?"]}
-            flags = []
-            for flag, desc in THROTTLED_FLAGS.items():
-                if flag & ts:
-                    flags.append(desc)
-            return {'bits': ts, 'flags': flags}
+        ret = {'bits': 0, 'flags': ["?"]}
+        if self.vcgencmd is not None:
+            async with self.throttle_check_lock:
+                try:
+                    resp = await self.event_loop.run_in_thread(self.vcgencmd.run)
+                    ret["bits"] = tstate = int(resp.strip().split("=")[-1], 16)
+                    ret["flags"] = [
+                        desc for flag, desc in THROTTLED_FLAGS.items() if flag & tstate
+                    ]
+                except Exception:
+                    pass
+        return ret
 
     def _read_system_files(self) -> Tuple:
         mem, units = self._get_memory_usage()
@@ -242,7 +247,13 @@
                 parsed_stats = stats.strip().split()
                 net_stats[dev_name] = {
                     'rx_bytes': int(parsed_stats[0]),
-                    'tx_bytes': int(parsed_stats[8])
+                    'tx_bytes': int(parsed_stats[8]),
+                    'rx_packets': int(parsed_stats[1]),
+                    'tx_packets': int(parsed_stats[9]),
+                    'rx_errs': int(parsed_stats[2]),
+                    'tx_errs': int(parsed_stats[10]),
+                    'rx_drop': int(parsed_stats[3]),
+                    'tx_drop': int(parsed_stats[11])
                 }
             return net_stats
         except Exception:
@@ -332,5 +343,52 @@
     def stop(self):
         self.watchdog_timer.stop()
 
+class VCGenCmd:
+    """
+    This class uses the BCM2835 Mailbox to directly query the throttled
+    state.  This should be less resource intensive than calling "vcgencmd"
+    in a subprocess.
+    """
+    MAX_STRING_SIZE = 1024
+    GET_RESULT_CMD = 0x00030080
+    UINT_SIZE = struct.calcsize("@I")
+    def __init__(self) -> None:
+        self.cmd_struct = struct.Struct(f"@6I{self.MAX_STRING_SIZE}sI")
+        self.cmd_buf = bytearray(self.cmd_struct.size)
+        self.mailbox_req = ioctl_macros.IOWR(100, 0, "c_char_p")
+        self.err_logged: bool = False
+
+    def run(self, cmd: str = "get_throttled") -> str:
+        try:
+            fd = os.open(VCIO_PATH, os.O_RDWR)
+            self.cmd_struct.pack_into(
+                self.cmd_buf, 0,
+                self.cmd_struct.size,
+                0x00000000,
+                self.GET_RESULT_CMD,
+                self.MAX_STRING_SIZE,
+                0,
+                0,
+                cmd.encode("utf-8"),
+                0x00000000
+            )
+            fcntl.ioctl(fd, self.mailbox_req, self.cmd_buf)
+        except OSError:
+            if not self.err_logged:
+                logging.exception("VCIO vcgencmd failed")
+                self.err_logged = True
+            return ""
+        finally:
+            os.close(fd)
+        result = self.cmd_struct.unpack_from(self.cmd_buf)
+        ret: int = result[5]
+        if ret:
+            logging.info(f"vcgencmd returned {ret}")
+        resp: bytes = result[6]
+        null_index = resp.find(b'\x00')
+        if null_index <= 0:
+            return ""
+        return resp[:null_index].decode()
+
 def load_component(config: ConfigHelper) -> ProcStats:
     return ProcStats(config)
