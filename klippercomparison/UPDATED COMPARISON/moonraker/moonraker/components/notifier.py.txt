Differences in moonraker/components/notifier.py:

- Lines with differences: 211 lines in 3 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/notifier.py	2022-07-25 05:53:30.906869297 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/notifier.py	2024-10-08 17:45:43.666278023 -0400
@@ -8,114 +8,112 @@
 
 import apprise
 import logging
+import pathlib
+import re
+from ..common import JobEvent, RequestType
 
 # Annotation imports
 from typing import (
     TYPE_CHECKING,
-    Type,
-    Optional,
     Dict,
     Any,
     List,
-    Union,
 )
 
 if TYPE_CHECKING:
-    from confighelper import ConfigHelper
-    from . import klippy_apis
-
-    APIComp = klippy_apis.KlippyAPI
-
+    from ..confighelper import ConfigHelper
+    from ..common import WebRequest
+    from .file_manager.file_manager import FileManager
+    from .klippy_apis import KlippyAPI as APIComp
 
 class Notifier:
     def __init__(self, config: ConfigHelper) -> None:
         self.server = config.get_server()
         self.notifiers: Dict[str, NotifierInstance] = {}
-        self.events: Dict[str, NotifierEvent] = {}
+        self.events: Dict[str, List[NotifierInstance]] = {}
         prefix_sections = config.get_prefix_sections("notifier")
-
-        self.register_events(config)
-
+        self.register_remote_actions()
         for section in prefix_sections:
             cfg = config[section]
             try:
                 notifier = NotifierInstance(cfg)
-
-                for event in self.events:
-                    if event in notifier.events or "*" in notifier.events:
-                        self.events[event].register_notifier(notifier)
-
+                for job_event in list(JobEvent):
+                    if job_event == JobEvent.STANDBY:
+                        continue
+                    evt_name = str(job_event)
+                    if "*" in notifier.events or evt_name in notifier.events:
+                        self.events.setdefault(evt_name, []).append(notifier)
                 logging.info(f"Registered notifier: '{notifier.get_name()}'")
-
             except Exception as e:
                 msg = f"Failed to load notifier[{cfg.get_name()}]\n{e}"
-                self.server.add_warning(msg)
+                self.server.add_warning(msg, exc_info=e)
                 continue
             self.notifiers[notifier.get_name()] = notifier
 
-    def register_events(self, config: ConfigHelper):
-
-        self.events["started"] = NotifierEvent(
-            "started",
-            "job_state:started",
-            config)
-
-        self.events["complete"] = NotifierEvent(
-            "complete",
-            "job_state:complete",
-            config)
-
-        self.events["error"] = NotifierEvent(
-            "error",
-            "job_state:error",
-            config)
-
-        self.events["cancelled"] = NotifierEvent(
-            "cancelled",
-            "job_state:cancelled",
-            config)
-
-        self.events["paused"] = NotifierEvent(
-            "paused",
-            "job_state:paused",
-            config)
-
-        self.events["resumed"] = NotifierEvent(
-            "resumed",
-            "job_state:resumed",
-            config)
-
-
-class NotifierEvent:
-    def __init__(self, identifier: str, event_name: str, config: ConfigHelper):
-        self.identifier = identifier
-        self.event_name = event_name
-        self.server = config.get_server()
-        self.notifiers: Dict[str, NotifierInstance] = {}
-        self.config = config
-
-        self.server.register_event_handler(self.event_name, self._handle)
-
-    def register_notifier(self, notifier: NotifierInstance):
-        self.notifiers[notifier.get_name()] = notifier
+        self.register_endpoints(config)
+        self.server.register_event_handler(
+            "job_state:state_changed", self._on_job_state_changed
+        )
 
-    async def _handle(self, *args) -> None:
-        logging.info(f"'{self.identifier}' notifier event triggered'")
-        await self.invoke_notifiers(args)
+    def register_remote_actions(self):
+        self.server.register_remote_method("notify", self.notify_action)
 
-    async def invoke_notifiers(self, args):
-        for notifier_name in self.notifiers:
-            try:
-                notifier = self.notifiers[notifier_name]
-                await notifier.notify(self.identifier, args)
-            except Exception as e:
-                logging.info(f"Failed to notify [{notifier_name}]\n{e}")
-                continue
+    async def notify_action(self, name: str, message: str = ""):
+        if name not in self.notifiers:
+            raise self.server.error(f"Notifier '{name}' not found", 404)
+        notifier = self.notifiers[name]
+        await notifier.notify("remote_action", [], message)
+
+    async def _on_job_state_changed(
+            self,
+            job_event: JobEvent,
+            prev_stats: Dict[str, Any],
+            new_stats: Dict[str, Any]
+    ) -> None:
+        evt_name = str(job_event)
+        for notifier in self.events.get(evt_name, []):
+            await notifier.notify(evt_name, [prev_stats, new_stats])
+
+    def register_endpoints(self, config: ConfigHelper):
+        self.server.register_endpoint(
+            "/server/notifiers/list", RequestType.GET, self._handle_notifier_list
+        )
+        self.server.register_debug_endpoint(
+            "/debug/notifiers/test", RequestType.POST, self._handle_notifier_test
+        )
 
+    async def _handle_notifier_list(
+        self, web_request: WebRequest
+    ) -> Dict[str, Any]:
+        return {"notifiers": self._list_notifiers()}
+
+    def _list_notifiers(self) -> List[Dict[str, Any]]:
+        return [notifier.as_dict() for notifier in self.notifiers.values()]
+
+    async def _handle_notifier_test(
+        self, web_request: WebRequest
+    ) -> Dict[str, Any]:
+
+        name = web_request.get_str("name")
+        if name not in self.notifiers:
+            raise self.server.error(f"Notifier '{name}' not found", 404)
+        notifier = self.notifiers[name]
+
+        kapis: APIComp = self.server.lookup_component('klippy_apis')
+        result: Dict[str, Any] = await kapis.query_objects(
+            {'print_stats': None}, default={})
+        print_stats = result.get('print_stats', {})
+        print_stats["filename"] = "notifier_test.gcode"  # Mock the filename
+
+        await notifier.notify(notifier.events[0], [print_stats, print_stats])
+
+        return {
+            "status": "success",
+            "stats": print_stats
+        }
 
 class NotifierInstance:
     def __init__(self, config: ConfigHelper) -> None:
-
         self.config = config
         name_parts = config.get_name().split(maxsplit=1)
         if len(name_parts) != 2:
@@ -123,32 +121,40 @@
         self.server = config.get_server()
         self.name = name_parts[1]
         self.apprise = apprise.Apprise()
-        self.warned = False
-
-        self.attach_requires_file_system_check = True
-        self.attach = config.get("attach", None)
-        if self.attach is None or \
-            (self.attach.startswith("http://") or
-             self.attach.startswith("https://")):
-            self.attach_requires_file_system_check = False
-
-        url_template = config.gettemplate('url')
+        self.attach = config.gettemplate("attach", None)
+        url_template = config.gettemplate("url")
         self.url = url_template.render()
 
-        if len(self.url) < 2:
+        if re.match(r"\w+?://", self.url) is None:
             raise config.error(f"Invalid url for: {config.get_name()}")
 
-        self.title = config.gettemplate('title', None)
+        self.title = config.gettemplate("title", None)
         self.body = config.gettemplate("body", None)
-
+        upper_body_format = config.get("body_format", 'text').upper()
+        if not hasattr(apprise.NotifyFormat, upper_body_format):
+            raise config.error(f"Invalid body_format for {config.get_name()}")
+        self.body_format = getattr(apprise.NotifyFormat, upper_body_format)
         self.events: List[str] = config.getlist("events", separator=",")
-
         self.apprise.add(self.url)
 
-    async def notify(self, event_name: str, event_args: List) -> None:
+    def as_dict(self):
+        return {
+            "name": self.name,
+            "url": self.config.get("url"),
+            "title": self.config.get("title", None),
+            "body": self.config.get("body", None),
+            "body_format": self.config.get("body_format", None),
+            "events": self.events,
+            "attach": self.attach
+        }
+
+    async def notify(
+        self, event_name: str, event_args: List, message: str = ""
+    ) -> None:
         context = {
             "event_name": event_name,
-            "event_args": event_args
+            "event_args": event_args,
+            "event_message": message
         }
 
         rendered_title = (
@@ -159,22 +165,47 @@
         )
 
         # Verify the attachment
-        if self.attach_requires_file_system_check and self.attach is not None:
-            fm = self.server.lookup_component("file_manager")
-            if not fm.can_access_path(self.attach):
-                if not self.warned:
-                    self.server.add_warning(
-                        f"Attachment of notifier '{self.name}' is not "
-                        "valid. The location of the "
-                        "attachment is not "
-                        "accessible.")
-                    self.warned = True
+        attachments: List[str] = []
+        if self.attach is not None:
+            fm: FileManager = self.server.lookup_component("file_manager")
+            try:
+                rendered = self.attach.render(context)
+            except self.server.error as e:
+                self.server.add_warning(
+                    f"[notifier {self.name}]: The attachment is not valid. The "
+                    "template failed to render.",
+                    f"notifier {self.name}",
+                    exc_info=e
+                )
                 self.attach = None
-
+            else:
+                for item in rendered.splitlines():
+                    item = item.strip()
+                    if not item:
+                        continue
+                    if re.match(r"https?://", item) is not None:
+                        # Attachment is a url, system check not necessary
+                        attachments.append(item)
+                        continue
+                    attach_path = pathlib.Path(item).expanduser().resolve()
+                    if not attach_path.is_file():
+                        self.server.add_warning(
+                            f"[notifier {self.name}]: Invalid attachment detected, "
+                            f"file does not exist: {attach_path}.",
+                            f"notifier {self.name}"
+                        )
+                    elif not fm.can_access_path(attach_path):
+                        self.server.add_warning(
+                            f"[notifier {self.name}]: Invalid attachment detected, "
+                            f"no read permission for the file {attach_path}.",
+                            f"notifier {self.name}"
+                        )
+                    else:
+                        attachments.append(str(attach_path))
         await self.apprise.async_notify(
-            rendered_body.strip(),
-            rendered_title.strip(),
-            attach=self.attach
+            rendered_body.strip(), rendered_title.strip(),
+            body_format=self.body_format,
+            attach=None if not attachments else attachments
         )
 
     def get_name(self) -> str:
