Differences in moonraker/components/update_manager/app_deploy.py:

- Lines with differences: 455 lines in 8 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/moonraker/moonraker/components/update_manager/app_deploy.py	2022-07-25 05:53:30.910869307 -0400
+++ /home/mks/firmware_comparison/downloads/moonraker/moonraker/components/update_manager/app_deploy.py	2024-10-08 17:45:43.667278026 -0400
@@ -5,11 +5,18 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 
 from __future__ import annotations
+import os
 import pathlib
-import shutil
 import hashlib
 import logging
+import re
+import distro
+import asyncio
+import importlib
+from .common import AppType, Channel
 from .base_deploy import BaseDeploy
+from ...utils import pip_utils
+from ...utils import json_wrapper as jsonw
 
 # Annotation imports
 from typing import (
@@ -19,67 +26,127 @@
     Union,
     Dict,
     List,
+    Tuple
 )
 if TYPE_CHECKING:
-    from confighelper import ConfigHelper
+    from ...confighelper import ConfigHelper
+    from ..klippy_connection import KlippyConnection as Klippy
     from .update_manager import CommandHelper
     from ..machine import Machine
+    from ..file_manager.file_manager import FileManager
 
-SUPPORTED_CHANNELS = {
-    "zip": ["stable", "beta"],
-    "git_repo": ["dev", "beta"]
-}
-TYPE_TO_CHANNEL = {
-    "zip": "stable",
-    "zip_beta": "beta",
-    "git_repo": "dev"
-}
+DISTRO_ALIASES = [distro.id()]
+DISTRO_ALIASES.extend(distro.like().split())
 
 class AppDeploy(BaseDeploy):
-    def __init__(self, config: ConfigHelper, cmd_helper: CommandHelper) -> None:
-        super().__init__(config, cmd_helper, prefix="Application")
+    def __init__(
+            self, config: ConfigHelper, cmd_helper: CommandHelper, prefix: str
+    ) -> None:
+        super().__init__(config, cmd_helper, prefix=prefix)
         self.config = config
-        self.debug = self.cmd_helper.is_debug_enabled()
-        type_choices = list(TYPE_TO_CHANNEL.keys())
-        self.type = config.get('type').lower()
-        if self.type not in type_choices:
-            raise config.error(
-                f"Config Error: Section [{config.get_name()}], Option "
-                f"'type: {self.type}': value must be one "
-                f"of the following choices: {type_choices}"
-            )
-        self.channel = config.get(
-            "channel", TYPE_TO_CHANNEL[self.type]
+        type_choices = {str(t): t for t in AppType.valid_types()}
+        self.type = config.getchoice("type", type_choices)
+        channel_choices = {str(chnl): chnl for chnl in list(Channel)}
+        self.channel = config.getchoice(
+            "channel", channel_choices, str(self.type.default_channel)
         )
-        if self.type == "zip_beta":
+        self.channel_invalid: bool = False
+        if self.channel not in self.type.supported_channels:
+            str_channels = [str(c) for c in self.type.supported_channels]
+            self.channel_invalid = True
+            invalid_channel = self.channel
+            self.channel = self.type.default_channel
             self.server.add_warning(
-                f"Config Section [{config.get_name()}], Option 'type: "
-                "zip_beta', value 'zip_beta' is deprecated.  Set 'type' "
-                "to zip and 'channel' to 'beta'")
-            self.type = "zip"
-        self.path = pathlib.Path(
-            config.get('path')).expanduser().resolve()
-        executable = config.get('env', None)
-        if self.channel not in SUPPORTED_CHANNELS[self.type]:
-            raise config.error(
-                f"Invalid Channel '{self.channel}' for config "
-                f"section [{config.get_name()}], type: {self.type}")
-        self._verify_path(config, 'path', self.path)
-        self.executable: Optional[pathlib.Path] = None
-        self.pip_exe: Optional[pathlib.Path] = None
+                f"[{config.get_name()}]: Invalid value '{invalid_channel}' for "
+                f"option 'channel'. Type '{self.type}' supports the following "
+                f"channels: {str_channels}.  Falling back to channel '{self.channel}'"
+            )
+        self._is_valid: bool = False
+        self.virtualenv: Optional[pathlib.Path] = None
+        self.py_exec: Optional[pathlib.Path] = None
+        self.pip_cmd: Optional[str] = None
+        self.pip_version: Tuple[int, ...] = tuple()
         self.venv_args: Optional[str] = None
-        if executable is not None:
-            self.executable = pathlib.Path(executable).expanduser()
-            self.pip_exe = self.executable.parent.joinpath("pip")
-            if not self.pip_exe.exists():
-                self.server.add_warning(
-                    f"Update Manger {self.name}: Unable to locate pip "
-                    "executable")
-            self._verify_path(config, 'env', self.executable)
-            self.venv_args = config.get('venv_args', None)
-
+        self.npm_pkg_json: Optional[pathlib.Path] = None
+        self.python_reqs: Optional[pathlib.Path] = None
+        self.install_script: Optional[pathlib.Path] = None
+        self.system_deps_json: Optional[pathlib.Path] = None
         self.info_tags: List[str] = config.getlist("info_tags", [])
         self.managed_services: List[str] = []
+
+    def _configure_path(self, config: ConfigHelper, reserve: bool = True) -> None:
+        self.path = pathlib.Path(config.get('path')).expanduser().resolve()
+        self._verify_path(config, 'path', self.path, check_file=False)
+        if (
+            reserve and self.name not in ["moonraker", "klipper"]
+            and not self.path.joinpath(".writeable").is_file()
+        ):
+            fm: FileManager = self.server.lookup_component("file_manager")
+            fm.add_reserved_path(f"update_manager {self.name}", self.path)
+
+    def _configure_virtualenv(self, config: ConfigHelper) -> None:
+        venv_path: Optional[pathlib.Path] = None
+        if config.has_option("virtualenv"):
+            venv_path = pathlib.Path(config.get("virtualenv")).expanduser()
+            if not venv_path.is_absolute():
+                venv_path = self.path.joinpath(venv_path)
+            self._verify_path(config, 'virtualenv', venv_path, check_file=False)
+        elif config.has_option("env"):
+            # Deprecated
+            if self.name != "klipper":
+                self.log_info("Option 'env' is deprecated, use 'virtualenv' instead.")
+            py_exec = pathlib.Path(config.get("env")).expanduser()
+            self._verify_path(config, 'env', py_exec, check_exe=True)
+            venv_path = py_exec.expanduser().parent.parent.resolve()
+        if venv_path is not None:
+            act_path = venv_path.joinpath("bin/activate")
+            if not act_path.is_file():
+                raise config.error(
+                    f"[{config.get_name()}]: Invalid virtualenv at path {venv_path}. "
+                    f"Verify that the 'virtualenv' option is set to a valid "
+                    "virtualenv path."
+                )
+            self.py_exec = venv_path.joinpath("bin/python")
+            if not (self.py_exec.is_file() and os.access(self.py_exec, os.X_OK)):
+                raise config.error(
+                    f"[{config.get_name()}]: Invalid python executable at "
+                    f"{self.py_exec}. Verify that the 'virtualenv' option is set "
+                    "to a valid virtualenv path."
+                )
+            self.log_info(f"Detected virtualenv: {venv_path}")
+            self.virtualenv = venv_path
+            pip_exe = self.virtualenv.joinpath("bin/pip")
+            if pip_exe.is_file():
+                self.pip_cmd = f"{self.py_exec} -m pip"
+            else:
+                self.log_info("Unable to locate pip executable")
+        self.venv_args = config.get('venv_args', None)
+        self.pip_env_vars = config.getdict("pip_environment_variables", None)
+
+    def _configure_dependencies(
+        self, config: ConfigHelper, node_only: bool = False
+    ) -> None:
+        if config.getboolean("enable_node_updates", False):
+            self.npm_pkg_json = self.path.joinpath("package-lock.json")
+            self._verify_path(config, 'enable_node_updates', self.npm_pkg_json)
+        if node_only:
+            return
+        if self.py_exec is not None:
+            self.python_reqs = self.path.joinpath(config.get("requirements"))
+            self._verify_path(config, 'requirements', self.python_reqs)
+        deps = config.get("system_dependencies", None)
+        if deps is not None:
+            self.system_deps_json = self.path.joinpath(deps).resolve()
+            self._verify_path(config, 'system_dependencies', self.system_deps_json)
+        else:
+            # Fall back on deprecated "install_script" option if dependencies file
+            # not present
+            install_script = config.get('install_script', None)
+            if install_script is not None:
+                self.install_script = self.path.joinpath(install_script).resolve()
+                self._verify_path(config, 'install_script', self.install_script)
+
+    def _configure_managed_services(self, config: ConfigHelper) -> None:
         svc_default = []
         if config.getboolean("is_system_service", True):
             svc_default.append(self.name)
@@ -87,11 +154,25 @@
         services: List[str] = config.getlist(
             "managed_services", svc_default, separator=None
         )
+        if self.name in services:
+            machine: Machine = self.server.lookup_component("machine")
+            data_path: str = self.server.get_app_args()["data_path"]
+            asvc = pathlib.Path(data_path).joinpath("moonraker.asvc")
+            if not machine.is_service_allowed(self.name):
+                self.server.add_warning(
+                    f"[{config.get_name()}]: Moonraker is not permitted to "
+                    f"restart service '{self.name}'.  To enable management "
+                    f"of this service add {self.name} to the bottom of the "
+                    f"file {asvc}.  To disable management for this service "
+                    "set 'is_system_service: False' in the configuration "
+                    "for this section."
+                )
+                services.clear()
         for svc in services:
             if svc not in svc_choices:
                 raw = " ".join(services)
                 self.server.add_warning(
-                    f"[{config.get_name()}]: Option 'restart_action: {raw}' "
+                    f"[{config.get_name()}]: Option 'managed_services: {raw}' "
                     f"contains an invalid value '{svc}'.  All values must be "
                     f"one of the following choices: {svc_choices}"
                 )
@@ -99,56 +180,38 @@
         for svc in svc_choices:
             if svc in services and svc not in self.managed_services:
                 self.managed_services.append(svc)
-        logging.debug(
-            f"Extension {self.name} managed services: {self.managed_services}"
+        self.log_debug(
+            f"Managed services: {self.managed_services}"
         )
-        # We need to fetch all potential options for an Application.  Not
-        # all options apply to each subtype, however we can't limit the
-        # options in children if we want to switch between channels and
-        # satisfy the confighelper's requirements.
-        self.moved_origin: Optional[str] = config.get('moved_origin', None)
-        self.origin: str = config.get('origin')
-        self.primary_branch = config.get("primary_branch", "master")
-        self.npm_pkg_json: Optional[pathlib.Path] = None
-        if config.getboolean("enable_node_updates", False):
-            self.npm_pkg_json = self.path.joinpath("package-lock.json")
-            self._verify_path(config, 'enable_node_updates', self.npm_pkg_json)
-        self.python_reqs: Optional[pathlib.Path] = None
-        if self.executable is not None:
-            self.python_reqs = self.path.joinpath(config.get("requirements"))
-            self._verify_path(config, 'requirements', self.python_reqs)
-        self.install_script: Optional[pathlib.Path] = None
-        install_script = config.get('install_script', None)
-        if install_script is not None:
-            self.install_script = self.path.joinpath(install_script).resolve()
-            self._verify_path(config, 'install_script', self.install_script)
 
-    @staticmethod
-    def _is_git_repo(app_path: Union[str, pathlib.Path]) -> bool:
-        if isinstance(app_path, str):
-            app_path = pathlib.Path(app_path).expanduser()
-        return app_path.joinpath('.git').exists()
+    def _verify_path(
+        self,
+        config: ConfigHelper,
+        option: str,
+        path: pathlib.Path,
+        check_file: bool = True,
+        check_exe: bool = False
+    ) -> None:
+        base_msg = (
+            f"Invalid path for option `{option}` in section "
+            f"[{config.get_name()}]: Path `{path}`"
+        )
+        if not path.exists():
+            raise config.error(f"{base_msg} does not exist")
+        if check_file and not path.is_file():
+            raise config.error(f"{base_msg} is not a file")
+        if check_exe and not os.access(path, os.X_OK):
+            raise config.error(f"{base_msg} is not executable")
 
     async def initialize(self) -> Dict[str, Any]:
         storage = await super().initialize()
-        self.need_channel_update = storage.get('need_channel_upate', False)
-        self._is_valid = storage.get('is_valid', False)
+        self.pip_version = tuple(storage.get("pip_version", []))
+        if self.pip_version:
+            ver_str = ".".join([str(part) for part in self.pip_version])
+            self.log_info(f"Stored pip version: {ver_str}")
         return storage
 
-    def _verify_path(self,
-                     config: ConfigHelper,
-                     option: str,
-                     file_path: pathlib.Path
-                     ) -> None:
-        if not file_path.exists():
-            raise config.error(
-                f"Invalid path for option `{option}` in section "
-                f"[{config.get_name()}]: Path `{file_path}` does not exist")
-
-    def check_need_channel_swap(self) -> bool:
-        return self.need_channel_update
-
-    def get_configured_type(self) -> str:
+    def get_configured_type(self) -> AppType:
         return self.type
 
     def check_same_paths(self,
@@ -161,11 +224,13 @@
             executable = pathlib.Path(executable)
         app_path = app_path.expanduser()
         executable = executable.expanduser()
-        if self.executable is None:
+        if self.py_exec is None:
             return False
         try:
-            return self.path.samefile(app_path) and \
-                self.executable.samefile(executable)
+            return (
+                self.path.samefile(app_path) and
+                self.py_exec.samefile(executable)
+            )
         except Exception:
             return False
 
@@ -175,12 +240,10 @@
                       ) -> None:
         raise NotImplementedError
 
-    async def reinstall(self):
-        raise NotImplementedError
-
-    async def restart_service(self):
+    async def restart_service(self) -> None:
         if not self.managed_services:
             return
+        machine: Machine = self.server.lookup_component("machine")
         is_full = self.cmd_helper.is_full_update()
         for svc in self.managed_services:
             if is_full and svc != self.name:
@@ -192,36 +255,89 @@
             if svc == "moonraker":
                 # Launch restart async so the request can return
                 # before the server restarts
-                event_loop = self.server.get_event_loop()
-                event_loop.delay_callback(.1, self._do_restart, svc)
+                machine.restart_moonraker_service()
             else:
-                await self._do_restart(svc)
-
-    async def _do_restart(self, svc_name: str) -> None:
-        machine: Machine = self.server.lookup_component("machine")
+                if svc == "klipper":
+                    kconn: Klippy = self.server.lookup_component("klippy_connection")
+                    svc = kconn.unit_name
+                await machine.do_service_action("restart", svc)
+
+    async def _read_system_dependencies(self) -> List[str]:
+        eventloop = self.server.get_event_loop()
+        if self.system_deps_json is not None:
+            deps_json = self.system_deps_json
+            try:
+                ret = await eventloop.run_in_thread(deps_json.read_bytes)
+                dep_info: Dict[str, List[str]] = jsonw.loads(ret)
+            except asyncio.CancelledError:
+                raise
+            except Exception:
+                logging.exception(f"Error reading system deps: {deps_json}")
+                return []
+            for distro_id in DISTRO_ALIASES:
+                if distro_id in dep_info:
+                    if not dep_info[distro_id]:
+                        self.log_info(
+                            f"Dependency file '{deps_json.name}' contains an empty "
+                            f"package definition for linux distro '{distro_id}'"
+                        )
+                    return dep_info[distro_id]
+            else:
+                self.log_info(
+                    f"Dependency file '{deps_json.name}' has no package definition "
+                    f" for linux distro '{DISTRO_ALIASES[0]}'"
+                )
+                return []
+        # Fall back on install script if configured
+        if self.install_script is None:
+            return []
+        # Open install file file and read
+        inst_path: pathlib.Path = self.install_script
+        if not inst_path.is_file():
+            self.log_info(f"Failed to open install script: {inst_path}")
+            return []
         try:
-            await machine.do_service_action("restart", svc_name)
+            data = await eventloop.run_in_thread(inst_path.read_text)
+        except asyncio.CancelledError:
+            raise
         except Exception:
-            if svc_name == "moonraker":
-                # We will always get an error when restarting moonraker
-                # from within the child process, so ignore it
-                return
-            raise self.log_exc("Error restarting service")
+            logging.exception(f"Error reading install script: {inst_path}")
+            return []
+        plines: List[str] = re.findall(r'PKGLIST="(.*)"', data)
+        plines = [p.lstrip("${PKGLIST}").strip() for p in plines]
+        packages: List[str] = []
+        for line in plines:
+            packages.extend(line.split())
+        if not packages:
+            self.log_info(f"No packages found in script: {inst_path}")
+        return packages
+
+    async def _read_python_reqs(self) -> List[str]:
+        if self.python_reqs is None:
+            return []
+        pyreqs = self.python_reqs
+        if not pyreqs.is_file():
+            self.log_info(f"Failed to open python requirements file: {pyreqs}")
+            return []
+        eventloop = self.server.get_event_loop()
+        return await eventloop.run_in_thread(
+            pip_utils.read_requirements_file, self.python_reqs
+        )
 
     def get_update_status(self) -> Dict[str, Any]:
         return {
-            'channel': self.channel,
-            'debug_enabled': self.debug,
-            'need_channel_update': self.need_channel_update,
+            'channel': str(self.channel),
+            'debug_enabled': self.server.is_debug_enabled(),
+            'channel_invalid': self.channel_invalid,
             'is_valid': self._is_valid,
-            'configured_type': self.type,
+            'configured_type': str(self.type),
             'info_tags': self.info_tags
         }
 
     def get_persistent_data(self) -> Dict[str, Any]:
         storage = super().get_persistent_data()
         storage['is_valid'] = self._is_valid
-        storage['need_channel_update'] = self.need_channel_update
+        storage['pip_version'] = list(self.pip_version)
         return storage
 
     async def _get_file_hash(self,
@@ -257,45 +373,93 @@
             self.log_exc("Error updating packages")
             return
 
-    async def _update_virtualenv(self,
-                                 requirements: Union[pathlib.Path, List[str]]
-                                 ) -> None:
-        if self.pip_exe is None:
+    async def _update_python_requirements(
+        self, requirements: Union[pathlib.Path, List[str]]
+    ) -> None:
+        if self.pip_cmd is None:
             return
-        # Update python dependencies
-        if isinstance(requirements, pathlib.Path):
-            if not requirements.is_file():
-                self.log_info(
-                    f"Invalid path to requirements_file '{requirements}'")
-                return
-            args = f"-r {requirements}"
-        else:
-            args = " ".join(requirements)
+        if self.name == "moonraker":
+            importlib.reload(pip_utils)
+        pip_exec = pip_utils.AsyncPipExecutor(
+            self.pip_cmd, self.server, self.cmd_helper.notify_update_response
+        )
+        # Check and update the pip version
+        await self._update_pip(pip_exec)
         self.notify_status("Updating python packages...")
         try:
-            # First attempt to update pip
-            # await self.cmd_helper.run_cmd(
-            #     f"{self.pip_exe} install -U pip", timeout=1200., notify=True,
-            #     retries=3)
-            await self.cmd_helper.run_cmd(
-                f"{self.pip_exe} install {args}", timeout=1200., notify=True,
-                retries=3)
+            await pip_exec.install_packages(requirements, self.pip_env_vars)
+        except asyncio.CancelledError:
+            raise
         except Exception:
             self.log_exc("Error updating python requirements")
 
-    async def _build_virtualenv(self) -> None:
-        if self.pip_exe is None or self.venv_args is None:
-            return
-        bin_dir = self.pip_exe.parent
-        env_path = bin_dir.parent.resolve()
-        self.notify_status(f"Creating virtualenv at: {env_path}...")
-        if env_path.exists():
-            shutil.rmtree(env_path)
+    async def _update_pip(self, pip_exec: pip_utils.AsyncPipExecutor) -> None:
+        self.notify_status("Checking pip version...")
         try:
-            await self.cmd_helper.run_cmd(
-                f"virtualenv {self.venv_args} {env_path}", timeout=300.)
-        except Exception:
-            self.log_exc(f"Error creating virtualenv")
-            return
-        if not self.pip_exe.exists():
-            raise self.log_exc("Failed to create new virtualenv", False)
+            pip_ver = await pip_exec.get_pip_version()
+            if pip_utils.check_pip_needs_update(pip_ver):
+                cur_ver = pip_ver.pip_version_string
+                update_ver = ".".join([str(part) for part in pip_utils.MIN_PIP_VERSION])
+                self.notify_status(
+                    f"Updating pip from version {cur_ver} to {update_ver}..."
+                )
+                await pip_exec.update_pip()
+                self.pip_version = pip_utils.MIN_PIP_VERSION
+            else:
+                self.notify_status("Pip version up to date")
+        except asyncio.CancelledError:
+            raise
+        except Exception as e:
+            self.notify_status(f"Pip Version Check Error: {e}")
+            self.log_exc("Pip Version Check Error")
+
+    async def _collect_dependency_info(self) -> Dict[str, Any]:
+        pkg_deps = await self._read_system_dependencies()
+        pyreqs = await self._read_python_reqs()
+        npm_hash = await self._get_file_hash(self.npm_pkg_json)
+        logging.debug(
+            f"\nApplication {self.name}: Pre-update dependencies:\n"
+            f"Packages: {pkg_deps}\n"
+            f"Python Requirements: {pyreqs}"
+        )
+        return {
+            "system_packages": pkg_deps,
+            "python_modules": pyreqs,
+            "npm_hash": npm_hash
+        }
+
+    async def _update_dependencies(
+        self, dep_info: Dict[str, Any], force: bool = False
+    ) -> None:
+        packages = await self._read_system_dependencies()
+        modules = await self._read_python_reqs()
+        logging.debug(
+            f"\nApplication {self.name}: Post-update dependencies:\n"
+            f"Packages: {packages}\n"
+            f"Python Requirements: {modules}"
+        )
+        if not force:
+            packages = list(set(packages) - set(dep_info["system_packages"]))
+            modules = list(set(modules) - set(dep_info["python_modules"]))
+        logging.debug(
+            f"\nApplication {self.name}: Dependencies to install:\n"
+            f"Packages: {packages}\n"
+            f"Python Requirements: {modules}\n"
+            f"Force All: {force}"
+        )
+        if packages:
+            await self._install_packages(packages)
+        if modules:
+            await self._update_python_requirements(self.python_reqs or modules)
+        npm_hash: Optional[str] = dep_info["npm_hash"]
+        ret = await self._check_need_update(npm_hash, self.npm_pkg_json)
+        if force or ret:
+            if self.npm_pkg_json is not None:
+                self.notify_status("Updating Node Packages...")
+                try:
+                    await self.cmd_helper.run_cmd(
+                        "npm ci --only=prod", notify=True, timeout=600.,
+                        cwd=str(self.path)
+                    )
+                except Exception:
+                    self.notify_status("Node Package Update failed")
