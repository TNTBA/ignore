Differences in klippy/extras/gcode_arcs.py:

- Lines with differences: 77 lines in 4 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/extras/gcode_arcs.py	2023-10-20 03:52:16.772163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/extras/gcode_arcs.py	2024-10-08 17:45:26.565216281 -0400
@@ -39,8 +39,6 @@
         self.gcode.register_command("G18", self.cmd_G18)
         self.gcode.register_command("G19", self.cmd_G19)
 
-        self.Coord = self.gcode.Coord
-
         # backwards compatibility, prior implementation only supported XY
         self.plane = ARC_PLANE_X_Y
 
@@ -64,52 +62,36 @@
         if not gcodestatus['absolute_coordinates']:
             raise gcmd.error("G2/G3 does not support relative move mode")
         currentPos = gcodestatus['gcode_position']
+        absolut_extrude = gcodestatus['absolute_extrude']
 
         # Parse parameters
-        asTarget = self.Coord(x=gcmd.get_float("X", currentPos[0]),
-                              y=gcmd.get_float("Y", currentPos[1]),
-                              z=gcmd.get_float("Z", currentPos[2]),
-                              e=None)
+        asTarget = [gcmd.get_float("X", currentPos[0]),
+                    gcmd.get_float("Y", currentPos[1]),
+                    gcmd.get_float("Z", currentPos[2])]
 
         if gcmd.get_float("R", None) is not None:
             raise gcmd.error("G2/G3 does not support R moves")
 
         # determine the plane coordinates and the helical axis
-        asPlanar = [ gcmd.get_float(a, 0.) for i,a in enumerate('IJ') ]
+        I = gcmd.get_float('I', 0.)
+        J = gcmd.get_float('J', 0.)
+        asPlanar = (I, J)
         axes = (X_AXIS, Y_AXIS, Z_AXIS)
         if self.plane == ARC_PLANE_X_Z:
-            asPlanar = [ gcmd.get_float(a, 0.) for i,a in enumerate('IK') ]
+            K = gcmd.get_float('K', 0.)
+            asPlanar = (I, K)
             axes = (X_AXIS, Z_AXIS, Y_AXIS)
         elif self.plane == ARC_PLANE_Y_Z:
-            asPlanar = [ gcmd.get_float(a, 0.) for i,a in enumerate('JK') ]
+            K = gcmd.get_float('K', 0.)
+            asPlanar = (J, K)
             axes = (Y_AXIS, Z_AXIS, X_AXIS)
 
         if not (asPlanar[0] or asPlanar[1]):
             raise gcmd.error("G2/G3 requires IJ, IK or JK parameters")
 
-        asE = gcmd.get_float("E", None)
-        asF = gcmd.get_float("F", None)
-
-        # Build list of linear coordinates to move
-        coords = self.planArc(currentPos, asTarget, asPlanar,
-                              clockwise, *axes)
-        e_per_move = e_base = 0.
-        if asE is not None:
-            if gcodestatus['absolute_extrude']:
-                e_base = currentPos[3]
-            e_per_move = (asE - e_base) / len(coords)
-
-        # Convert coords into G1 commands
-        for coord in coords:
-            g1_params = {'X': coord[0], 'Y': coord[1], 'Z': coord[2]}
-            if e_per_move:
-                g1_params['E'] = e_base + e_per_move
-                if gcodestatus['absolute_extrude']:
-                    e_base += e_per_move
-            if asF is not None:
-                g1_params['F'] = asF
-            g1_gcmd = self.gcode.create_gcode_command("G1", "G1", g1_params)
-            self.gcode_move.cmd_G1(g1_gcmd)
+        # Build linear coordinates to move
+        self.planArc(currentPos, asTarget, asPlanar, clockwise,
+                     gcmd, absolut_extrude, *axes)
 
     # function planArc() originates from marlin plan_arc()
     # https://github.com/MarlinFirmware/Marlin
@@ -120,6 +102,7 @@
     #
     # alpha and beta axes are the current plane, helical axis is linear travel
     def planArc(self, currentPos, targetPos, offset, clockwise,
+                gcmd, absolut_extrude,
                 alpha_axis, beta_axis, helical_axis):
         # todo: sometimes produces full circles
 
@@ -159,23 +142,42 @@
         # Generate coordinates
         theta_per_segment = angular_travel / segments
         linear_per_segment = linear_travel / segments
-        coords = []
-        for i in range(1, int(segments)):
+
+        asE = gcmd.get_float("E", None)
+        asF = gcmd.get_float("F", None)
+
+        e_per_move = e_base = 0.
+        if asE is not None:
+            if absolut_extrude:
+                e_base = currentPos[3]
+            e_per_move = (asE - e_base) / segments
+
+        for i in range(1, int(segments) + 1):
             dist_Helical = i * linear_per_segment
-            cos_Ti = math.cos(i * theta_per_segment)
-            sin_Ti = math.sin(i * theta_per_segment)
+            c_theta = i * theta_per_segment
+            cos_Ti = math.cos(c_theta)
+            sin_Ti = math.sin(c_theta)
             r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti
             r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti
 
-            # Coord doesn't support index assignment, create list
-            c = [None, None, None, None]
+            c = [None, None, None]
             c[alpha_axis] = center_P + r_P
             c[beta_axis] = center_Q + r_Q
             c[helical_axis] = currentPos[helical_axis] + dist_Helical
-            coords.append(self.Coord(*c))
 
-        coords.append(targetPos)
-        return coords
+
+            if i == segments:
+                c = targetPos
+            # Convert coords into G1 commands
+            g1_params = {'X': c[0], 'Y': c[1], 'Z': c[2]}
+            if e_per_move:
+                g1_params['E'] = e_base + e_per_move
+                if absolut_extrude:
+                    e_base += e_per_move
+            if asF is not None:
+                g1_params['F'] = asF
+            g1_gcmd = self.gcode.create_gcode_command("G1", "G1", g1_params)
+            self.gcode_move.cmd_G1(g1_gcmd)
 
 def load_config(config):
     return ArcSupport(config)
