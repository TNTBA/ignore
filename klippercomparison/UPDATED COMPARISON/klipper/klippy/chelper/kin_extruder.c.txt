Differences in klippy/chelper/kin_extruder.c:

- Lines with differences: 78 lines in 6 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/klippy/chelper/kin_extruder.c	2023-10-20 03:52:16.740163936 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/klippy/chelper/kin_extruder.c	2024-10-08 17:45:26.556216248 -0400
@@ -9,9 +9,15 @@
 #include <string.h> // memset
 #include "compiler.h" // __visible
 #include "itersolve.h" // struct stepper_kinematics
+#include "list.h" // list_node
 #include "pyhelper.h" // errorf
 #include "trapq.h" // move_get_distance
 
+struct pa_params {
+    double pressure_advance, active_print_time;
+    struct list_node node;
+};
+
 // Without pressure advance, the extruder stepper position is:
 //     extruder_position(t) = nominal_position(t)
 // When pressure advance is enabled, additional filament is pushed
@@ -52,17 +58,25 @@
 
 // Calculate the definitive integral of extruder for a given move
 static double
-pa_move_integrate(struct move *m, double pressure_advance
+pa_move_integrate(struct move *m, struct list_head *pa_list
                   , double base, double start, double end, double time_offset)
 {
     if (start < 0.)
         start = 0.;
     if (end > m->move_t)
         end = m->move_t;
-    // Calculate base position and velocity with pressure advance
+    // Determine pressure_advance value
     int can_pressure_advance = m->axes_r.y != 0.;
-    if (!can_pressure_advance)
-        pressure_advance = 0.;
+    double pressure_advance = 0.;
+    if (can_pressure_advance) {
+        struct pa_params *pa = list_last_entry(pa_list, struct pa_params, node);
+        while (unlikely(pa->active_print_time > m->print_time) &&
+                !list_is_first(&pa->node, pa_list)) {
+            pa = list_prev_entry(pa, node);
+        }
+        pressure_advance = pa->pressure_advance;
+    }
+    // Calculate base position and velocity with pressure advance
     base += pressure_advance * m->start_v;
     double start_v = m->start_v + pressure_advance * 2. * m->half_accel;
     // Calculate definitive integral
@@ -75,20 +89,20 @@
 // Calculate the definitive integral of the extruder over a range of moves
 static double
 pa_range_integrate(struct move *m, double move_time
-                   , double pressure_advance, double hst)
+                   , struct list_head *pa_list, double hst)
 {
     // Calculate integral for the current move
     double res = 0., start = move_time - hst, end = move_time + hst;
     double start_base = m->start_pos.x;
-    res += pa_move_integrate(m, pressure_advance, 0., start, move_time, start);
-    res -= pa_move_integrate(m, pressure_advance, 0., move_time, end, end);
+    res += pa_move_integrate(m, pa_list, 0., start, move_time, start);
+    res -= pa_move_integrate(m, pa_list, 0., move_time, end, end);
     // Integrate over previous moves
     struct move *prev = m;
     while (unlikely(start < 0.)) {
         prev = list_prev_entry(prev, node);
         start += prev->move_t;
         double base = prev->start_pos.x - start_base;
-        res += pa_move_integrate(prev, pressure_advance, base, start
+        res += pa_move_integrate(prev, pa_list, base, start
                                  , prev->move_t, start);
     }
     // Integrate over future moves
@@ -96,14 +110,15 @@
         end -= m->move_t;
         m = list_next_entry(m, node);
         double base = m->start_pos.x - start_base;
-        res -= pa_move_integrate(m, pressure_advance, base, 0., end, end);
+        res -= pa_move_integrate(m, pa_list, base, 0., end, end);
     }
     return res;
 }
 
 struct extruder_stepper {
     struct stepper_kinematics sk;
-    double pressure_advance, half_smooth_time, inv_half_smooth_time2;
+    struct list_head pa_list;
+    double half_smooth_time, inv_half_smooth_time2;
 };
 
 static double
@@ -116,22 +131,45 @@
         // Pressure advance not enabled
         return m->start_pos.x + move_get_distance(m, move_time);
     // Apply pressure advance and average over smooth_time
-    double area = pa_range_integrate(m, move_time, es->pressure_advance, hst);
+    double area = pa_range_integrate(m, move_time, &es->pa_list, hst);
     return m->start_pos.x + area * es->inv_half_smooth_time2;
 }
 
 void __visible
-extruder_set_pressure_advance(struct stepper_kinematics *sk
+extruder_set_pressure_advance(struct stepper_kinematics *sk, double print_time
                               , double pressure_advance, double smooth_time)
 {
     struct extruder_stepper *es = container_of(sk, struct extruder_stepper, sk);
-    double hst = smooth_time * .5;
+    double hst = smooth_time * .5, old_hst = es->half_smooth_time;
     es->half_smooth_time = hst;
     es->sk.gen_steps_pre_active = es->sk.gen_steps_post_active = hst;
+
+    // Cleanup old pressure advance parameters
+    double cleanup_time = sk->last_flush_time - (old_hst > hst ? old_hst : hst);
+    struct pa_params *first_pa = list_first_entry(
+            &es->pa_list, struct pa_params, node);
+    while (!list_is_last(&first_pa->node, &es->pa_list)) {
+        struct pa_params *next_pa = list_next_entry(first_pa, node);
+        if (next_pa->active_print_time >= cleanup_time) break;
+        list_del(&first_pa->node);
+        first_pa = next_pa;
+    }
+
     if (! hst)
         return;
     es->inv_half_smooth_time2 = 1. / (hst * hst);
-    es->pressure_advance = pressure_advance;
+
+    if (list_last_entry(&es->pa_list, struct pa_params, node)->pressure_advance
+            == pressure_advance) {
+        // Retain old pa_params
+        return;
+    }
+    // Add new pressure advance parameters
+    struct pa_params *pa = malloc(sizeof(*pa));
+    memset(pa, 0, sizeof(*pa));
+    pa->pressure_advance = pressure_advance;
+    pa->active_print_time = print_time;
+    list_add_tail(&pa->node, &es->pa_list);
 }
 
 struct stepper_kinematics * __visible
@@ -141,5 +179,22 @@
     memset(es, 0, sizeof(*es));
     es->sk.calc_position_cb = extruder_calc_position;
     es->sk.active_flags = AF_X;
+    list_init(&es->pa_list);
+    struct pa_params *pa = malloc(sizeof(*pa));
+    memset(pa, 0, sizeof(*pa));
+    list_add_tail(&pa->node, &es->pa_list);
     return &es->sk;
 }
+
+void __visible
+extruder_stepper_free(struct stepper_kinematics *sk)
+{
+    struct extruder_stepper *es = container_of(sk, struct extruder_stepper, sk);
+    while (!list_empty(&es->pa_list)) {
+        struct pa_params *pa = list_first_entry(
+                &es->pa_list, struct pa_params, node);
+        list_del(&pa->node);
+        free(pa);
+    }
+    free(sk);
+}
