Differences in src/sensor_adxl345.c:

- Lines with differences: 116 lines in 8 blocks

Detailed Differences:

--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/home/mks/klipper/src/sensor_adxl345.c	2023-10-20 03:52:19.636163937 -0400
+++ /home/mks/firmware_comparison/downloads/klipper/src/sensor_adxl345.c	2024-10-08 17:45:26.898217504 -0400
@@ -1,6 +1,6 @@
 // Support for gathering acceleration data from ADXL345 chip
 //
-// Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
+// Copyright (C) 2020-2023  Kevin O'Connor <kevin@koconnor.net>
 //
 // This file may be distributed under the terms of the GNU GPLv3 license.
 
@@ -10,19 +10,19 @@
 #include "basecmd.h" // oid_alloc
 #include "command.h" // DECL_COMMAND
 #include "sched.h" // DECL_TASK
+#include "sensor_bulk.h" // sensor_bulk_report
 #include "spicmds.h" // spidev_transfer
 
 struct adxl345 {
     struct timer timer;
     uint32_t rest_ticks;
     struct spidev_s *spi;
-    uint16_t sequence, limit_count;
-    uint8_t flags, data_count;
-    uint8_t data[50];
+    uint8_t flags;
+    struct sensor_bulk sb;
 };
 
 enum {
-    AX_HAVE_START = 1<<0, AX_RUNNING = 1<<1, AX_PENDING = 1<<2,
+    AX_PENDING = 1<<0,
 };
 
 static struct task_wake adxl345_wake;
@@ -47,27 +47,6 @@
 }
 DECL_COMMAND(command_config_adxl345, "config_adxl345 oid=%c spi_oid=%c");
 
-// Report local measurement buffer
-static void
-adxl_report(struct adxl345 *ax, uint8_t oid)
-{
-    sendf("adxl345_data oid=%c sequence=%hu data=%*s"
-          , oid, ax->sequence, ax->data_count, ax->data);
-    ax->data_count = 0;
-    ax->sequence++;
-}
-
-// Report buffer and fifo status
-static void
-adxl_status(struct adxl345 *ax, uint_fast8_t oid
-            , uint32_t time1, uint32_t time2, uint_fast8_t fifo)
-{
-    sendf("adxl345_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-          " buffered=%c fifo=%c limit_count=%hu"
-          , oid, time1, time2-time1, ax->sequence
-          , ax->data_count, fifo, ax->limit_count);
-}
-
 // Helper code to reschedule the adxl345_event() timer
 static void
 adxl_reschedule_timer(struct adxl345 *ax)
@@ -79,7 +58,6 @@
 }
 
 // Chip registers
-#define AR_POWER_CTL   0x2D
 #define AR_DATAX0      0x32
 #define AR_FIFO_STATUS 0x39
 #define AM_READ  0x80
@@ -87,6 +65,8 @@
 
 #define SET_FIFO_CTL 0x90
 
+#define BYTES_PER_SAMPLE 5
+
 // Query accelerometer data
 static void
 adxl_query(struct adxl345 *ax, uint8_t oid)
@@ -96,7 +76,7 @@
     spidev_transfer(ax->spi, 1, sizeof(msg), msg);
     // Extract x, y, z measurements
     uint_fast8_t fifo_status = msg[8] & ~0x80; // Ignore trigger bit
-    uint8_t *d = &ax->data[ax->data_count];
+    uint8_t *d = &ax->sb.data[ax->sb.data_count];
     if (((msg[2] & 0xf0) && (msg[2] & 0xf0) != 0xf0)
         || ((msg[4] & 0xf0) && (msg[4] & 0xf0) != 0xf0)
         || ((msg[6] & 0xf0) && (msg[6] & 0xf0) != 0xf0)
@@ -112,94 +92,56 @@
         d[3] = (msg[2] & 0x1f) | (msg[6] << 5); // x high bits and z high bits
         d[4] = (msg[4] & 0x1f) | ((msg[6] << 2) & 0x60); // y high and z high
     }
-    ax->data_count += 5;
-    if (ax->data_count + 5 > ARRAY_SIZE(ax->data))
-        adxl_report(ax, oid);
+    ax->sb.data_count += BYTES_PER_SAMPLE;
+    if (ax->sb.data_count + BYTES_PER_SAMPLE > ARRAY_SIZE(ax->sb.data))
+        sensor_bulk_report(&ax->sb, oid);
     // Check fifo status
     if (fifo_status >= 31)
-        ax->limit_count++;
-    if (fifo_status > 1 && fifo_status <= 32) {
+        ax->sb.possible_overflows++;
+    if (fifo_status > 1) {
         // More data in fifo - wake this task again
         sched_wake_task(&adxl345_wake);
-    } else if (ax->flags & AX_RUNNING) {
+    } else {
         // Sleep until next check time
-        sched_del_timer(&ax->timer);
         ax->flags &= ~AX_PENDING;
         adxl_reschedule_timer(ax);
     }
 }
 
-// Startup measurements
-static void
-adxl_start(struct adxl345 *ax, uint8_t oid)
-{
-    sched_del_timer(&ax->timer);
-    ax->flags = AX_RUNNING;
-    uint8_t msg[2] = { AR_POWER_CTL, 0x08 };
-    spidev_transfer(ax->spi, 0, sizeof(msg), msg);
-    adxl_reschedule_timer(ax);
-}
-
-// End measurements
-static void
-adxl_stop(struct adxl345 *ax, uint8_t oid)
-{
-    // Disable measurements
-    sched_del_timer(&ax->timer);
-    ax->flags = 0;
-    uint8_t msg[2] = { AR_POWER_CTL, 0x00 };
-    uint32_t end1_time = timer_read_time();
-    spidev_transfer(ax->spi, 0, sizeof(msg), msg);
-    uint32_t end2_time = timer_read_time();
-    // Drain any measurements still in fifo
-    uint_fast8_t i;
-    for (i=0; i<33; i++) {
-        msg[0] = AR_FIFO_STATUS | AM_READ;
-        msg[1] = 0x00;
-        spidev_transfer(ax->spi, 1, sizeof(msg), msg);
-        uint_fast8_t fifo_status = msg[1] & ~0x80;
-        if (!fifo_status)
-            break;
-        if (fifo_status <= 32)
-            adxl_query(ax, oid);
-    }
-    // Report final data
-    if (ax->data_count)
-        adxl_report(ax, oid);
-    adxl_status(ax, oid, end1_time, end2_time, msg[1]);
-}
-
 void
 command_query_adxl345(uint32_t *args)
 {
     struct adxl345 *ax = oid_lookup(args[0], command_config_adxl345);
 
-    if (!args[2]) {
+    sched_del_timer(&ax->timer);
+    ax->flags = 0;
+    if (!args[1])
         // End measurements
-        adxl_stop(ax, args[0]);
         return;
-    }
+
     // Start new measurements query
-    sched_del_timer(&ax->timer);
-    ax->timer.waketime = args[1];
-    ax->rest_ticks = args[2];
-    ax->flags = AX_HAVE_START;
-    ax->sequence = ax->limit_count = 0;
-    ax->data_count = 0;
-    sched_add_timer(&ax->timer);
+    ax->rest_ticks = args[1];
+    sensor_bulk_reset(&ax->sb);
+    adxl_reschedule_timer(ax);
 }
-DECL_COMMAND(command_query_adxl345,
-             "query_adxl345 oid=%c clock=%u rest_ticks=%u");
+DECL_COMMAND(command_query_adxl345, "query_adxl345 oid=%c rest_ticks=%u");
 
 void
 command_query_adxl345_status(uint32_t *args)
 {
     struct adxl345 *ax = oid_lookup(args[0], command_config_adxl345);
     uint8_t msg[2] = { AR_FIFO_STATUS | AM_READ, 0x00 };
+
     uint32_t time1 = timer_read_time();
     spidev_transfer(ax->spi, 1, sizeof(msg), msg);
     uint32_t time2 = timer_read_time();
-    adxl_status(ax, args[0], time1, time2, msg[1]);
+
+    uint_fast8_t fifo_status = msg[1] & ~0x80; // Ignore trigger bit
+    if (fifo_status > 32)
+        // Query error - don't send response - host will retry
+        return;
+    sensor_bulk_status(&ax->sb, args[0], time1, time2-time1
+                       , fifo_status * BYTES_PER_SAMPLE);
 }
 DECL_COMMAND(command_query_adxl345_status, "query_adxl345_status oid=%c");
 
@@ -212,11 +154,7 @@
     struct adxl345 *ax;
     foreach_oid(oid, ax, command_config_adxl345) {
         uint_fast8_t flags = ax->flags;
-        if (!(flags & AX_PENDING))
-            continue;
-        if (flags & AX_HAVE_START)
-            adxl_start(ax, oid);
-        else
+        if (flags & AX_PENDING)
             adxl_query(ax, oid);
     }
 }
