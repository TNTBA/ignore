--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/etc/network/if-pre-up.d/ifenslave	2016-09-27 08:23:58.000000000 -0400
+++ /media/mks/armbi_root/etc/network/if-pre-up.d/ifenslave	2021-10-17 00:02:24.000000000 -0400
@@ -6,18 +6,10 @@
 
 add_master()
 {
-	# Return if $BOND_MASTER is already a bonding interface.
-	[ -f "/sys/class/net/$BOND_MASTER/bonding/slaves" ] && return
+	# Return if $IFACE is already a bonding interface.
+	[ -f "/sys/class/net/$IFACE/bonding/slaves" ] && return
 
-	# If the bonding module is not yet loaded, load it.
-	if [ ! -r /sys/class/net/bonding_masters ]; then
-		modprobe -q bonding
-	fi
-
-	# Create the master interface.
-	if ! grep -sq "\\<$BOND_MASTER\\>" /sys/class/net/bonding_masters; then
-		echo "+$BOND_MASTER" > /sys/class/net/bonding_masters
-	fi
+	ip link add dev "$IFACE" type bond
 }
 
 sysfs_change_down()
@@ -25,7 +17,7 @@
 	# Called with :
 	# $1 = basename of the file in bonding/ to write to.
 	# $2 = value to write. Won't write if $2 is empty.
-	if [ "$2" ] ; then
+	if [ -n "$2" ] ; then
 		# If the value we plan to write is different from the current one...
 		if ! grep -sq "\\<$2\\>" "/sys/class/net/$BOND_MASTER/bonding/$1" ; then
 			# ...and the master is up...
@@ -43,7 +35,7 @@
 	# Called with :
 	# $1 = basename of the file in bonding/ to write to.
 	# $2 = value to write. Won't write if $2 is empty.
-	if [ "$2" ] ; then
+	if [ -n "$2" ] ; then
 		echo "$2" > "/sys/class/net/$BOND_MASTER/bonding/$1"
 		return $?
 	fi
@@ -57,10 +49,10 @@
 	# $2 = values to write.
 	for value in $2; do
 		# Do not add $2 to $1 if already present.
-		if ! grep -sq "\\<$value\\>" /sys/class/net/$BOND_MASTER/bonding/$1
+		if ! grep -sq "\\<$value\\>" "/sys/class/net/$BOND_MASTER/bonding/$1"
 		then
 		    sysfs "$1" "+$value"
-		fi 
+		fi
 	done
 }
 
@@ -68,7 +60,7 @@
 early_setup_master()
 {
 	# Warning: the order in which we write into the sysfs files is important.
-	# Double check in drivers/net/bonding/bond_sysfs.c in linux kernel source tree 
+	# Double check in drivers/net/bonding/bond_sysfs.c in the Linux kernel source tree
 	# before changing anything here.
 
 	# fail_over_mac must be set before enslavement of any slaves.
@@ -82,15 +74,18 @@
 			BOND_SLAVES=""
 			;;
 		all)
-			BOND_SLAVES=`sed -ne 's/ *\(eth[^:]*\):.*/\1/p' /proc/net/dev`
-			AUTOIF="yes"
+			BOND_SLAVES=$(sed -ne 's/ *\(eth[^:]*\):.*/\1/p' /proc/net/dev)
 			;;
 	esac
 
 	[ "$VERBOSITY" = 1 ] && v=-v
 	for slave in $BOND_SLAVES ; do
-		if ( [ "$AUTOIF" ] && ifquery --state $slave ) ; then
-			echo "Not enslaving interface $slave since it is already configured"
+		export IFENSLAVE_ENV_NAME="IFUPDOWN_$slave"
+		IFUPDOWN_IFACE="$(printenv "$IFENSLAVE_ENV_NAME")"
+		unset IFENSLAVE_ENV_NAME
+		if ( ( ifquery --state "$slave" >/dev/null 2>&1 ) && ( ifquery "$slave" | grep -q bond-master ) ) || [ -n "$IFUPDOWN_IFACE" ] ; then
+			# Skipping interface that's already up or being configured and has bonding configuration
+			continue
 		else
 			# Ensure $slave is down.
 			ip link set "$slave" down 2>/dev/null
@@ -108,7 +103,7 @@
 setup_master()
 {
 	# Warning: the order in which we write into the sysfs files is important.
-	# Double check in drivers/net/bonding/bond_sysfs.c in linux kernel source tree 
+	# Double check in drivers/net/bonding/bond_sysfs.c in the Linux kernel source tree
 	# before changing anything here.
 
 	# use_carrier can be set anytime.
@@ -118,10 +113,6 @@
 	# num_unsol_na can be set anytime.
 	sysfs num_unsol_na "$IF_BOND_NUM_UNSOL_NA"
 
-	# xmit_hash_policy can be set anytime.
-	# Changing xmit_hash_policy requires $BOND_MASTER to be down.
-	sysfs_change_down xmit_hash_policy "$IF_BOND_XMIT_HASH_POLICY"
-
 	# arp_ip_target must be set before arp_interval.
 	sysfs_add arp_ip_target "$IF_BOND_ARP_IP_TARGET"
 	sysfs arp_interval "$IF_BOND_ARP_INTERVAL"
@@ -138,6 +129,10 @@
 	# Mode should be set after miimon or arp_interval, to avoid a warning in syslog.
 	sysfs_change_down mode "$IF_BOND_MODE"
 
+	# Requires $BOND_MASTER to be down and mode to be configured
+	sysfs_change_down xmit_hash_policy "$IF_BOND_XMIT_HASH_POLICY"
+	sysfs_change_down tlb_dynamic_lb "$IF_BOND_TLB_DYNAMIC_LB"
+
 	# packets_per_slave allowed for mode balance-rr only.
 	sysfs packets_per_slave "$IF_BOND_PACKETS_PER_SLAVE"
 
@@ -149,22 +144,26 @@
 	sysfs_change_down lacp_rate "$IF_BOND_LACP_RATE"
 
 	# queue_id must be set after enslavement.
-	for iface_queue_id in $IF_BOND_QUEUE_ID
-	do
-		sysfs iface_queue_id $iface_queue_id
+	for iface_queue_id in $IF_BOND_QUEUE_ID ; do
+		sysfs iface_queue_id "$iface_queue_id"
 	done
 
 	# active_slave must be set after mode and after enslavement.
 	# The slave must be up and the underlying link must be up too.
 	# FIXME: We should have a way to write an empty string to active_slave, to set the active_slave to none.
-	if [ "$IF_BOND_ACTIVE_SLAVE" ] ; then
-		# Need to force interface up before. Bonding will refuse to activate a down interface.
-		ip link set "$IF_BOND_ACTIVE_SLAVE" up
-		sysfs active_slave "$IF_BOND_ACTIVE_SLAVE"
+	if [ -n "$IF_BOND_ACTIVE_SLAVE" ] ; then
+		if [ "$IF_BOND_ACTIVE_SLAVE" = "none" ] ; then
+			sysfs active_slave ""
+		else
+			# Need to force interface up before. Bonding will refuse to activate a down interface.
+			if ifquery -l "$IF_BOND_ACTIVE_SLAVE" >/dev/null 2>&1 ; then
+				ifup "$IF_BOND_ACTIVE_SLAVE"
+			else
+				ip link set "$IF_BOND_ACTIVE_SLAVE" up
+			fi
+			sysfs active_slave "$IF_BOND_ACTIVE_SLAVE"
+		fi
 	fi
-
-	# Force $BOND_MASTER to be up, if we are called from a slave stanza.
-	[ "$IFACE" != "$BOND_MASTER" ] && ip link set dev "$BOND_MASTER" up
 }
 
 setup_primary() {
@@ -172,7 +171,8 @@
 	# The first slave in bond-primary found in current slaves becomes the primary.
 	# If no slave in bond-primary is found, then the primary does not change.
 	for slave in $IF_BOND_PRIMARY ; do
-		if grep -sq "\\<$slave\\>" "/sys/class/net/$BOND_MASTER/bonding/slaves" ; then
+		slaves="/sys/class/net/$BOND_MASTER/bonding/slaves"
+		if grep -sq "\\<$slave\\>" "$slaves" ; then
 			sysfs primary "$slave"
 			break
 		fi
@@ -184,25 +184,50 @@
 	sysfs primary_reselect "$IF_BOND_PRIMARY_RESELECT"
 }
 
+setup_master_device() {
+	add_master
+	early_setup_master
+	setup_master
+	enslave_slaves
+	setup_primary
+}
+
+setup_slave_device() {
+	# Require the bond master to have an iface stanza
+	if ! ifquery -l "$IF_BOND_MASTER" >/dev/null 2>&1 ; then
+		echo "No iface stanza found for master $IF_BOND_MASTER" >&2
+		exit 1
+	fi
+
+	# Ensure the master is up or being configured
+	export IFENSLAVE_ENV_NAME="IFUPDOWN_$IF_BOND_MASTER"
+	IFUPDOWN_IF_BOND_MASTER="$(printenv "$IFENSLAVE_ENV_NAME")"
+	unset IFENSLAVE_ENV_NAME
+	if [ -z "$IFUPDOWN_IF_BOND_MASTER" ] ; then
+		ifquery --state "$IF_BOND_MASTER" >/dev/null 2>&1 || ifup "$IF_BOND_MASTER"
+	fi
+
+	# Enslave it to the master
+	ip link set "$1" down 2>/dev/null
+	if ! sysfs_add slaves "$1" 2>/dev/null ; then
+		echo "Failed to enslave $1 to $BOND_MASTER." >&2
+	fi
+
+	setup_primary
+}
+
 # Option slaves deprecated, replaced by bond-slaves, but still supported for backward compatibility.
 IF_BOND_SLAVES=${IF_BOND_SLAVES:-$IF_SLAVES}
 
-if [ "$IF_BOND_MASTER" ] ; then
+if [ -n "$IF_BOND_MASTER" ] ; then
+	# FIXME: use function arguments instead of this variable
 	BOND_MASTER="$IF_BOND_MASTER"
-	BOND_SLAVES="$IFACE"
-else
-	if [ "$IF_BOND_SLAVES" ] ; then
-		BOND_MASTER="$IFACE"
-		BOND_SLAVES="$IF_BOND_SLAVES"
-	fi
+	setup_slave_device "$IFACE"
+elif [ -n "$IF_BOND_SLAVES" ] || [ -n "$IF_BOND_MODE" ] ; then
+	# FIXME: use function arguments instead of these variables
+	BOND_MASTER="$IFACE"
+	BOND_SLAVES="$IF_BOND_SLAVES"
+	setup_master_device "$IFACE"
 fi
 
-# Exit if nothing to do...
-[ -z "$BOND_MASTER$BOND_SLAVES" ] && exit
-
-add_master
-early_setup_master
-setup_master
-enslave_slaves
-setup_primary
 exit 0
