--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/bin/deb-systemd-helper	2018-11-21 18:15:24.000000000 -0500
+++ /media/mks/armbi_root/usr/bin/deb-systemd-helper	2022-07-08 20:05:29.000000000 -0400
@@ -76,6 +76,11 @@
 messages to stderr (thus visible in dpkg runs). Please include these when
 filing a bugreport.
 
+=item B<DPKG_ROOT>
+
+Instead of working on the filesystem root /, perform all operations on a chroot
+system in the directory given by DPKG_ROOT.
+
 =back
 
 =cut
@@ -90,6 +95,8 @@
 # only have perl-base, not perl).
 eval { require Data::Dumper; } or *Data::Dumper::Dumper = sub { "no Data::Dumper" };
 
+my $dpkg_root = $ENV{DPKG_ROOT} // '';
+
 use constant {
      SYSTEM_INSTANCE_ENABLED_STATE_DIR => '/var/lib/systemd/deb-systemd-helper-enabled',
      USER_INSTANCE_ENABLED_STATE_DIR   => '/var/lib/systemd/deb-systemd-user-helper-enabled',
@@ -99,13 +106,34 @@
 
 my $quiet = 0;
 my $instance = 'system';
-my $enabled_state_dir = SYSTEM_INSTANCE_ENABLED_STATE_DIR;
-my $masked_state_dir = SYSTEM_INSTANCE_MASKED_STATE_DIR;
+my $enabled_state_dir = $dpkg_root . SYSTEM_INSTANCE_ENABLED_STATE_DIR;
+my $masked_state_dir = $dpkg_root . SYSTEM_INSTANCE_MASKED_STATE_DIR;
 
 # Globals are bad, but in this specific case, it really makes things much
 # easier to write and understand.
 my $changed_sth;
-my $has_systemctl = -x "/bin/systemctl";
+my $has_systemctl = -x "$dpkg_root/bin/systemctl" || -x "$dpkg_root/usr/bin/systemctl";
+
+sub assertdpkgroot {
+    my ($path, $msg) = @_;
+    if (length $ENV{DPKG_ROOT}) {
+        if ($path !~ /^\Q$dpkg_root\E/) {
+            error("doesn't start with dpkg_root: $path $msg");
+        }
+        if ($path =~ /^\Q$dpkg_root$dpkg_root\E/) {
+            error("double dpkg_root: $path $msg");
+        }
+    }
+}
+
+sub assertnotdpkgroot {
+    my ($path, $msg) = @_;
+    if (length $ENV{DPKG_ROOT}) {
+        if ($path =~ /^\Q$dpkg_root\E/) {
+            error("starts with dpkg_root: $path $msg");
+        }
+    }
+}
 
 sub error {
     print STDERR "$0: error: @_\n";
@@ -127,11 +155,11 @@
 
     my $service_path = $scriptname;
 
-    if (-f "/etc/systemd/$instance/$scriptname") {
+    if (-f "$dpkg_root/etc/systemd/$instance/$scriptname") {
         $service_path = "/etc/systemd/$instance/$scriptname";
-    } elsif (-f "/lib/systemd/$instance/$scriptname") {
+    } elsif (-f "$dpkg_root/lib/systemd/$instance/$scriptname") {
         $service_path = "/lib/systemd/$instance/$scriptname";
-    } elsif (-f "/usr/lib/systemd/$instance/$scriptname") {
+    } elsif (-f "$dpkg_root/usr/lib/systemd/$instance/$scriptname") {
         $service_path = "/usr/lib/systemd/$instance/$scriptname";
     }
 
@@ -148,7 +176,7 @@
     debug "Reading state file $dsh_state";
     my @entries;
     if (open(my $fh, '<', $dsh_state)) {
-        @entries = map { chomp; $_ } <$fh>;
+        @entries = map { chomp; "$dpkg_root$_" } <$fh>;
         close($fh);
     }
     return @entries;
@@ -158,6 +186,9 @@
 sub record_in_statefile {
     my ($dsh_state, $service_link) = @_;
 
+    assertdpkgroot($dsh_state, "record_in_statefile");
+    assertnotdpkgroot($service_link, "record_in_statefile");
+
     # Appending a newline makes the following code simpler; we can skip
     # chomp()ing and appending newlines in every print.
     $service_link .= "\n";
@@ -178,7 +209,7 @@
         close($infh);
     }
     print $outfh $service_link unless $line_exists;
-    close($outfh);
+    close($outfh) or error("unable to close $tmpname");
 
     debug "Renaming temp file $tmpname to state file $dsh_state";
     rename($tmpname, $dsh_state) or
@@ -189,17 +220,20 @@
 # when enabling this service file. Not straight-forward because service files
 # can refer to other service files using Also=.
 sub get_link_closure {
-    my ($scriptname, $service_path) = @_;
+    my ($scriptname, $service_path, @visited) = @_;
+    assertnotdpkgroot($service_path, "get_link_closure");
 
     my @links;
+    my @wants_dirs;
 
     my $unit_name = basename($service_path);
+    my $wanted_target = $unit_name;
 
     # The keys parsed from the unit file below can only have unit names
     # as values. Since unit names can't have whitespace in systemd,
     # simply use split and strip any leading/trailing quotes. See
     # systemd-escape(1) for examples of valid unit names.
-    open my $fh, '<', $service_path or error("unable to read $service_path");
+    open my $fh, '<', "$dpkg_root$service_path" or error("unable to read $dpkg_root$service_path");
     while (my $line = <$fh>) {
         chomp($line);
         my $service_link;
@@ -210,15 +244,18 @@
                 my $wants_dir = "/etc/systemd/$instance/$value";
                 $wants_dir .= '.wants' if $1 eq 'WantedBy';
                 $wants_dir .= '.requires' if $1 eq 'RequiredBy';
-                push @links, { dest => $service_path, src => "$wants_dir/$scriptname" };
+                push @wants_dirs, "$wants_dir/";
             }
         }
 
         if ($line =~ /^\s*Also=(.+)$/i) {
             for my $value (split(/\s+/, $1)) {
                 $value =~ s/^(["'])(.*)\g1$/$2/;
-                if ($value ne $unit_name) {
-                    push @links, get_link_closure($value, find_unit($value));
+                if ($value ne $unit_name and not grep $_ eq $value, @visited) {
+                    # We can end up in an infinite recursion, so remember what units we
+                    # already processed to break it
+                    push @visited, $value;
+                    push @links, get_link_closure($value, find_unit($value), @visited);
                 }
             }
         }
@@ -231,9 +268,18 @@
                 }
             }
         }
+
+        if ($line =~ /^\s*DefaultInstance=\s*(["']?+)(.+)\g1\s*$/i) {
+            $wanted_target = $2;
+            $wanted_target = $unit_name =~ s/^(.*\@)(\.\w+)$/$1$wanted_target$2/r;
+        }
     }
     close($fh);
 
+    for my $wants_dir (@wants_dirs) {
+        push @links, { dest => $service_path, src => $wants_dir . $wanted_target };
+    }
+
     return @links;
 }
 
@@ -241,7 +287,10 @@
     my ($scriptname, $service_path) = @_;
 
     my @links = get_link_closure($scriptname, $service_path);
-    my @missing_links = grep { ! -l $_->{src} } @links;
+    foreach my $link (@links) {
+        assertnotdpkgroot($link->{src}, "all_links_installed");
+    }
+    my @missing_links = grep { ! -l "$dpkg_root$_->{src}" } @links;
 
     return (@missing_links == 0);
 }
@@ -250,7 +299,10 @@
     my ($scriptname, $service_path) = @_;
 
     my @links = get_link_closure($scriptname, $service_path);
-    my @existing_links = grep { -l $_->{src} } @links;
+    foreach my $link (@links) {
+        assertnotdpkgroot($link->{src}, "all_links_installed");
+    }
+    my @existing_links = grep { -l "$dpkg_root$_->{src}" } @links;
 
     return (@existing_links == 0);
 }
@@ -268,7 +320,12 @@
             $create_links = 1 unless no_link_installed($scriptname, $service_path);
         } else {
             debug "Using systemctl preset to enable $scriptname";
-            system("/bin/systemctl",
+            my $systemd_root = '/';
+            if ($dpkg_root ne '') {
+                $systemd_root = $dpkg_root;
+            }
+            system("systemctl",
+                   "--root=$systemd_root",
                    $instance eq "user" ? "--global" : "--system",
                    "--preset-mode=enable-only",
                    "preset", $scriptname) == 0
@@ -296,6 +353,10 @@
 
         my $statefile = $service_link;
         $statefile =~ s,^/etc/systemd/$instance/,$enabled_state_dir/,;
+        $service_link = "$dpkg_root$service_link";
+        assertdpkgroot($statefile, "make_systemd_links");
+        assertdpkgroot($service_link, "make_systemd_links");
+        assertnotdpkgroot($service_path, "make_systemd_links");
         next if -e $statefile;
 
         if ($opts{'create_links'} && ! -l $service_link) {
@@ -311,8 +372,8 @@
         # and still only enable unit files on the initial installation
         # of a package.
         make_path(dirname($statefile));
-        open(my $fh, '>>', $statefile);
-        close($fh);
+        open(my $fh, '>>', $statefile) or error("Failed to create/touch $statefile");
+        close($fh) or error("Failed to create/touch $statefile");
     }
 
 }
@@ -329,6 +390,7 @@
 
     my $dsh_state = dsh_state_path($scriptname);
     my @links = get_link_closure($scriptname, $service_path);
+    assertdpkgroot($dsh_state, "update_state");
 
     debug "Old state file contents: " .
         Data::Dumper::Dumper([ state_file_entries($dsh_state) ]);
@@ -340,9 +402,10 @@
         UNLINK => 0);
     chmod(0644, $tmpname);
     for my $link (@links) {
+        assertnotdpkgroot($link->{src}, "update_state");
         print $outfh $link->{src} . "\n";
     }
-    close($outfh);
+    close($outfh) or error("Failed to close $tmpname");
 
     debug "Renaming temp file $tmpname to state file $dsh_state";
     rename($tmpname, $dsh_state) or
@@ -359,6 +422,7 @@
     debug "Contents: " . Data::Dumper::Dumper(\@entries);
 
     for my $link (@entries) {
+        assertdpkgroot($link, "was_enabled");
         if (! -l $link) {
             debug "Link $link is missing, considering $scriptname was-disabled.";
             return 0;
@@ -380,6 +444,8 @@
     my $dsh_state = dsh_state_path($service_path);
     my @entries = state_file_entries($dsh_state);
     debug "Contents: " . Data::Dumper::Dumper(\@entries);
+    assertdpkgroot($dsh_state, "remove_links");
+    assertnotdpkgroot($service_path, "remove_links");
 
     if (is_purge()) {
         unlink($dsh_state) if -e $dsh_state;
@@ -392,9 +458,10 @@
         # • If the user did not disable (= link still exists) the service.
         #   If we don’t do this, the link will be deleted a few lines down,
         #   but not re-created when re-installing the package.
+        assertdpkgroot($link, "remove_links");
         if (is_purge() || -l $link) {
             my $link_state = $link;
-            $link_state =~ s,^/etc/systemd/$instance/,$enabled_state_dir/,;
+            $link_state =~ s,^\Q$dpkg_root\E/etc/systemd/$instance/,$enabled_state_dir/,;
             unlink($link_state);
         }
 
@@ -412,7 +479,7 @@
     # disabling actually worked or not — the case is handled by
     # dh_installsystemd generating an appropriate disable
     # command by parsing the service file at debhelper-time.
-    open(my $fh, '<', $service_path) or return;
+    open(my $fh, '<', "$dpkg_root$service_path") or return;
     while (my $line = <$fh>) {
         chomp($line);
         my $service_link;
@@ -441,7 +508,7 @@
 sub mask_service {
     my ($scriptname, $service_path) = @_;
 
-    my $mask_link = "/etc/systemd/$instance/" . basename($service_path);
+    my $mask_link = "$dpkg_root/etc/systemd/$instance/" . basename($service_path);
 
     if (-e $mask_link) {
         # If the link already exists, don’t do anything.
@@ -463,20 +530,20 @@
     $changed_sth = 1;
 
     my $statefile = $mask_link;
-    $statefile =~ s,^/etc/systemd/$instance/,$masked_state_dir/,;
+    $statefile =~ s,^\Q$dpkg_root\E/etc/systemd/$instance/,$masked_state_dir/,;
 
     # Store the fact that we masked this service, so that we can unmask it on
     # installation time. We cannot unconditionally unmask because that would
     # interfere with the user’s decision to mask a service.
     make_path(dirname($statefile));
-    open(my $fh, '>>', $statefile);
-    close($fh);
+    open(my $fh, '>>', $statefile) or error("Failed to create/touch $statefile");
+    close($fh) or error("Failed to create/touch $statefile");
 }
 
 sub unmask_service {
     my ($scriptname, $service_path) = @_;
 
-    my $mask_link = "/etc/systemd/$instance/" . basename($service_path);
+    my $mask_link = "$dpkg_root/etc/systemd/$instance/" . basename($service_path);
 
     # Not masked? Nothing to do.
     return unless -e $mask_link;
@@ -487,7 +554,7 @@
     }
 
     my $statefile = $mask_link;
-    $statefile =~ s,^/etc/systemd/$instance/,$masked_state_dir/,;
+    $statefile =~ s,^\Q$dpkg_root\E/etc/systemd/$instance/,$masked_state_dir/,;
 
     if (! -e $statefile) {
         debug "Not unmasking $mask_link because the state file $statefile does not exist";
@@ -508,8 +575,8 @@
 
 if ($instance eq 'user') {
     debug "is user unit = yes";
-    $enabled_state_dir = USER_INSTANCE_ENABLED_STATE_DIR;
-    $masked_state_dir = USER_INSTANCE_MASKED_STATE_DIR;
+    $enabled_state_dir = $dpkg_root . USER_INSTANCE_ENABLED_STATE_DIR;
+    $masked_state_dir = $dpkg_root . USER_INSTANCE_MASKED_STATE_DIR;
 }
 
 my $action = shift;
@@ -581,14 +648,14 @@
         remove_links($service_path);
         # Clean up the state dir if it’s empty, or at least clean up all empty
         # subdirectories. Necessary to cleanly pass a piuparts run.
-        rmdir_if_empty(SYSTEM_INSTANCE_ENABLED_STATE_DIR);
-        rmdir_if_empty(USER_INSTANCE_ENABLED_STATE_DIR);
+        rmdir_if_empty($dpkg_root . SYSTEM_INSTANCE_ENABLED_STATE_DIR);
+        rmdir_if_empty($dpkg_root . USER_INSTANCE_ENABLED_STATE_DIR);
 
         # Same with directories below /etc/systemd, where we create symlinks.
         # If systemd is not installed (and no other package shipping service
         # files), this would make piuparts fail, too.
-        rmdir_if_empty($_) for (grep { -d } </etc/systemd/system/*>);
-        rmdir_if_empty($_) for (grep { -d } </etc/systemd/user/*>);
+        rmdir_if_empty($_) for (grep { -d } <$dpkg_root/etc/systemd/system/*>);
+        rmdir_if_empty($_) for (grep { -d } <$dpkg_root/etc/systemd/user/*>);
     }
 
     if ($action eq 'enable') {
@@ -603,14 +670,15 @@
         unmask_service($scriptname, $service_path);
         # Clean up the state dir if it’s empty, or at least clean up all empty
         # subdirectories. Necessary to cleanly pass a piuparts run.
-        rmdir_if_empty('/var/lib/systemd/deb-systemd-helper-masked');
+        rmdir_if_empty($dpkg_root . SYSTEM_INSTANCE_MASKED_STATE_DIR);
+        rmdir_if_empty($dpkg_root . USER_INSTANCE_MASKED_STATE_DIR);
     }
 }
 
 # If we changed anything and this machine is running systemd, tell
 # systemd to reload so that it will immediately pick up our
 # changes.
-if ($changed_sth && $instance eq 'system' && -d "/run/systemd/system") {
+if (!length $ENV{DPKG_ROOT} && $changed_sth && $instance eq 'system' && -d "/run/systemd/system") {
     system("systemctl", "daemon-reload");
 }
 
