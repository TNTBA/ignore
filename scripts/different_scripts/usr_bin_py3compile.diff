--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/bin/py3compile	2019-03-26 06:25:14.000000000 -0400
+++ /media/mks/armbi_root/usr/bin/py3compile	2023-04-09 06:18:11.000000000 -0400
@@ -63,23 +63,45 @@
 
     result = []
     for fn in listdir(name):
+        if fn.startswith('.'):
+            continue
         with open(join(name, fn), 'r', encoding='utf-8') as lines:
             for line in lines:
-                type_, vrange, dname, pattern = line.split('|', 3)
+                if line.startswith('#'):
+                    continue
+                line = line.rstrip('\n')
+
+                try:
+                    type_, vrange, dname, pattern = line.split('|', 3)
+                except ValueError:
+                    pattern = '.*'
+                    type_, vrange, dname = line.split('|', 2)
+                if type_ != 'file':
+                    dname = dname.rstrip('/') + '/'  # make sure it ends with slash
                 vrange = parse_vrange(vrange)
+
                 versions = get_requested_versions(vrange, available=True)
                 if not versions:
                     # pattern doesn't match installed Python versions
                     continue
-                pattern = pattern.rstrip('\n')
-                if type_ == 're':
-                    pattern = compile_regexpr(None, None, pattern)
+
+                if type_ == 're' or pattern:
+                    try:
+                        pattern = compile_regexpr(None, None, pattern)
+                    except Exception:
+                        log.warning('skipping invalid pattern in file %s, line: %s', fn, line)
+                        continue
+
                 result.append((type_, versions, dname, pattern))
     return result
 
 
 def get_exclude_patterns(directory='/', patterns=None, versions=None):
     """Return patterns for files that shouldn't be compiled in given dir."""
+
+    # make sure directory name ends with a slash
+    directory = directory.rstrip('/') + '/'
+
     if versions is not None:
         # make sure it's a set (debsorted returns a list)
         versions = set(versions)
@@ -103,33 +125,42 @@
 
 def filter_files(files, e_patterns, compile_versions):
     """Generate (file, versions_to_compile) pairs."""
-    for fn in files:
+    for fpath in files:
         valid_versions = set(compile_versions)  # all by default
 
         for type_, vers, dname, pattern in e_patterns:
-            if type_ == 'dir' and fn.startswith(dname):
+            if not fpath.startswith(dname):
+                continue
+            rfpath = fpath[len(dname):]  # relative to dname
+
+            if type_ == 'dir':  # fpath.startswith(dname) - see above
+                valid_versions = valid_versions - vers
+            elif type_ == 'file' and fpath == dname:
                 valid_versions = valid_versions - vers
-            elif type_ == 're' and pattern.match(fn):
+            elif type_ == 're' and (pattern.match(fpath) or pattern.match(rfpath)):
+                # NOTE: directory is checked at the beginning of this loop
                 valid_versions = valid_versions - vers
 
             # move to the next file if all versions were removed
             if not valid_versions:
                 break
         if valid_versions:
-            public_dir = PUBLIC_DIR_RE.match(fn)
+            public_dir = PUBLIC_DIR_RE.match(fpath)
             if public_dir and len(public_dir.group(1)) != 1:
-                yield fn, set([getver(public_dir.group(1))])
+                yield fpath, set([getver(public_dir.group(1))])
             else:
-                yield fn, valid_versions
+                yield fpath, valid_versions
 
 
 ### COMPILE ####################################################
 def py_compile(version, optimize, workers):
     if not isinstance(version, str):
         version = vrepr(version)
-    cmd = "/usr/bin/python%s%s -m py_compile -" \
-        % (version, ' -O' if optimize else '')
-    process = Popen(cmd, bufsize=1, shell=True,
+    cmd = ["/usr/bin/python" + version]
+    if optimize:
+        cmd.append("-O")
+    cmd += ["-m", "py_compile",  "-"]
+    process = Popen(cmd, bufsize=0,
                     stdin=PIPE, close_fds=True)
     workers[version] = process  # keep the reference for .communicate()
     stdin = process.stdin
@@ -168,10 +199,12 @@
                 if not force:
                     try:
                         mtime = int(os.stat(fn).st_mtime)
-                        expect = struct.pack('<4sl',
-                                             interpreter.magic_number(version), mtime)
+                        expect = struct.pack('<4sLL',
+                                             interpreter.magic_number(version),
+                                             0,
+                                             mtime & 0xFFFF_FFFF)
                         with open(cfn, 'rb') as chandle:
-                            actual = chandle.read(8)
+                            actual = chandle.read(12)
                         if expect == actual:
                             continue
                     except (IOError, OSError):
@@ -191,7 +224,7 @@
 def main():
     usage = '%prog [-V [X.Y][-][A.B]] DIR_OR_FILE [-X REGEXPR]\n' +\
         '       %prog -p PACKAGE'
-    parser = optparse.OptionParser(usage, version='%prog 3.7.3-1',
+    parser = optparse.OptionParser(usage, version='%prog 3.11.2-1+b1',
                                    option_class=Option)
     parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
                       help='turn verbose mode on')
@@ -253,7 +286,7 @@
             e_patterns = get_exclude_patterns(item, options.regexpr,
                                               compile_versions)
             if not exists(item):
-                log.warn('No such file or directory: %s', item)
+                log.warning('No such file or directory: %s', item)
             else:
                 log.debug('byte compiling %s using Python %s',
                           item, compile_versions)
