--- /media/mks/5dcae443-0796-4029-ae6c-bf5bd2a37067/usr/lib/init/init-d-script	2019-02-14 15:33:13.000000000 -0500
+++ /media/mks/armbi_root/usr/lib/init/init-d-script	2023-04-03 02:25:22.000000000 -0400
@@ -7,18 +7,18 @@
 shift
 
 # Define LSB log_* functions.
-# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
+# Depend on sysvinit-utils (>= 3.05-1) to ensure that this file is present
 # and status_of_proc is working.
 . /lib/lsb/init-functions
 
 # PATH should only include /usr/* if it runs after the mountnfs.sh
 # script.  Scripts running before mountnfs.sh should remove the /usr/*
 # entries.
-PATH=/sbin:/usr/sbin:/bin:/usr/bin
+PATH=/usr/sbin:/usr/bin:/sbin:/bin
 export PATH
 
 is_call_implemented() {
-	command -V $1 > /dev/null 2>&1
+	PATH= command -V $1 >/dev/null 2>&1
 }
 
 do_usage() {
@@ -43,22 +43,11 @@
 # Function that starts the daemon/service
 #
 
-# Return
-#   0 if daemon has been started
-#   1 if daemon was already running
-#   2 if daemon could not be started
 do_start_cmd() {
-	start-stop-daemon --start --quiet ${PIDFILE:+--pidfile ${PIDFILE}} \
-	    $START_ARGS \
-	    --startas $DAEMON --name $NAME --exec $DAEMON --test > /dev/null \
-	    || return 1
-	start-stop-daemon --start --quiet ${PIDFILE:+--pidfile ${PIDFILE}} \
-	    $START_ARGS \
-	    --startas $DAEMON --name $NAME --exec $DAEMON -- $DAEMON_ARGS \
-	    || return 2
-	# Add code here, if necessary, that waits for the process to be ready
-	# to handle requests from services started subsequently which depend
-	# on this one.  As a last resort, sleep for some time.
+	start-stop-daemon --start --quiet \
+	    ${PIDFILE:+--pidfile "$PIDFILE"} \
+	    ${COMMAND_NAME:+--name "$COMMAND_NAME"} \
+	    ${DAEMON:+--exec "$DAEMON"} $START_ARGS -- $DAEMON_ARGS
 }
 
 do_start()
@@ -66,30 +55,30 @@
 	if is_call_implemented do_start_prepare ; then
 		call do_start_prepare
 	fi
-	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
+	log_daemon_msg "Starting $DESC" "$NAME"
 	call do_start_cmd
-	case "$?" in
-		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
-		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
-	esac
+	retval=$?
+	if [ "$retval" = 1 ] && [ no != "$VERBOSE" ] ; then
+		log_progress_msg "is already running"
+	fi
+	retval=$(( $retval > 1 ))
+	vlog_end_msg $retval
 	if is_call_implemented do_start_cleanup ; then
 		call do_start_cleanup
 	fi
+	return $retval
 }
 
 #
 # Function that stops the daemon/service
 #
 
-# Return
-#   0 if daemon has been stopped
-#   1 if daemon was already stopped
-#   2 if daemon could not be stopped
-#   other if a failure occurred
 do_stop_cmd() {
-	start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 \
-	    $STOP_ARGS \
-	    ${PIDFILE:+--pidfile ${PIDFILE}} --name $NAME --exec $DAEMON
+	start-stop-daemon --stop --quiet \
+	    --retry=TERM/0/CONT/30/KILL/5 \
+	    ${PIDFILE:+--pidfile "$PIDFILE"} \
+	    ${COMMAND_NAME:+--name "$COMMAND_NAME"} \
+	    ${DAEMON:+--exec "$DAEMON"} $STOP_ARGS
 	RETVAL="$?"
 	[ "$RETVAL" = 2 ] && return 2
 	# Wait for children to finish too if this is a daemon that forks
@@ -98,10 +87,11 @@
 	# that waits for the process to drop all resources that could be
 	# needed by services started subsequently.  A last resort is to
 	# sleep for some time.
-	start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 \
-	    $STOP_ARGS \
-	    --exec $DAEMON
-	[ "$?" = 2 ] && return 2
+	if [ -n "$DAEMON" ] ; then
+		start-stop-daemon --stop --quiet --oknodo \
+		    --retry=0/30/KILL/5 --exec "$DAEMON" $STOP_ARGS
+		[ "$?" = 2 ] && return 2
+	fi
 	# Many daemons don't delete their pidfiles when they exit.
 	rm -f $PIDFILE
 	return $RETVAL
@@ -112,64 +102,94 @@
 	if is_call_implemented do_stop_prepare ; then
 		call do_stop_prepare
 	fi
-	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
+	vlog_daemon_msg "Stopping $DESC" "$NAME"
 	call do_stop_cmd
-	case "$?" in
-		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
-		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
-	esac
+	retval=$?
+	if [ "$retval" = 1 ] && [ no != "$VERBOSE" ] ; then
+		log_progress_msg "is not running"
+	fi
+	retval=$(( $retval > 1 ))
+	vlog_end_msg $retval
 	if is_call_implemented do_stop_cleanup ; then
 		call do_stop_cleanup
 	fi
+	return $retval
 }
 
 do_restart() {
-	[ "$VERBOSE" != no ] && log_daemon_msg "Restarting $DESC" "$NAME"
+	if is_call_implemented do_restart_prepare ; then
+		call do_restart_prepare
+	fi
+	vlog_daemon_msg "Restarting $DESC" "$NAME"
 	call do_stop_cmd
-	call do_start_cmd
-	case "$?" in
-		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
-		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
-	esac
+	retval=$(( $? > 1 ))
+	if [ $retval -eq 0 ] ; then
+		call do_start_cmd
+		retval=$(( $? > 1 ))
+	fi
+	vlog_end_msg $retval
+	if is_call_implemented do_restart_cleanup ; then
+		call do_restart_cleanup
+	fi
+	return $retval
 }
 
-do_force_reload() {
-	if is_call_implemented do_reload ; then
-		call do_reload
-	else
-		call do_restart
+# Wrapper for do_reload_cmd
+do_reload_wrapper() {
+	if is_call_implemented do_reload_prepare ; then
+		call do_reload_prepare
 	fi
+	vlog_daemon_msg "Reloading $DESC configuration files" "$NAME"
+	call do_reload_cmd
+	retval=$(( $? != 0 ))
+	vlog_end_msg $retval
+	if is_call_implemented do_reload_cleanup ; then
+		call do_reload_cleanup
+	fi
+	return $retval
+}
+
+# To enable this function, RELOAD_SIGNAL should be set to the kill signal
+do_reload_signal() {
+	start-stop-daemon --stop --signal $RELOAD_SIGNAL --quiet \
+	    ${PIDFILE:+--pidfile "$PIDFILE"} \
+	    ${COMMAND_NAME:+--name "$COMMAND_NAME"} \
+	    ${DAEMON:+--exec "$DAEMON"} $RELOAD_ARGS
 }
 
+# Deprecated: use RELOAD_SIGNAL instead for newer scripts
 # Enable this using
 # alias do_reload=do_reload_sigusr1
 do_reload_sigusr1() {
-        log_daemon_msg "Reloading $DESC configuration files" "$NAME"
-        start-stop-daemon --oknodo --stop --signal 1 --quiet \
-          --pidfile "$PIDFILE" --exec "$DAEMON"
-        log_end_msg $?
+	RELOAD_SIGNAL=1
+	do_reload_cmd() { do_reload_signal; }
+	do_reload_wrapper
 }
 
 do_status() {
-	# FIXME: Does it make sense to call `status_of_proc' if PIDFILE is
-	# empty?
-	status_of_proc "$DAEMON" "$NAME" ${PIDFILE:="-p ${PIDFILE}"}
+	status_of_proc ${PIDFILE:+-p "$PIDFILE"} "${DAEMON:-none}" "$NAME"
 }
 
 if [ "$DEBUG" = "true" ] ; then
     set -x
 fi
 
+# Unset configuration variables to make sure that if variable is not assigned a
+# value in init script, it does not use one from environment. See #822918.
+unset DAEMON DAEMON_ARGS DESC NAME COMMAND_NAME PIDFILE \
+    RELOAD_ARGS RELOAD_SIGNAL START_ARGS STOP_ARGS
+
 SCRIPTNAME="$__init_d_script_name"
-scriptbasename="$(basename "$__init_d_script_name")"
+scriptbasename=${__init_d_script_name##*/}
 if [ "$scriptbasename" != "init-d-script" ] ; then
     . "$__init_d_script_name"
 else
     exit 0
 fi
 
-NAME=${NAME:=$(basename $DAEMON)}
-DESC=${DESC:=$NAME}
+: ${NAME:=${DAEMON##*/}}
+: ${DESC:=$NAME}
+: ${COMMAND_NAME:=${NAME}}
 
 # Do not use pid file if $PIDFILE is 'none'.  Otherwise, generate from
 # $NAME or use the value provided by the init.d script.
@@ -179,13 +199,17 @@
     PIDFILE=/var/run/$NAME.pid
 fi
 
+# Read configuration variable file if it is present
+[ -r "/etc/default/${NAME}" ] && . "/etc/default/${NAME}"
+
 # Exit if the package is not installed
 if [ none != "$DAEMON" ] && [ ! -x "$DAEMON" ] ; then
 	exit 0
 fi
 
-# Read configuration variable file if it is present
-[ -r /etc/default/$NAME ] && . /etc/default/$NAME
+# Do not use DAEMON or COMMAND_NAME if they are set to 'none'.
+[ none = "$DAEMON" ] && DAEMON=
+[ none = "$COMMAND_NAME" ] && COMMAND_NAME=
 
 # Load the VERBOSE setting and other rcS variables
 . /lib/init/vars.sh
@@ -193,6 +217,17 @@
     VERBOSE=yes
 fi
 
+# Setup do_reload if not already defined
+if ! is_call_implemented do_reload ; then
+	if ! is_call_implemented do_reload_cmd && [ -n "$RELOAD_SIGNAL" ]
+	then
+		do_reload_cmd() { do_reload_signal; }
+	fi
+	if is_call_implemented do_reload_cmd ; then
+		alias do_reload=do_reload_wrapper
+	fi
+fi
+
 case "$1" in
   start)
 	call do_start
@@ -212,20 +247,26 @@
 	fi
 	;;
   force-reload)
-	call do_force_reload
+	if is_call_implemented do_force_reload ; then
+		call do_force_reload
+	elif is_call_implemented do_reload ; then
+		do_reload
+	else
+		call do_restart
+	fi
 	;;
   restart)
 	call do_restart
 	;;
   try-restart)
-        log_daemon_msg "Trying to restart $DESC" "$NAME"
-	if call do_status > /dev/null 2>&1 ; then
-	    call do_restart
-            log_end_msg $?
+	vlog_daemon_msg "Trying to restart $DESC" "$NAME"
+	if (call do_status) >/dev/null ; then
+		(call do_restart) >/dev/null
 	else
-	    log_progress_msg "is not running."
-            log_end_msg 1
+		[ no != "$VERBOSE" ] && log_progress_msg "is not running"
+		true
     	fi
+	vlog_end_msg $?
 	;;
   '')
 	call do_usage
